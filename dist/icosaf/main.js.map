{"version":3,"sources":["./$_lazy_route_resource lazy namespace object","./src/app/app-routing.module.ts","./src/app/app.component.ts","./src/app/app.component.html","./src/app/app.module.ts","./src/app/components/UC-A/use-case-a.component.ts","./src/app/components/UC-A/use-case-a.component.html","./src/app/components/UCDetails/modal/problem-modal.component.ts","./src/app/components/UCDetails/modal/problem-modal.component.html","./src/app/components/UCDetails/use-case-details.component.ts","./src/app/components/UCDetails/use-case-details.component.html","./src/app/components/agv-details/agv-details.component.ts","./src/app/components/agv-details/agv-details.component.html","./src/app/components/agv-details/error-image-modal/problem-image.component.ts","./src/app/components/agv-details/error-image-modal/problem-image.component.html","./src/app/components/dashboard/dashboard.component.ts","./src/app/components/dashboard/dashboard.component.html","./src/app/components/grid-list/grid-list-uc.component.ts","./src/app/components/grid-list/grid-list-uc.component.html","./src/app/components/login/login-dialog/login-dialog.component.ts","./src/app/components/login/login-dialog/login-dialog.component.html","./src/app/components/notification/notification.component.ts","./src/app/components/notification/notification.component.html","./src/app/components/stats/stats.component.ts","./src/app/components/stats/stats.component.html","./src/app/components/toolbar/toolbar.component.ts","./src/app/components/toolbar/toolbar.component.html","./src/app/external-libraries/canvasjs.min.js","./src/app/model/agv.model.ts","./src/app/model/work-area.model.ts","./src/app/services/SseService/sse-service.service.ts","./src/app/services/UC-A/uca.service.ts","./src/app/services/UC-C/uc-c-service.service.ts","./src/app/services/auth.service.ts","./src/environments/environment.ts","./src/main.ts","crypto (ignored)"],"names":[],"mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,maAAma,uBAAuB,EAAE;AAC5b;AACA,oBAAoB,cAAc;AAClC;AACA,wWAAwW,uBAAuB,EAAE;AACjY;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qBAAqB,wBAAwB,cAAc;AAChE,iFAAiF,UAAU,EAAE,2XAA2X,SAAS,wBAAwB,89CAA89C;AACv9D,cAAc,wBAAwB,01BAA01B;AACh4B,eAAe,wBAAwB,snCAAsnC;AAC7pC,eAAe,wBAAwB,keAAke;AACzgB,iBAAiB,wBAAwB,kXAAkX;AAC3Z;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE,iFAAiF;AACjF,uBAAuB,qGAAqG;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,+CAA+C,4CAA4C;AAC3F;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,iDAAiD;AACjD,+CAA+C,qDAAqD;AACpG,uDAAuD,mGAAmG,sCAAsC,GAAG;AACnM;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA;AACA;AACA;AACA,uDAAuD,2BAA2B;AAClF,oDAAoD;AACpD;AACA,oDAAoD,cAAc;AAClE;AACA,KAAK,mEAAmE;AACxE;AACA;AACA;AACA;AACA,oDAAoD,oMAAoM;AACxP;AACA,gBAAgB;AAChB;AACA;AACA,sCAAsC,qGAAqG;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe,oBAAoB,0BAA0B;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,+CAA+C,OAAO,uDAAuD,mDAAmD,iDAAiD,qDAAqD,uFAAuF,eAAe;AAC5W;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,scAAsc;AACxe;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,6FAA6F;AAC7F,2BAA2B;AAC3B;AACA;AACA;AACA,uCAAuC,+CAA+C;AACtF;AACA;AACA;AACA,wCAAwC,cAAc,0EAA0E,UAAU;AAC1I,yCAAyC,mBAAmB;AAC5D;AACA,cAAc,4BAA4B,WAAW,EAAE,gCAAgC,WAAW,EAAE,mCAAmC,WAAW,EAAE,oCAAoC,eAAe;AACvM,qDAAqD,8BAA8B,EAAE,kCAAkC,eAAe;AACtI,wDAAwD,8BAA8B,EAAE;AACxF,IAAI,KAA6B,kEAAkE,KAA0C,GAAG,iCAAO,EAAE,mCAAE,aAAa,WAAW,EAAE;AAAA,oGAAC,GAAG,SAAoB;AAC7M;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,icAAic,+BAA+B,EAAE;AACle,qIAAqI,YAAY,UAAU,sEAAsE,gDAAgD,gDAAgD,yBAAyB,EAAE,+EAA+E,yBAAyB,EAAE,6EAA6E,yBAAyB,EAAE;AAC9iB,sEAAsE,yBAAyB,qBAAqB,EAAE,8EAA8E,yBAAyB,EAAE,sIAAsI,yBAAyB,EAAE,qIAAqI,yBAAyB,EAAE;AAChiB,yHAAyH,yBAAyB,EAAE,yIAAyI,yBAAyB,EAAE,gMAAgM,+CAA+C;AACviB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,uCAAuC,IAAI;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,uCAAuC,IAAI;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,oDAAoD,+EAA+E,oGAAoG,6EAA6E;AACpT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,gLAAgL,wLAAwL;AACxW,4KAA4K,wLAAwL;AACpW;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA,0DAA0D,oCAAoC,EAAE;AAChG,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sEAAsE,gBAAgB,2BAA2B,eAAe,gCAAgC,+BAA+B;AAC7N;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB,uBAAuB,qBAAqB,+CAA+C,0CAA0C,4DAA4D,mDAAmD,iCAAiC;AAC7T;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA,gDAAgD,oEAAoE;AACpH;AACA,kBAAkB,kDAAkD;AACpE;AACA,kBAAkB,0DAA0D;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,QAAQ,EAAE;AAC9E,8DAA8D,8JAA8J,YAAY,EAAE;AAC1O;AACA,4DAA4D;AAC5D,6GAA6G,kFAAkF,uDAAuD;AACtP,qBAAqB;AACrB;AACA,oDAAoD,uHAAuH,kFAAkF;AAC7P,kDAAkD;AAClD,qBAAqB;AACrB;AACA,qXAAqX,QAAQ,EAAE;AAC/X;AACA;AACA;AACA;AACA,uCAAuC,qCAAqC;AAC5E;AACA;AACA,mCAAmC,sCAAsC;AACzE;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA,mCAAmC,sCAAsC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4EAA4E,8BAA8B,mJAAmJ,mFAAmF,uDAAuD,GAAG,EAAE;AAC7Z,iDAAiD,uHAAuH,mFAAmF,mDAAmD;AAC9S,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4TAA4T,QAAQ,EAAE;AACtU;AACA;AACA,aAAa,+EAA+E,6BAA6B,uFAAuF,kFAAkF,uDAAuD,GAAG,EAAE;AAC9V,6DAA6D,6BAA6B,yEAAyE,kFAAkF,mDAAmD,GAAG,EAAE;AAC7S;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2BAA2B,wBAAwB,uBAAuB,mBAAmB,iBAAiB,WAAW,UAAU,iBAAiB,WAAW,gBAAgB,2CAA2C,yBAAyB,iBAAiB,kBAAkB,sDAAsD;AACpX;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ,EAAE;AAC3D,+CAA+C,qHAAqH,EAAE;AACtK,8CAA8C,uGAAuG,EAAE;AACvJ,2CAA2C,WAAW,qBAAqB,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,+CAA+C,qHAAqH,EAAE;AACtK,8CAA8C,uGAAuG,EAAE;AACvJ,2CAA2C,wCAAwC,qBAAqB,EAAE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ,EAAE;AAC3D,+CAA+C,qHAAqH,EAAE;AACtK;AACA;AACA;AACA,iBAAiB;AACjB,2CAA2C,uCAAuC,qBAAqB,EAAE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6IAA6I,YAAY,EAAE;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E;AACA;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA,oEAAoE,6KAA6K;AACjP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,kEAAkE,WAAW;AAC7E,iBAAiB,eAAe,QAAQ,gBAAgB,iCAAiC;AACzF,gEAAgE,wBAAwB;AACxF,2DAA2D,UAAU,uBAAuB,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA,8DAA8D,WAAW;AACzE;AACA;AACA;AACA;AACA;AACA,qDAAqD,oDAAoD,kGAAkG,EAAE;AAC7M;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,2CAA2C,yBAAyB,oBAAoB,kBAAkB,uBAAuB,8BAA8B;AAC/J,+DAA+D,mBAAmB,uNAAuN,EAAE;AAC3S;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA,uEAAuE,oCAAoC;AAC3G;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAkD;AACjF,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,4KAA4K;AAC5K;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,gCAAgC;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sIAAsI,gCAAgC;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,gCAAgC;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,gCAAgC;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,gCAAgC;AACzH;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+IAA+I;AAC/I;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kLAAkL,gCAAgC;AAClN;AACA;AACA;AACA,sCAAsC,yBAAyB;AAC/D;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,gCAAgC;AAC5I;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA;AACA,mCAAmC;AACnC,gCAAgC;AAChC,iEAAiE,gCAAgC;AACjG;AACA;AACA,2BAA2B,oCAAoC;AAC/D,+DAA+D,wBAAwB;AACvF;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,8BAA8B;AAC9B;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA,yDAAyD,4BAA4B;AACrF;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAmD;AAC1F,2CAA2C,cAAc;AACzD;AACA;AACA;AACA,gDAAgD,wBAAwB,EAAE;AAC1E,mCAAmC,yEAAyE;AAC5G;AACA;AACA,uFAAuF,oCAAoC,EAAE;AAC7H;AACA;AACA;AACA;AACA;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA,mCAAmC,uBAAuB;AAC1D,sCAAsC,yIAAyI;AAC/K;AACA;AACA,0BAA0B,wBAAwB;AAClD,sCAAsC,yIAAyI;AAC/K;AACA,+BAA+B,uBAAuB;AACtD,sCAAsC,yIAAyI;AAC/K;AACA,+BAA+B,wBAAwB;AACvD,sCAAsC;AACtC,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2LAA2L;AAC3L;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qMAAqM,iFAAiF,qBAAqB,yMAAyM,GAAG,EAAE;AACthB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA,qIAAqI,uBAAuB;AAC5J;AACA,uBAAuB,cAAc;AACrC,iEAAiE,aAAa,8BAA8B,aAAa;AACzH;AACA;AACA;AACA,+BAA+B,+CAA+C;AAC9E;AACA;AACA;AACA,2CAA2C,mBAAmB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA,4qBAA4qB,6BAA6B;AACzsB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,uOAAuO,oRAAoR;AAC3f;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gCAAgC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,qDAAqD,+GAA+G;AACpK;AACA,sJAAsJ,4DAA4D,aAAa,iEAAiE;AAChS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gCAAgC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,yCAAyC;AACzC;AACA;AACA;AACA,iHAAiH,+GAA+G;AAChO,sJAAsJ,gEAAgE,aAAa,iEAAiE;AACpS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iHAAiH;AACtK;AACA,sJAAsJ,8DAA8D,aAAa,iEAAiE;AAClS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA,8EAA8E,cAAc;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,kJAAkJ,8DAA8D,iEAAiE,gEAAgE;AACjV,uFAAuF,YAAY;AACnG;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,kJAAkJ,qEAAqE,+BAA+B,gEAAgE,uDAAuD,YAAY;AACzX;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA,8EAA8E,cAAc;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,4DAA4D,wEAAwE,+BAA+B,gEAAgE,uDAAuD,YAAY;AACtS;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,kJAAkJ,2DAA2D,6CAA6C,gEAAgE,uDAAuD,YAAY;AAC7X;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,kJAAkJ,kEAAkE,+BAA+B,gEAAgE,uDAAuD,YAAY;AACtX;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,kJAAkJ,qEAAqE,+BAA+B,gEAAgE,uDAAuD,YAAY;AACzX;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,0BAA0B,8cAA8c,aAAa,EAAE;AACvf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,obAAob,aAAa;AACjc,yCAAyC;AACzC;AACA;AACA,uEAAuE;AACvE;AACA,oLAAoL,+GAA+G;AACnS,sJAAsJ,4DAA4D,aAAa,iEAAiE;AAChS;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kHAAkH;AACvK;AACA,sJAAsJ;AACtJ,gDAAgD,aAAa,kEAAkE;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,4JAA4J,aAAa;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA,kTAAkT,aAAa,uHAAuH,aAAa;AACnc,iLAAiL,sFAAsF,kJAAkJ,+GAA+G;AACxgB,4DAA4D,gEAAgE,aAAa,iEAAiE;AAC1M;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,iHAAiH;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA,iSAAiS,kBAAkB;AACnT,yCAAyC;AACzC,sLAAsL,kBAAkB;AACxM;AACA;AACA;AACA,4EAA4E;AAC5E;AACA,mOAAmO,kHAAkH;AACrV,gJAAgJ,gEAAgE,aAAa,iEAAiE;AAC9R;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,iHAAiH;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA,wfAAwf,kBAAkB;AAC1gB,yCAAyC;AACzC;AACA,qFAAqF,kBAAkB;AACvG;AACA;AACA,2EAA2E;AAC3E;AACA;AACA,8GAA8G,kHAAkH;AAChO,gJAAgJ,mEAAmE,aAAa,iEAAiE;AACjS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F,0GAA0G,cAAc;AACxH;AACA,iIAAiI,gCAAgC;AACjK;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,kJAAkJ,8DAA8D,aAAa,yBAAyB,iFAAiF,eAAe;AACtV;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uOAAuO,sFAAsF,kOAAkO,+DAA+D,aAAa,yBAAyB;AACpoB,uFAAuF,eAAe;AACtG;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA,8EAA8E,cAAc;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,kJAAkJ,4DAA4D,kDAAkD,yBAAyB,uDAAuD,YAAY;AAC5V;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gCAAgC;AAC/F;AACA;AACA,8EAA8E,cAAc;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,4DAA4D,kDAAkD,yBAAyB,uDAAuD,YAAY;AAChS;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA,8EAA8E,cAAc;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,iGAAiG,wDAAwD,uDAAuD,uDAAuD,YAAY,2BAA2B,oFAAoF,wDAAwD,uDAAuD,uDAAuD,YAAY;AACpjB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E,sGAAsG;AACtG;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,gEAAgE,8EAA8E,mHAAmH,uDAAuD,iHAAiH,4BAA4B;AACrc,oEAAoE,8EAA8E,mHAAmH,uDAAuD,iHAAiH,4BAA4B;AACzc;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,4DAA4D,iFAAiF,wDAAwD,uDAAuD,uDAAuD,YAAY,2BAA2B,iFAAiF;AAC3a,uFAAuF,uDAAuD,uDAAuD,YAAY;AACjN;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,6JAA6J,aAAa,0CAA0C,aAAa,kBAAkB,aAAa,iFAAiF,aAAa;AAC9V;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iHAAiH;AACtK;AACA;AACA;AACA,qDAAqD,iHAAiH;AACtK;AACA;AACA,gEAAgE,kFAAkF,aAAa,4EAA4E,2BAA2B,kFAAkF;AACxV,sDAAsD,4EAA4E;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,mDAAmD;AACnD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,yIAAyI;AACzI;AACA;AACA;AACA,qDAAqD,kHAAkH;AACvK;AACA;AACA,gEAAgE,wFAAwF,aAAa,wDAAwD,2BAA2B;AACxP,qGAAqG,aAAa,wDAAwD;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA,0GAA0G,cAAc;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kJAAkJ,iEAAiE;AACnN,iFAAiF,gEAAgE,uDAAuD,YAAY;AACpN;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA;AACA;AACA;AACA,2CAA2C,6BAA6B;AACxE;AACA,iCAAiC;AACjC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,gJAAgJ;AAChJ;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,4BAA4B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA,gDAAgD,wBAAwB,uBAAuB;AAC/F,yBAAyB,yBAAyB,kBAAkB,EAAE,EAAE,YAAY,cAAc;AAClG;AACA;AACA;AACA,kCAAkC;AAClC;AACA,sEAAsE,cAAc;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mLAAmL,6CAA6C;AAChO;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yOAAyO,MAAM,KAAK,EAAE;AACtP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe,uBAAuB,kEAAkE,MAAM,KAAK,EAAE,EAAE,EAAE;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B,cAAc;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb,0BAA0B,mBAAmB,cAAc;AAC3D,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,cAAc;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,6BAA6B,kBAAkB,cAAc;AACzJ;AACA;AACA,qDAAqD,wBAAwB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,uCAAuC,iNAAiN;AACxP;AACA,gCAAgC;AAChC,0JAA0J;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4JAA4J,QAAQ;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU,aAAa;AACxC,uCAAuC;AACvC,kDAAkD,kBAAkB,qBAAqB,UAAU;AACnG;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wDAAwD;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B,sBAAsB,QAAQ;AAC7F,iCAAiC,yBAAyB,4BAA4B,EAAE,EAAE,YAAY,cAAc;AACpH;AACA;AACA;AACA,8BAA8B,UAAU;AACxC,wDAAwD,WAAW;AACnE,8CAA8C;AAC9C,2RAA2R;AAC3R;AACA;AACA;AACA;AACA,8BAA8B,wJAAwJ;AACtL;AACA;AACA,8HAA8H,cAAc,EAAE;AAC9I;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB,cAAc;AACvE,2CAA2C,UAAU,EAAE;AACvD,yBAAyB,6FAA6F,0CAA0C,EAAE;AAClK,6CAA6C,cAAc;AAC3D;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,0BAA0B,uBAAuB,kBAAkB;AACnE,oEAAoE,UAAU;AAC9E;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA,2BAA2B,aAAa,oCAAoC;AAC5E,iBAAiB,UAAU;AAC3B,2BAA2B,aAAa,gDAAgD;AACxF,iBAAiB,UAAU;AAC3B;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA,2BAA2B,gBAAgB,cAAc;AACzD,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wOAAwO,cAAc;AACtP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA,uCAAuC,cAAc;AACrD;AACA,mCAAmC,kBAAkB;AACrD,8OAA8O,0KAA0K,YAAY,2IAA2I;AAC/iB;AACA;AACA;AACA,mCAAmC;AACnC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA,uCAAuC,cAAc;AACrD;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,4DAA4D,6HAA6H;AACzL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAyE,yBAAyB,uDAAuD,EAAE;AAC3L;AACA;AACA;AACA;AACA;AACA;AACA,0KAA0K,gCAAgC;AAC1M,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kCAAkC,KAAK,wFAAwF;AAC/K,uDAAuD,uBAAuB;AAC9E;AACA,sCAAsC,gBAAgB;AACtD;AACA,uDAAuD,YAAY,aAAa,yBAAyB,yBAAyB;AAClI;AACA;AACA;AACA;AACA,0FAA0F,0BAA0B;AACpH;AACA,oCAAoC,WAAW,WAAW,yBAAyB,qCAAqC,EAAE,OAAO,EAAE;AACnI;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA,6EAA6E,0EAA0E;AACvJ;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA,mLAAmL,uEAAuE;AAC1P,0XAA0X;AAC1X;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4RAA4R;AACxV;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA,4DAA4D;AAC5D,2IAA2I,wQAAwQ,sBAAsB;AACza;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA,gEAAgE;AAChE;AACA;AACA,8DAA8D,yDAAyD;AACvH,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAkD;AACvE;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,aAAa;AACrH;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F,yGAAyG;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iEAAiE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iEAAiE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iEAAiE;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,idAAid,iEAAiE;AAClhB;AACA;AACA;AACA;AACA,wbAAwb,gFAAgF;AACxgB;AACA;AACA;AACA;AACA,4CAA4C,wJAAwJ;AACpM;AACA;AACA;AACA,4CAA4C,wJAAwJ;AACpM;AACA;AACA,wCAAwC,wJAAwJ;AAChM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oMAAoM,OAAO;AAC3M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,0BAA0B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yHAAyH,gCAAgC;AACzJ;AACA;AACA;AACA,kCAAkC,mCAAmC;AACrE;AACA;AACA;AACA;AACA,iFAAiF,iGAAiG,6IAA6I;AAC/T,uQAAuQ,sBAAsB,mDAAmD;AAChV;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA,yEAAyE,iGAAiG,6IAA6I;AACvT,6YAA6Y,sBAAsB,mDAAmD;AACtd;AACA;AACA;AACA,6PAA6P,OAAO;AACpQ,yCAAyC,mCAAmC;AAC5E;AACA;AACA;AACA,yEAAyE,2GAA2G;AACpL,8CAA8C,0dAA0d,sBAAsB;AAC9hB,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA,yEAAyE,cAAc;AACvF;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2MAA2M,yBAAyB;AACpO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sIAAsI,8CAA8C;AACpL,yOAAyO;AACzO,4CAA4C,uEAAuE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA,uBAAuB,cAAc;AACrC;AACA,wEAAwE,2DAA2D;AACnI;AACA,uHAAuH,cAAc;AACrI,gFAAgF;AAChF,6SAA6S;AAC7S,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,OAAO;AAC/F;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA,iiBAAiiB,+EAA+E;AAChnB;AACA,mCAAmC,cAAc;AACjD;AACA,qcAAqc,+EAA+E;AACphB;AACA,mCAAmC,cAAc;AACjD;AACA,miBAAmiB,8DAA8D,iBAAiB;AAClnB,0FAA0F;AAC1F;AACA,mCAAmC,cAAc;AACjD;AACA,+MAA+M,8DAA8D,iBAAiB,uEAAuE;AACrW;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD,qDAAqD;AACrD;AACA;AACA,mCAAmC,cAAc;AACjD,qDAAqD;AACrD;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA,2GAA2G,wGAAwG;AACnN;AACA,8CAA8C,QAAQ;AACtD,qLAAqL;AACrL,8FAA8F;AAC9F;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA,iCAAiC;AACjC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA,oDAAoD;AACpD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4fAA4f,cAAc;AAC1gB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wEAAwE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yNAAyN,QAAQ;AACjO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,0JAA0J,QAAQ;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA,uHAAuH,gCAAgC,EAAE;AACzJ;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sFAAsF,YAAY,sBAAsB;AACxH,+NAA+N,EAAE;AACjO;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,yBAAyB;AACxF;AACA;AACA;AACA,gDAAgD,yBAAyB;AACzE;AACA;AACA;AACA;AACA;AACA,kGAAkG,4BAA4B;AAC9H;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA,yBAAyB;AACzB,+BAA+B,cAAc;AAC7C,8IAA8I,YAAY,cAAc;AACxK,0SAA0S,EAAE;AAC5S;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,8IAA8I,YAAY,cAAc;AACxK,kIAAkI,EAAE;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,uDAAuD,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,sCAAsC;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sCAAsC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA;AACA;AACA,2DAA2D,wCAAwC;AACnG;AACA;AACA;AACA;AACA,wDAAwD,kFAAkF,kFAAkF;AAC5N;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAqD;AAC1E;AACA,+BAA+B,2DAA2D;AAC1F;AACA;AACA;AACA;AACA,2BAA2B,2DAA2D;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4CAA4C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4CAA4C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,uDAAuD,yBAAyB,oGAAoG,gBAAgB,OAAO;AAC3M,qBAAqB,UAAU;AAC/B,6CAA6C,6IAA6I,0FAA0F;AACpR;AACA,6BAA6B,oKAAoK,0FAA0F;AAC3R;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mQAAmQ,6CAA6C;AAChT;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,wVAAwV,6CAA6C;AACrY;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+JAA+J;AAC/J;AACA,+JAA+J;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB,uCAAuC;AACzF,4KAA4K;AAC5K;AACA;AACA;AACA;AACA;AACA,iFAAiF,OAAO;AACxF;AACA,6DAA6D,OAAO;AACpE,mCAAmC;AACnC,sDAAsD;AACtD;AACA;AACA;AACA;AACA,4CAA4C,gCAAgC,EAAE;AAC9E;AACA;AACA;AACA,sHAAsH,cAAc;AACpI;AACA;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA,2HAA2H,cAAc;AACzI;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA,2HAA2H,cAAc;AACzI;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA,gHAAgH,cAAc;AAC9H;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA,gFAAgF;AAChF,6GAA6G;AAC7G;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,gFAAgF,8FAA8F;AAC9K;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA,gFAAgF,kFAAkF;AAClK;AACA;AACA;AACA,uFAAuF,8FAA8F;AACrL;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,4EAA4E,iCAAiC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,OAAO,mBAAmB,mCAAmC;AAClI,mKAAmK,8FAA8F;AACjQ;AACA;AACA,uHAAuH,8FAA8F;AACrN,qOAAqO,8FAA8F;AACnU;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA,4CAA4C,gCAAgC,EAAE;AAC9E;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,wEAAwE,iCAAiC;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,OAAO,mBAAmB,mCAAmC;AACnI,+JAA+J,8FAA8F;AAC7P;AACA;AACA,mHAAmH;AACnH,kDAAkD,yMAAyM,8FAA8F;AACzV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iJAAiJ,OAAO;AACxJ,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA,4CAA4C,gCAAgC,EAAE;AAC9E;AACA;AACA,+GAA+G,cAAc;AAC7H;AACA;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA,gHAAgH,cAAc;AAC9H;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA,oHAAoH,cAAc;AAClI;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA,4GAA4G,cAAc;AAC1H;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA,4EAA4E,iGAAiG;AAC7K;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA,4EAA4E,8FAA8F;AAC1K;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,iDAAiD,kFAAkF;AACnI;AACA;AACA,mVAAmV;AACnV,8GAA8G,sVAAsV,8FAA8F;AACliB;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wJAAwJ;AACxJ;AACA;AACA,4HAA4H;AAC5H;AACA;AACA;AACA;AACA,4EAA4E,iCAAiC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,OAAO,mBAAmB,mCAAmC;AACvI;AACA,kKAAkK,mHAAmH;AACrR;AACA;AACA,uHAAuH,mHAAmH,8NAA8N,mHAAmH;AAC3jB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,mHAAmH;AACnM;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,iCAAiC;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,OAAO,mBAAmB,mCAAmC;AACnI,+JAA+J,mHAAmH;AAClR;AACA;AACA;AACA,mHAAmH,mHAAmH,8NAA8N;AACpc,gHAAgH;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,mHAAmH;AAC3L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,aAAa,gBAAgB;AAC3E,wCAAwC;AACxC,8CAA8C;AAC9C,mCAAmC;AACnC,kEAAkE;AAClE,0CAA0C;AAC1C,mDAAmD,YAAY;AAC/D,sCAAsC;AACtC,qCAAqC;AACrC,kEAAkE;AAClE,uCAAuC;AACvC,6CAA6C;AAC7C,2DAA2D,kCAAkC;AAC7F,uCAAuC;AACvC,0CAA0C;AAC1C,yCAAyC;AACzC,4CAA4C;AAC5C,+CAA+C;AAC/C,gDAAgD;AAChD,4CAA4C;AAC5C,wCAAwC;AACxC,wDAAwD,sGAAsG;AAC9J,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6BAA6B;AACxE,sFAAsF,OAAO,mBAAmB,2CAA2C;AAC3J;AACA;AACA;AACA;AACA,uCAAuC,8BAA8B;AACrE,8EAA8E,OAAO;AACrF;AACA;AACA,sCAAsC,4CAA4C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE,kFAAkF,OAAO,mBAAmB,2CAA2C;AACvJ;AACA;AACA;AACA,uCAAuC,8BAA8B;AACrE,mFAAmF,OAAO,mBAAmB,4CAA4C;AACzJ;AACA;AACA;AACA;AACA,4CAA4C,gCAAgC,EAAE;AAC9E;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0BAA0B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,icAAic;AACjc;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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a,EAAE,oCAAoC;AACnD;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oCAAoC;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,WAAW,gCAAgC,sBAAsB,EAAE,sCAAsC,oCAAoC,EAAE,uCAAuC,mDAAmD,EAAE,qCAAqC,6BAA6B,EAAE,sCAAsC,qCAAqC,EAAE,EAAE,EAAE,QAAQ;AACvZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,uDAAuD;AACzE,yBAAyB,8BAA8B,qBAAqB,gDAAgD,GAAG;AAC/H,mBAAmB,sCAAsC,wBAAwB,GAAG;AACpF;AACA;AACA;AACA,sHAAsH,qBAAqB,gBAAgB,gBAAgB,YAAY,aAAa;AACpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB,sHAAsH;AAC3J,kBAAkB,0CAA0C;AAC5D,sBAAsB,yBAAyB,OAAO;AACtD,uBAAuB,OAAO;AAC9B,kCAAkC,OAAO;AACzC;AACA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4FAA4F;AAC/G,iBAAiB,UAAU;AAC3B,yBAAyB,oCAAoC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gCAAgC,gBAAgB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB,oFAAoF,EAAE,mBAAmB,mBAAmB;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4BAA4B,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU,SAAS,sGAAsG;AAClJ;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB,qEAAqE,mBAAmB;AAC3H,sBAAsB;AACtB,yCAAyC;AACzC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mBAAmB,uBAAuB,yBAAyB;AACxE,mBAAmB,qBAAqB,mDAAmD;AAC3F;AACA;AACA;AACA;AACA,aAAa,qBAAqB,mBAAmB,2BAA2B,6DAA6D,EAAE,uBAAuB,sCAAsC,gBAAgB,cAAc;AAC1O,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,QAAQ;AACnC,uBAAuB,QAAQ;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,ykBAAykB,QAAQ,QAAQ,OAAO,+BAA+B;AAC/nB,+BAA+B,yFAAyF,8BAA8B;AACtJ,+BAA+B,wBAAwB;AACvD,gCAAgC,uBAAuB,yBAAyB,iCAAiC,EAAE,sBAAsB,sBAAsB;AAC/J,gCAAgC,uBAAuB,yBAAyB,iCAAiC,EAAE,sBAAsB,sBAAsB;AAC/J;AACA,qCAAqC,mBAAmB,mBAAmB,mBAAmB,kBAAkB;AAChH,gDAAgD,mBAAmB,mBAAmB,MAAM,0GAA0G,aAAa,2EAA2E,KAAK;AACnS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,uFAAuF;AACvF;AACA,oCAAoC,mBAAmB,uBAAuB,2BAA2B,uBAAuB,kBAAkB;AAClJ,0CAA0C,2BAA2B,kBAAkB,mBAAmB,uBAAuB,2BAA2B,uBAAuB,kBAAkB,eAAe,uBAAuB;AAC3O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2BAA2B,WAAW,WAAW,WAAW,WAAW,UAAU;AACrI,0DAA0D,iCAAiC,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,UAAU;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2HAA2H,kBAAkB,kBAAkB;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uFAAuF;AAC7J;AACA;AACA,2CAA2C,wBAAwB;AACnE,sFAAsF;AACtF;AACA;AACA;AACA;AACA,kFAAkF,iBAAiB,kBAAkB;AACrH,sBAAsB,mBAAmB,OAAO,mBAAmB,QAAQ,8BAA8B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C,+BAA+B,yBAAyB,gBAAgB,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oFAAoF;AACjH,mCAAmC,4DAA4D;AAC/F,6BAA6B,cAAc,UAAU,6DAA6D;AAClH,+BAA+B,sBAAsB,sBAAsB,4DAA4D;AACvI;AACA;AACA;AACA;AACA,kDAAkD,gDAAgD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","file":"main.js","sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./$$_lazy_route_resource lazy recursive\";","import { NgModule } from '@angular/core';\r\nimport { Routes, RouterModule } from '@angular/router';\r\nimport { GridListUCComponent } from './components/grid-list/grid-list-uc.component';\r\nimport { UseCaseDetailsComponent } from './components/UCDetails/use-case-details.component';\r\nimport { DashboardComponent } from './components/dashboard/dashboard.component';\r\nimport { LoginDialogComponent } from './components/login/login-dialog/login-dialog.component';\r\nimport { AgvDetailsComponent } from './components/agv-details/agv-details.component';\r\nimport { StatsComponent } from './components/stats/stats.component';\r\nimport { UseCaseAComponent } from './components/UC-A/use-case-a.component';\r\n\r\n\r\n\r\nconst routes: Routes = [\r\n  {\r\n    path: '',\r\n    redirectTo: 'chooseUseCase',\r\n    pathMatch: 'full'\r\n  },\r\n\r\n  {\r\n    path: 'chooseUseCase',\r\n    // canActivate: [AuthGuard],\r\n    component: GridListUCComponent,  \r\n  },\r\n  {\r\n    path:'UseCaseA',\r\n    component: UseCaseAComponent\r\n  },\r\n  {\r\n    path: 'use-case-details',\r\n    component: UseCaseDetailsComponent,\r\n  },\r\n  {\r\n    path: 'Home',\r\n    component: DashboardComponent,\r\n    children: [\r\n      {\r\n        path: 'work-area/:workAreaId/agv-details/:agvId',\r\n        component: AgvDetailsComponent,\r\n        outlet: \"dashboardContent\"\r\n      },\r\n      {\r\n        path: 'work-area/:workAreaId/statistics/:graphType',\r\n        component: StatsComponent,\r\n        outlet: \"dashboardContent\",\r\n      }\r\n    ]\r\n  },\r\n\r\n\r\n\r\n  // {\r\n  //   path: 'logged',\r\n  //   children: [\r\n  //     // {\r\n  //     //   path: 'applicationi-internet/students',\r\n  //     //   component: StudentsContComponent\r\n  //     // },\r\n  //     // {\r\n  //     //   path: 'applicationi-internet/vms',\r\n  //     //   component: VmsContComponentComponent\r\n  //     // }\r\n  //   ]\r\n  // },\r\n];\r\n\r\n\r\n@NgModule({\r\n  imports: [RouterModule.forRoot(routes)],\r\n  exports: [RouterModule]\r\n})\r\nexport class AppRoutingModule { }\r\n","import { AfterViewInit, Component, OnInit, ViewChild } from '@angular/core';\nimport { SseService } from './services/SseService/sse-service.service';\nimport { MatIconRegistry } from '@angular/material/icon';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { MatDialog } from '@angular/material/dialog';\nimport { LoginDialogComponent } from './components/login/login-dialog/login-dialog.component';\nimport { MatSelectionList } from '@angular/material/list';\nimport { NotificationComponent } from './components/notification/notification.component';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n  logIconSelected: boolean\n\n\n  @ViewChild('iconList') iconList: MatSelectionList;\n  @ViewChild('logList') logList: MatSelectionList;\n\n\n\n\n  constructor(\n    private sseService: SseService,\n    iconRegistry: MatIconRegistry,\n    sanitizer: DomSanitizer,\n    private activatedRoute: ActivatedRoute,\n    private router: Router,\n    public dialog: MatDialog,) {\n    this.logIconSelected = false\n\n    iconRegistry.addSvgIcon(\n      'dashboard-icon-selected',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/dashboardIconSelected.svg'));\n    iconRegistry.addSvgIcon(\n      'dashboard-icon',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/dashboardIcon.svg'));\n    iconRegistry.addSvgIcon(\n      'setting-icon',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/settingIcon.svg'));\n    iconRegistry.addSvgIcon(\n      'setting-icon-selected',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/settingIconSelected.svg'));\n    iconRegistry.addSvgIcon(\n      'login-icon',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/loginIcon.svg'));\n    iconRegistry.addSvgIcon(\n      'logout-icon',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/logoutIcon.svg'));\n    iconRegistry.addSvgIcon(\n      'error-icon',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/errorIcon.svg'));\n    iconRegistry.addSvgIcon(\n      'danger-icon',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/dangerIcon.svg'));\n    iconRegistry.addSvgIcon(\n      'success-icon',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/successIcon.svg'));\n    iconRegistry.addSvgIcon(\n      'login-icon',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/loginIcon.svg'));\n    iconRegistry.addSvgIcon(\n      'login-icon-selected',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/loginIconSelected.svg'));\n  }\n  ngAfterViewInit(): void {\n  }\n\n  ngOnInit() {\n\n\n    \n    console.log(\"Contacting events...\")\n    this.sseService\n      .getServerSentEvent(\"http://sseicosaf.cloud.reply.eu/events\")\n      .subscribe(response => {\n\n        console.log(response)\n        let data = JSON.parse(response.data)\n        console.log(data)\n        if (data.status === \"NOK\") {\n          const dialogRef = this.dialog.open(NotificationComponent, {\n            disableClose:true,\n            width: 'auto',\n            height: 'auto',\n            data: {\n              workAreaId: '0',\n              taskId: data.task_id,\n              agvId: '0'\n            },\n            panelClass: \"zeroPaddingModal\"\n          })\n        }\n      });\n    console.log(this.activatedRoute.url)\n  }\n\n  openDialog(): void {\n    const dialogRef = this.dialog.open(LoginDialogComponent, {\n      width: '25%'\n    });\n\n    dialogRef.afterClosed().subscribe(_ => {\n      this.logList.deselectAll()\n      this.logIconSelected = false\n    });\n  }\n\n  onLogIconSelect() {\n  }\n\n  isLoggedIconSelected(): boolean {\n    return this.logIconSelected\n  }\n\n  onSelect(list) {\n    if (list == this.iconList) {\n      //deseleziono l'altra lista\n      this.logList.deselectAll()\n      this.logIconSelected = false\n    }\n    else {\n      // seleziono logList\n      if (!this.logIconSelected) {\n        this.openDialog()\n        this.logIconSelected = true\n      }\n      this.iconList.deselectAll()\n    }\n    return list.selectedOptions.selected[0].value\n  }\n\n\n\n\n  navigateTo(url: string) {\n    this.router.navigate([url])\n\n  }\n\n\n}","<app-toolbar>\r\n</app-toolbar>\r\n\r\n<mat-sidenav-container class=\"example-container\">\r\n\r\n    <mat-sidenav mode=\"side\" opened=\"true\">\r\n\r\n        <mat-selection-list #iconList id=\"iconList\" [multiple]=\"false\" (selectionChange)=\"onSelect(iconList)\">\r\n\r\n            <mat-list-option #dashboardIcon value=\"dashboard-icon\" (click)=\"navigateTo('Home')\">\r\n                <div *ngIf=\"dashboardIcon.selected === true; then dashboardSelectedBlock else dashboardBlock\"></div>\r\n                <ng-template #dashboardSelectedBlock>\r\n                    <mat-icon svgIcon=\"dashboard-icon-selected\" aria-hidden=\"false\"\r\n                        aria-label=\"Example of dashboard SVG icon selected\"></mat-icon>\r\n                </ng-template>\r\n                <ng-template #dashboardBlock>\r\n                    <!-- <mat-icon aria-hidden=\"false\" aria-label=\"Example home icon\">home</mat-icon> -->\r\n                    <mat-icon svgIcon=\"dashboard-icon\" aria-hidden=\"false\" aria-label=\"Example of dashboard SVG icon\">\r\n                    </mat-icon>\r\n                </ng-template>\r\n            </mat-list-option>\r\n\r\n            <mat-divider></mat-divider>\r\n\r\n            <mat-list-option #settingIcon value=\"setting-icon\">\r\n\r\n                <div *ngIf=\"settingIcon.selected === true; then settingSelectedBlock else settingBlock\"></div>\r\n                <ng-template #settingSelectedBlock>\r\n                    <mat-icon svgIcon=\"setting-icon-selected\" aria-hidden=\"false\"\r\n                        aria-label=\"Example of setting SVG icon\">\r\n                    </mat-icon>\r\n                </ng-template>\r\n\r\n                <ng-template #settingBlock>\r\n                    <mat-icon svgIcon=\"setting-icon\" aria-hidden=\"false\" aria-label=\"Example of setting SVG icon\">\r\n                    </mat-icon>\r\n                </ng-template>\r\n\r\n            </mat-list-option>\r\n\r\n            <mat-divider></mat-divider>\r\n\r\n        </mat-selection-list>\r\n\r\n        <span id=\"verticalFiller\"></span>\r\n\r\n\r\n        <mat-selection-list #logList id=\"logList\" [multiple]=\"false\" (selectionChange)=\"onSelect(logList)\">\r\n            <mat-divider></mat-divider>\r\n            <mat-list-option #logIcon value=\"login-icon\">\r\n\r\n                <div *ngIf=\"isLoggedIconSelected(); then logged else unlogged\"></div>\r\n                <ng-template #logged>\r\n                    <div id=\"logIcon\" value=\"login-icon-selected\">\r\n                        <mat-icon svgIcon=\"login-icon-selected\" aria-hidden=\"false\"\r\n                            aria-label=\"Example of logged SVG icon\"></mat-icon>\r\n                    </div>\r\n                </ng-template>\r\n                <ng-template #unlogged>\r\n                    <div id=\"logIcon\" value=\"login-icon\">\r\n                        <mat-icon svgIcon=\"login-icon\" aria-hidden=\"false\" aria-label=\"Example of logged SVG icon\">\r\n                        </mat-icon>\r\n                    </div>\r\n                </ng-template>\r\n            </mat-list-option>\r\n            <mat-divider></mat-divider>\r\n        </mat-selection-list>\r\n\r\n    </mat-sidenav>\r\n\r\n    <mat-sidenav-content>\r\n        <router-outlet></router-outlet>\r\n    </mat-sidenav-content>\r\n\r\n</mat-sidenav-container>","import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\n\r\nimport { GridListUCComponent } from './components/grid-list/grid-list-uc.component';\r\nimport { UseCaseDetailsComponent } from './components/UCDetails/use-case-details.component';\r\nimport { ProblemModalComponent } from './components/UCDetails/modal/problem-modal.component';\r\nimport { ToolbarComponent } from './components/toolbar/toolbar.component';\r\nimport { AppRoutingModule } from './app-routing.module';\r\n\r\nimport { AppComponent } from './app.component';\r\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\r\n\r\nimport { MatDialogModule } from '@angular/material/dialog';\r\nimport { MatIconModule } from '@angular/material/icon';\r\nimport { MatButtonModule } from '@angular/material/button';\r\nimport { MatToolbarModule } from '@angular/material/toolbar';\r\nimport { MatRadioModule } from '@angular/material/radio';\r\nimport { MatTabsModule } from '@angular/material/tabs';\r\nimport { MatListModule } from '@angular/material/list';\r\nimport { MatTableModule } from '@angular/material/table';\r\nimport { MatExpansionModule } from '@angular/material/expansion';\r\nimport { MatGridListModule } from '@angular/material/grid-list';\r\nimport { MatSidenavModule } from '@angular/material/sidenav';\r\nimport { HttpClientModule } from '@angular/common/http';\r\nimport { DashboardComponent } from './components/dashboard/dashboard.component';\r\nimport { MatCardModule } from '@angular/material/card';\r\nimport { MatProgressBarModule } from '@angular/material/progress-bar';\r\nimport { LoginDialogComponent } from './components/login/login-dialog/login-dialog.component';\r\nimport { ReactiveFormsModule, FormsModule } from '@angular/forms';\r\n\r\n\r\nimport {MatSortModule} from '@angular/material/sort'; \r\n\r\nimport {MatInputModule} from '@angular/material/input'; \r\nimport { MatFormFieldModule } from '@angular/material/form-field';\r\nimport { AgvDetailsComponent } from './components/agv-details/agv-details.component';\r\nimport { ProblemImageComponent } from './components/agv-details/error-image-modal/problem-image.component';\r\nimport { MatCarouselModule } from '@ngmodule/material-carousel';\r\nimport { StatsComponent } from './components/stats/stats.component';\r\n\r\n\r\nimport {MatPaginatorModule} from '@angular/material/paginator';\r\nimport { NotificationComponent } from './components/notification/notification.component';\r\nimport { UseCaseAComponent } from './components/UC-A/use-case-a.component'; \r\n\r\n@NgModule({\r\n  declarations: [\r\n    GridListUCComponent,\r\n    UseCaseDetailsComponent,\r\n    ProblemModalComponent,\r\n    AppComponent,\r\n    ToolbarComponent,\r\n    DashboardComponent,\r\n    LoginDialogComponent,\r\n    AgvDetailsComponent,\r\n    ProblemImageComponent,\r\n    StatsComponent,\r\n    NotificationComponent,\r\n    UseCaseAComponent,\r\n  ],\r\n  imports: [\r\n    BrowserModule,\r\n    AppRoutingModule,\r\n    BrowserAnimationsModule,\r\n    MatDialogModule,\r\n    MatIconModule,\r\n    MatButtonModule,\r\n    MatToolbarModule,\r\n    MatRadioModule,\r\n    MatTabsModule,\r\n    MatListModule,\r\n    MatTableModule,\r\n    MatExpansionModule,\r\n    MatGridListModule,\r\n    MatSidenavModule,\r\n    HttpClientModule,\r\n    MatCardModule,\r\n    MatProgressBarModule,\r\n    MatFormFieldModule,\r\n    ReactiveFormsModule,\r\n    FormsModule,\r\n    MatInputModule,\r\n    MatPaginatorModule,\r\n    MatSortModule,\r\n    MatCarouselModule.forRoot(),\r\n\r\n  ],\r\n  providers: [],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n","import { Component, OnInit } from '@angular/core';\nimport { UCAService } from 'src/app/services/UC-A/uca.service';\n\n@Component({\n  selector: 'app-use-case-a',\n  templateUrl: './use-case-a.component.html',\n  styleUrls: ['./use-case-a.component.css']\n})\nexport class UseCaseAComponent implements OnInit {\n\n  constructor(private UCAService : UCAService) { }\n\n  ngOnInit(): void {\n  }\n\n  ok(){\n    console.log(\"ok\");\n    \n  }\n\n  notOK(){\n    console.log(\"notOK\");\n    \n  }\n\n}\n","<div class=\"flexCenter\">\n    <button mat-raised-button color=\"primary\" style=\"margin-right: 20px;\" (click)=\"ok()\">OK</button>\n    <button mat-raised-button color=\"warn\" (click)=\"notOK()\">NOT OK</button>\n</div>","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-problem-modal',\n  templateUrl: './problem-modal.component.html',\n  styleUrls: ['./problem-modal.component.css']\n})\nexport class ProblemModalComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n  confirm(){\n    console.log(\"Confirm\")\n  }\n\n}\n","<div id=\"modal\">\n    <h1 mat-dialog-title>Gestione Problema</h1>\n    <p> Selezionare le comunicazioni da inviare</p>\n    <form>\n        <div mat-dialog-content>\n            <div id=\"divCheckboxes\">\n                <div class=\"checkboxList\">\n                    <p>COMUNICAZIONI PER AGV</p>\n                    <mat-radio-group #AGVSelection aria-label=\"Select an option\">\n                        <mat-radio-button value=\"1\">Option 1</mat-radio-button>\n                        <mat-radio-button value=\"2\">Option 2</mat-radio-button>\n                    </mat-radio-group>\n                </div>\n                <div class=\"checkboxList\">\n                    <p>COMUNICAZIONI PER OPERATORE</p>\n                    <mat-radio-group #OperatorSelection aria-label=\"Select an option\">\n                        <mat-radio-button value=\"1\">Option 1</mat-radio-button>\n                        <mat-radio-button value=\"2\">Option 2</mat-radio-button>\n                    </mat-radio-group>\n                </div>\n            </div>\n        </div>\n        <button mat-button (click)=\"confirm()\">CONFIRM</button>\n    </form>\n</div>","import { Component } from '@angular/core';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { MatDialog } from '@angular/material/dialog';\nimport { ProblemModalComponent } from './modal/problem-modal.component';\n\n\n//For now values in the db are provided statically, later will be provided from a service\n\nexport interface Item {\n  state: number; // 0 nessun problema or problema risolto // 1 problema // 2 componente non ancora considerato //3 loading\n  id: string;\n  hour: string;\n  problemsFound: string;\n  description: string;\n  button: string;\n}\n\n\n@Component({\n  selector: 'app-use-case-details',\n  templateUrl: './use-case-details.component.html',\n  styleUrls: ['./use-case-details.component.css'],\n  animations: [\n    trigger('detailExpand', [\n      state('collapsed', style({ height: '0px', minHeight: '0' })),\n      state('expanded', style({ height: '*' })),\n      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),\n    ]),\n  ],\n})\nexport class UseCaseDetailsComponent {\n  dataSource = ELEMENT_DATA;\n  columnsToDisplay = ['state', 'id', 'hour', 'problemsFound', 'button'];\n  expandedElement: Item | null;\n \n\n  constructor(public dialog: MatDialog){}\n\n\n  headerOfColumn(column: string) {\n    switch (column) {\n      case 'state':\n        return 'Stato';\n      case 'id':\n        return 'Componente';\n      case 'hour':\n        return 'Ora';\n      case 'problemsFound':\n        return 'Problemi Rilevati';\n      default:\n        break;\n    }\n\n  }\n\n  solve(element: Item){\n    event.stopPropagation();\n    this.dialog.open(ProblemModalComponent);\n  }\n}\n\nconst ELEMENT_DATA: Item[] = [\n  {\n    state: 0,\n    id: 'Hydrogen',\n    hour: '1.0079',\n    problemsFound: '',\n    button:'',\n    description: `Hydrogen is a chemical element with problemsFound H and atomic number 1. With a standard\n        atomic hour of 1.008, hydrogen is the lightest element on the periodic table.`\n  },  {\n    state: 0,\n    id: 'Lithium',\n    hour: '6.941',\n    problemsFound: 'Tipologia Errore risolto',\n    button:'',\n    description: `Lithium is a chemical element with problemsFound Li and atomic number 3. It is a soft,\n        silvery-white alkali metal. Under standard conditions, it is the lightest metal and the\n        lightest solid element.`\n  }, {\n    state: 0,\n    id: 'Beryllium',\n    hour: '9.0122',\n    problemsFound: '',\n    button:'',\n    description: `Beryllium is a chemical element with problemsFound Be and atomic number 4. It is a\n        relatively rare element in the universe, usually occurring as a product of the spallation of\n        larger atomic nuclei that have collided with cosmic rays.`\n  }, {\n    state: 0,\n    id: 'Boron',\n    hour: '10.811',\n    problemsFound: '',\n    button:'',\n    description: `Boron is a chemical element with problemsFound B and atomic number 5. Produced entirely\n        by cosmic ray spallation and supernovae and not by stellar nucleosynthesis, it is a\n        low-abundance element in the Solar system and in the Earth's crust.`\n  },  {\n    state: 0,\n    id: 'Nitrogen',\n    hour: '14.0067',\n    problemsFound: 'Tipologia Errore risolto',\n    button:'',\n    description: `Nitrogen is a chemical element with problemsFound N and atomic number 7. It was first\n        discovered and isolated by Scottish physician Daniel Rutherford in 1772.`\n  }, {\n    state: 1,\n    id: 'Carbon',\n    hour: '12.0107',\n    problemsFound: 'Tipologia Errore',\n    button:'',\n    description: `Carbon is a chemical element with problemsFound C and atomic number 6. It is nonmetallic\n        and tetravalentmaking four electrons available to form covalent chemical bonds. It belongs\n        to group 14 of the periodic table.`\n  },{\n    state: 1,\n    id: 'Oxygen',\n    hour: '15.9994',\n    problemsFound: 'Tipologia Errore',\n    button:'',\n    description: `Oxygen is a chemical element with problemsFound O and atomic number 8. It is a member of\n         the chalcogen group on the periodic table, a highly reactive nonmetal, and an oxidizing\n         agent that readily forms oxides with most elements as well as with other compounds.`\n  }, {\n    state: 3,\n    id: 'Helium',\n    hour: '4.0026',\n    problemsFound: '',\n    button:'',\n    description: `Helium is a chemical element with problemsFound He and atomic number 2. It is a\n        colorless, odorless, tasteless, non-toxic, inert, monatomic gas, the first in the noble gas\n        group in the periodic table. Its boiling point is the lowest among all the elements.`\n  },{\n    state: 2,\n    id: 'Fluorine',\n    hour: '',\n    problemsFound: '',\n    button:'',\n    description: `Fluorine is a chemical element with problemsFound F and atomic number 9. It is the\n        lightest halogen and exists as a highly toxic pale yellow diatomic gas at standard\n        conditions.`\n  }, {\n    state: 2,\n    id: 'Neon',\n    hour: '',\n    problemsFound: '',\n    button:'',\n    description: `Neon is a chemical element with problemsFound Ne and atomic number 10. It is a noble gas.\n        Neon is a colorless, odorless, inert monatomic gas under standard conditions, with about\n        two-thirds the density of air.`\n  },\n];","<mat-tab-group>\r\n    <mat-tab label=\"AGV-1\">\r\n\r\n        <table mat-table [dataSource]=\"dataSource\" multiTemplateDataRows class=\"mat-elevation-z8\">\r\n            <!-- State Column -->\r\n            <ng-container matColumnDef=\"state\">\r\n                <th mat-header-cell *matHeaderCellDef style=\"width: 5%;\"> STATO </th>\r\n                <td mat-cell *matCellDef=\"let element\">\r\n                    <div [ngSwitch]=\"element.state\">\r\n                        <!-- 0: ok or problem solved, 1: warning , 2: not yet considered, 3: loading-->\r\n                        <mat-icon *ngSwitchCase=\"0\" aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"success\">\r\n                            check_circle\r\n                        </mat-icon>\r\n                        <mat-icon *ngSwitchCase=\"1\" aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"error\">\r\n                            warning\r\n                        </mat-icon>\r\n                        <mat-icon *ngSwitchCase=\"2\" aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"inactive\">\r\n                            cancel\r\n                        </mat-icon>\r\n                        <mat-icon *ngSwitchCase=\"3\" aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"looping\">\r\n                            loop\r\n                        </mat-icon>\r\n\r\n\r\n                        <div *ngSwitchDefault>\r\n                            <h1>Switch</h1>\r\n                            <p>Select topic from the dropdown, to switch the content of this DIV.</p>\r\n                        </div>\r\n                    </div>\r\n                </td>\r\n            </ng-container>\r\n\r\n            <!-- Id Column -->\r\n            <ng-container matColumnDef=\"id\">\r\n                <th mat-header-cell *matHeaderCellDef style=\"width: 10%;\"> Componente </th>\r\n                <td mat-cell *matCellDef=\"let element\"> <b> {{element.id | uppercase }} </b></td>\r\n            </ng-container>\r\n\r\n            <!-- Hour Column -->\r\n            <ng-container matColumnDef=\"hour\">\r\n                <th mat-header-cell *matHeaderCellDef style=\"width: 7%;\"> Ora </th>\r\n                <td mat-cell *matCellDef=\"let element\"> {{element.hour}} </td>\r\n            </ng-container>\r\n\r\n            <!-- Problems Column -->\r\n            <ng-container matColumnDef=\"problemsFound\">\r\n                <th mat-header-cell *matHeaderCellDef style=\"width: 25%;\"> Problemi Rilevati </th>\r\n                <td mat-cell *matCellDef=\"let element\" [style]=\"element.state!=0?'color:red':'' \">\r\n                    {{element.problemsFound}}</td>\r\n            </ng-container>\r\n\r\n            <!-- Solve Button Column -->\r\n            <ng-container matColumnDef=\"button\">\r\n                <th mat-header-cell *matHeaderCellDef style=\"width: 7%;\"> </th>\r\n                <td mat-cell *matCellDef=\"let element\">\r\n                    <button *ngIf=\"element.state==1\" name=\"risolvi\" mat-raised-button color=\"primary\" (click)=\"solve(element)\">RISOLVI</button>\r\n                </td>\r\n            </ng-container>\r\n\r\n\r\n\r\n\r\n\r\n            <!-- <button mat-raised-button color=\"primary\">RISOLVI</button> -->\r\n\r\n\r\n            <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->\r\n            <ng-container matColumnDef=\"expandedDetail\">\r\n                <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"columnsToDisplay.length\">\r\n                    <div class=\"example-element-detail\"\r\n                        [@detailExpand]=\"element == expandedElement ? 'expanded' : 'collapsed'\">\r\n                        <mat-list id=\"listImages\">\r\n                            <mat-list-item><img src=\"../../../assets/black.jpeg\" /> </mat-list-item>\r\n                            <mat-list-item><img src=\"../../../assets/black.jpeg\" /> </mat-list-item>\r\n                            <mat-list-item><img src=\"../../../assets/black.jpeg\" /> </mat-list-item>\r\n                        </mat-list>\r\n                    </div>\r\n                </td>\r\n            </ng-container>\r\n\r\n            <tr mat-header-row *matHeaderRowDef=\"columnsToDisplay\"></tr>\r\n            <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\" class=\"example-element-row\"\r\n                [class.example-expanded-row]=\"expandedElement === element\"\r\n                (click)=\"expandedElement = expandedElement === element ? null : element\">\r\n            </tr>\r\n            <tr mat-row *matRowDef=\"let row; columns: ['expandedDetail']\" class=\"example-detail-row\"></tr>\r\n        </table>\r\n\r\n\r\n\r\n\r\n\r\n        <!-- <mat-icon aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"success\">check_circle_outline</mat-icon> -->\r\n        <!-- <mat-icon aria-hidden=\"false\" aria-label=\"Example home icon\">cancel</mat-icon>  -->\r\n        <!-- <mat-icon aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"error\">warning</mat-icon> -->\r\n        <!-- -->\r\n\r\n\r\n\r\n\r\n\r\n        <!-- \r\n        <table mat-table\r\n       [dataSource]=\"dataSource\" multiTemplateDataRows\r\n       class=\"mat-elevation-z8\">\r\n  <ng-container matColumnDef=\"{{column}}\" *ngFor=\"let column of columnsToDisplay\">\r\n    <th mat-header-cell *matHeaderCellDef> {{column}} </th>\r\n    <td mat-cell *matCellDef=\"let element\"> {{element[column]}} </td>\r\n  </ng-container>\r\n\r\n  <ng-container matColumnDef=\"expandedDetail\">\r\n    <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"columnsToDisplay.length\">\r\n      <div class=\"example-element-detail\"\r\n           [@detailExpand]=\"element == expandedElement ? 'expanded' : 'collapsed'\">\r\n        <div class=\"example-element-diagram\">\r\n          <div class=\"example-element-position\"> {{element.position}} </div>\r\n          <div class=\"example-element-symbol\"> {{element.symbol}} </div>\r\n          <div class=\"example-element-name\"> {{element.name}} </div>\r\n          <div class=\"example-element-weight\"> {{element.weight}} </div>\r\n        </div>\r\n        <div class=\"example-element-description\">\r\n          {{element.description}}\r\n          <span class=\"example-element-description-attribution\"> -- Wikipedia </span>\r\n        </div>\r\n      </div>\r\n    </td>\r\n  </ng-container>\r\n\r\n  <tr mat-header-row *matHeaderRowDef=\"columnsToDisplay\"></tr>\r\n  <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\"\r\n      class=\"example-element-row\"\r\n      [class.example-expanded-row]=\"expandedElement === element\"\r\n      (click)=\"expandedElement = expandedElement === element ? null : element\">\r\n  </tr>\r\n  <tr mat-row *matRowDef=\"let row; columns: ['expandedDetail']\" class=\"example-detail-row\"></tr>\r\n</table> -->\r\n\r\n\r\n\r\n    </mat-tab>\r\n    <mat-tab label=\"AGV-2\"> Content 2 </mat-tab>\r\n    <mat-tab label=\"AGV-3\"> Content 3 </mat-tab>\r\n</mat-tab-group>","import { AfterViewInit, Component, Input, OnDestroy, OnInit, ViewChild } from '@angular/core';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { MatDialog, MatDialogConfig } from '@angular/material/dialog';\nimport { ProblemModalComponent } from '../UCDetails/modal/problem-modal.component';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { ProblemImageComponent, Slide } from './error-image-modal/problem-image.component';\nimport { SseService } from 'src/app/services/SseService/sse-service.service';\nimport { ActivatedRoute } from '@angular/router';\nimport { MatPaginator } from '@angular/material/paginator';\nimport { Subscription } from 'rxjs';\nimport { UCCService } from 'src/app/services/UC-C/uc-c-service.service';\nimport { MatRadioButton, MatRadioGroup } from '@angular/material/radio';\nimport { Order } from 'src/app/model/order.model';\nimport { MatSort } from '@angular/material/sort';\nimport { MatExpansionPanel } from '@angular/material/expansion';\nimport { Task } from 'src/app/model/task.model';\n\n\nconst options = { hour: \"numeric\", minute: \"numeric\", second: \"numeric\" }\nexport interface Problem {\n  state: number; // 0 nessun problema or problema risolto // 1 problema // 2 componente non ancora considerato //3 loading\n  id: string;\n  kit: string;\n  hour: string;\n  problemsFound: string;\n  description: string;\n  button: string;\n}\n\n\ninterface Prelievo {\n  state: number;\n  components: string\n  kit: string;\n  hour: string;\n}\n\n\n@Component({\n  selector: 'app-agv-details',\n  templateUrl: './agv-details.component.html',\n  styleUrls: ['./agv-details.component.css'],\n  animations: [\n    trigger('detailExpand', [\n      state('collapsed', style({ height: '0px', minHeight: '0' })),\n      state('expanded', style({ height: '*' })),\n      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),\n    ]),\n  ]\n})\nexport class AgvDetailsComponent implements OnInit, AfterViewInit, OnDestroy {\n\n  @ViewChild('problemPanel', { static: false }) problemPanel: MatExpansionPanel\n\n  sseSubscription: Subscription\n\n  @ViewChild('matSortProblems') matSortProblems: MatSort;\n  @ViewChild('matSortPrelievi') matSortPrelievi: MatSort;\n\n\n  @ViewChild(\"OperatorSelection\") opSelection: MatRadioGroup\n  @ViewChild(\"AGVActionSelected\") AGVsel: MatRadioGroup\n  dataSourceProblems: MatTableDataSource<Problem>\n  columnsToDisplay = ['state', 'id', 'kit', 'problemsFound', 'button', 'hour'];\n  expandedElement: Problem | null;\n  isHidingProblemHandling: boolean\n  AGVActionSelected: string\n  OpActionSelected: string\n  opChecked: boolean = false\n\n  agvOptions = ['Ritentare', 'Rimanere fermo', 'Continuo attivit']\n  opOptions = [{ text: 'Richiesta intervento', val: false, dis: false }, { text: 'Richiesta interveno urgente', val: false, dis: false }]\n\n  displayedColumnsPrelievi: string[] = ['state', 'components', 'kit', 'hour'];\n  dataSourcePrelievi: MatTableDataSource<Prelievo>\n  problems: Slide[];\n  taskErrorId: string;\n\n\n  AGVActionSelection(actionSelected: string) {\n    this.AGVActionSelected = actionSelected\n\n    if (actionSelected === this.agvOptions[1]) {\n      console.log(\"selezionato rimanere fermo\")\n      if (!this.opOptions.find(o => o.val == true))\n        this.opOptions[0].val = true\n      for (let op of this.opOptions) {\n        op.dis = false\n      }\n      console.log(\"Changed now\")\n    }\n    else {\n      console.log(\"selezionato altro\")\n      for (let op of this.opOptions) {\n        op.val = false\n        op.dis = true\n      }\n    }\n  }\n  OpActionSelection(opSel) {\n    if (!opSel.dis) {\n      for (let op of this.opOptions)\n        if (opSel != op) op.val = false\n      //this.opOptions.find(o=>o!=opSel).val = false\n      this.opOptions.find(o => o == opSel).val = true\n    }\n  }\n\n  private _paginatorPrelievi: MatPaginator;\n  paramsSub: Subscription;\n  public get paginatorPrelievi(): MatPaginator {\n    return this._paginatorPrelievi;\n  }\n  @ViewChild('paginatorPrelievi')\n  public set paginatorPrelievi(value: MatPaginator) {\n    this._paginatorPrelievi = value;\n    this.dataSourcePrelievi.paginator = this.paginatorPrelievi\n\n  }\n  private _paginatorErrors: MatPaginator;\n  public get paginatorErrors(): MatPaginator {\n    return this._paginatorErrors;\n  }\n  @ViewChild('paginatorErrors')\n  public set paginatorErrors(value: MatPaginator) {\n    this._paginatorErrors = value;\n    this.dataSourceProblems.paginator = this.paginatorErrors\n  }\n\n\n  constructor(\n    public dialog: MatDialog,\n    public imageDialog: MatDialog,\n    private sseService: SseService,\n    private UCCService: UCCService,\n    private activatedRoute: ActivatedRoute) {\n\n    this.isHidingProblemHandling = true\n    this.problems = []\n    this.problems.push({ image: \"../../../assets/img/errorIcon.svg\" },\n      { image: \"../../../assets/img/dangerIcon.svg\" },\n      { image: \"../../../assets/img/settingIconSelected.svg\" })\n\n\n    this.dataSourcePrelievi = new MatTableDataSource()\n    this.dataSourceProblems = new MatTableDataSource()\n  }\n  ngAfterViewInit(): void {\n\n    this.activatedRoute.queryParams.subscribe(queryParams => {\n      if (queryParams['taskId']) {\n\n        this.taskErrorId = queryParams['taskId']\n\n        this.problemPanel.open()\n        this.expandedElement = this.dataSourceProblems.data.find(problem => problem.id === `PN${queryParams['taskId']}`)\n        this.isHidingProblemHandling = false\n      }\n    })\n    this.paginatorPrelievi = this.dataSourcePrelievi.paginator\n    this.paginatorErrors = this.dataSourceProblems.paginator\n    this.matSortProblems = this.dataSourcePrelievi.sort\n    this.matSortPrelievi = this.dataSourcePrelievi.sort\n  }\n\n  ngOnInit(): void {\n\n    //TODO chiamata per ottenere tutti i problemi e i task risolti fino a quel momento\n\n\n\n\n    this.paramsSub = this.activatedRoute.params.subscribe(params => {\n\n      if (params['workAreaId'] && params['agvId']) {\n\n        this.UCCService.subjectSelectedWorkAreaAndAgv.next([Number(params['workAreaId']), Number(params['agvId'])])\n\n        this.UCCService.getTaskListAgv(this.UCCService.currentOrder.order_id, params['agvId']).subscribe(tasks => {\n\n\n\n          let sourceProblems: Problem[] = []\n          let sourcePrelievi: Prelievo[] = []\n          //TODO: definire come dare settare le due data source problemi e prelievi\n          tasks.forEach((task: Task) => {\n\n            switch (task.task_status_id) {\n              //created\n              case 1:\n                //  sourcePrelievi.push({\n                //   state: 1,\n                //   components: `PN${task.task_id}`,\n                //   kit: \"45\",\n                // //  hour: task.startTime.toLocaleTimeString('it', options)\n                // hour: new Date().toLocaleTimeString('it', options)\n                // })\n                break;\n              //completed\n              case 2:\n                sourcePrelievi.push({\n                  state: 2,\n                  components: `PN${task.task_id}`,\n                  kit: \"45\",\n                  //   hour: task.stop_time.toLocaleTimeString('it', options)\n                  hour: new Date().toLocaleTimeString('it', options)\n                })\n\n                break;\n              //failed\n              case 3:\n              //pending\n              case 4:\n                sourceProblems.push({\n                  state: 3,\n                  id: `PN${task.task_id}`,\n                  kit: '45',\n                  //hour: task.error_time.toLocaleTimeString('it', options),\n                  hour: new Date().toLocaleTimeString('it', options),\n                  problemsFound: 'Tipologia Problema',\n                  button: '',\n                  description: `Problem description`,\n                })\n                break;\n            }\n\n            sourcePrelievi = sourcePrelievi.sort((a, b) => b.hour.localeCompare(a.hour))\n            this.dataSourcePrelievi.data = sourcePrelievi\n\n            this.dataSourceProblems.data = sourceProblems\n\n            this.dataSourcePrelievi.paginator = this.paginatorPrelievi\n            this.dataSourcePrelievi.sort = this.matSortPrelievi\n            this.dataSourceProblems.paginator = this.paginatorErrors\n            this.dataSourceProblems.sort = this.matSortProblems\n\n\n\n          })\n\n\n        })\n\n        if (!this.sseSubscription) {\n\n          this.sseSubscription = this.sseService\n            .getServerSentEvent(\"http://sseicosaf.cloud.reply.eu/events\")\n            .subscribe(data => {\n\n              let response = JSON.parse(data.data)\n\n\n              if (response.status === \"OK\") {\n\n\n                console.log(\"CIao\", response);\n\n                let taskId = response.task_id\n\n                let problemFound = false\n\n                let sourceProblem = this.dataSourceProblems.data.filter(problem => { problemFound = true; return problem.id !== `PN${taskId}` })\n\n                this.dataSourceProblems.data = sourceProblem\n\n\n                let sourcePrelievi = [...this.dataSourcePrelievi.data, {\n                  state: problemFound ? 4 : 2,\n                  components: `PN${taskId}`,\n                  kit: \"45\",\n                  hour: new Date().toLocaleTimeString('it', options)\n                }]\n                sourcePrelievi = sourcePrelievi.sort((a, b) => b.hour.localeCompare(a.hour))\n\n                this.dataSourcePrelievi.data = sourcePrelievi\n\n                this.dataSourcePrelievi.paginator = this.paginatorPrelievi\n                this.dataSourcePrelievi.sort = this.matSortPrelievi\n\n              } else {\n                if (response.status === \"NOK\") {\n\n                  let taskId = response.task_id\n                  this.dataSourceProblems.data = [\n                    {\n                      state: 3,\n                      id: `PN${response.task_id}`,\n                      kit: 'Nome kit',\n                      hour: new Date().toLocaleTimeString('it', options),\n                      problemsFound: 'Tipologia Problema',\n                      button: '',\n                      description: `Problem description`,\n                    }\n                  ]\n\n                  this.dataSourceProblems.paginator = this.paginatorErrors\n                  this.dataSourceProblems.sort = this.matSortProblems\n                }\n              }\n            })\n        }\n      }\n    })\n  }\n\n  ngOnDestroy(): void {\n    this.paramsSub.unsubscribe()\n    this.sseSubscription.unsubscribe()\n  }\n\n\n  headerOfColumn(column: string) {\n    switch (column) {\n      case 'state':\n        return 'Stato';\n      case 'id':\n        return 'Componente';\n      case 'hour':\n        return 'Ora';\n      case 'problemsFound':\n        return 'Problemi Rilevati';\n      default:\n        break;\n    }\n  }\n\n  proceed() {\n    // console.log(this.AGVActionSelected);\n    // console.log(this.OpActionSelected);\n\n\n    this.UCCService.getLastActionError(15).subscribe(success => {\n      console.log(success[0].error_id);\n\n      this.UCCService.setSolveAction(this.AGVActionSelected, 1, 1, 1, success[0].error_id).subscribe(response => {\n        this.UCCService.setTaskStatusOk(Number(this.taskErrorId)).subscribe(_ => {\n          console.log(\"Risolvi ora\", response)\n        })\n      })\n    })\n  }\n\n  solve(element: Problem) {\n    event.stopPropagation();\n    //this.dialog.open(ProblemModalComponent);\n    this.isHidingProblemHandling = false\n    this.expandedElement = element\n  }\n\n  openImage(imageSrc: Slide) {\n    console.log(imageSrc)\n    const dialogConfig = new MatDialogConfig();\n\n    dialogConfig.disableClose = false;\n    dialogConfig.autoFocus = true;\n    dialogConfig.minWidth = \"50%\"\n    dialogConfig.minHeight = \"50%\"\n    dialogConfig.panelClass = \"zeroPaddingModal\"\n\n\n    let imageArray = []\n\n    imageArray.push(imageSrc)\n\n    this.problems.forEach(element => {\n      if (element.image != imageSrc.image)\n        imageArray.push(element)\n    });\n\n    dialogConfig.data = {\n      images: imageArray\n    };\n    this.imageDialog.open(ProblemImageComponent, dialogConfig)\n  }\n}\n\n// const PROBLEMS: Item[] = [\n//   {\n//     state: 2,\n//     id: 'PN 45335478',\n//     kit: 'Nome kit',\n//     hour: '10:59',\n//     problemsFound: 'Tipologia Problema',\n//     button: '',\n//     description: `Problem description`\n//   },\n// ]\n\n\n","<mat-accordion>\n    <mat-expansion-panel #problemPanel class=\"border\">\n        <mat-expansion-panel-header>\n            <mat-panel-title>\n                Problemi rilevati\n            </mat-panel-title>\n        </mat-expansion-panel-header>\n        \n        <!-----------TABLE -->\n        <table mat-table [dataSource]=\"dataSourceProblems\" multiTemplateDataRows  #matSortProblems=\"matSort\" matSort>\n            <!-- State Column -->\n            <ng-container matColumnDef=\"state\">\n                <th mat-header-cell *matHeaderCellDef class=\"normalColumn\"> STATO </th>\n                <td mat-cell *matCellDef=\"let element\" class=\"normalColumn\">\n                    <div>\n                        <mat-icon svgIcon=\"error-icon\" aria-hidden=\"false\" aria-label=\"Example home icon\">\n                        </mat-icon>\n                    </div>\n                </td>\n            </ng-container>\n\n            <!-- Id Column -->\n            <ng-container matColumnDef=\"id\">\n                <th mat-header-cell *matHeaderCellDef class=\"normalColumn\" mat-sort-header> Componente </th>\n                <td mat-cell *matCellDef=\"let element\" class=\"normalColumn\"> <b> {{element.id | uppercase }} </b></td>\n            </ng-container>\n\n\n            <!-- Problems Column -->\n            <ng-container matColumnDef=\"problemsFound\">\n                <th mat-header-cell *matHeaderCellDef class=\"normalColumn\" mat-sort-header> Problemi Rilevati </th>\n                <td mat-cell *matCellDef=\"let element\" class=\"normalColumn\">\n                    <p class=\"errorType\">{{element.problemsFound}}</p>\n                </td>\n            </ng-container>\n\n\n            <!-- Solve Button Column -->\n            <ng-container matColumnDef=\"button\">\n                <th mat-header-cell *matHeaderCellDef class=\"normalColumn\"> </th>\n                <td mat-cell *matCellDef=\"let element\" class=\"normalColumn\">\n                    <button *ngIf=\"element.state==3\" name=\"risolvi\" mat-flat-button class=\"solveButton\"\n                        (click)=\"solve(element)\">\n                        RISOLVI\n                    </button>\n                </td>\n            </ng-container>\n\n            <!-- Kit Column -->\n            <ng-container matColumnDef=\"kit\">\n                <th mat-header-cell *matHeaderCellDef class=\"normalColumn\" mat-sort-header> Kit </th>\n                <td mat-cell *matCellDef=\"let element\" class=\"normalColumn\"> {{element.kit}}</td>\n            </ng-container>\n\n\n            <!-- Hour Column -->\n            <ng-container matColumnDef=\"hour\">\n                <th mat-header-cell *matHeaderCellDef class=\"lastColumn\" mat-sort-header> Ora </th>\n                <td mat-cell *matCellDef=\"let element\" class=\"lastColumn\"> {{element.hour}} </td>\n            </ng-container>\n\n            <!-- <button mat-raised-button color=\"primary\">RISOLVI</button> -->\n\n\n            <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->\n            <ng-container matColumnDef=\"expandedDetail\">\n\n                <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"columnsToDisplay.length\">\n                    <div class=\"example-element-detail\"\n                        [@detailExpand]=\"element == expandedElement ? 'expanded' : 'collapsed'\">\n                        <div *ngIf=\"!isHidingProblemHandling else problemDetails\" class=\"handleProblemForm\">\n                            <div class=\"inlineDiv\">\n                                <h1 mat-dialog-title>Gestione Problema</h1>\n                                <mat-icon aria-hidden=\"false\" aria-label=\"Close Icon\"\n                                    (click)=\"expandedElement=null\">close\n                                </mat-icon>\n                            </div>\n                            <p> Selezionare le comunicazioni da inviare</p>\n                            <form>\n                                <div mat-dialog-content>\n                                    <div id=\"divCheckboxes\">\n                                        <div class=\"checkboxList\">\n                                            <p>COMUNICAZIONI PER AGV</p>\n                                            <mat-radio-group color=\"primary\"  \n                                                aria-label=\"Select an option\" #AGVActionSelected>\n                                                <mat-radio-button *ngFor=\"let agvOption of agvOptions; let i = index\" value=\"{{i}}\" (click)=\"AGVActionSelection(agvOption)\">{{agvOption}}</mat-radio-button>\n                                            </mat-radio-group>\n                                        </div>\n                                        <div class=\"checkboxList\">\n                                            <p>COMUNICAZIONI PER OPERATORE</p>\n                                            <mat-radio-group color=\"primary\" #OperatorSelection\n                                                aria-label=\"Select an option\">\n                                                <mat-radio-button *ngFor=\"let opOption of opOptions; let op_index=index\" [disabled]=\"opOption.dis\" value=\"{{op_index}}\" [checked]=\"opOption.val\" (click)=\"OpActionSelection(opOption)\">{{opOption.text}}</mat-radio-button>\n                                                <u>Aggiungere un testo</u>\n                                            </mat-radio-group>\n                                        </div>\n                                    </div>\n                                </div>\n                                <button mat-flat-button (click)=\"proceed()\" class=\"proceedButton\">PROCEDI</button>\n                            </form>\n                        </div>\n                        <ng-template #problemDetails>\n                            <div class=\"rightContent\">\n                                <p>IMMAGINI</p>\n                                <mat-list id=\"listImages\">\n                                    <mat-list-item *ngFor=\"let problemSrc of problems\"><img [src]=\"problemSrc.image\"\n                                            (click)=\"openImage(problemSrc)\" /> </mat-list-item>\n                                </mat-list>\n                                <p><u>Richiedi altre immagini</u></p>\n\n                                <p><u>LOG AGV</u></p>\n                            </div>\n                        </ng-template>\n                    </div>\n                </td>\n            </ng-container>\n\n            <tr mat-header-row *matHeaderRowDef=\"columnsToDisplay\"></tr>\n            <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\" class=\"example-element-row\"\n                [class.example-expanded-row]=\"expandedElement === element\"\n                (click)=\"expandedElement = expandedElement === element ? null : element; isHidingProblemHandling = true;\">\n            </tr>\n            <tr mat-row *matRowDef=\"let row; columns: ['expandedDetail']\" class=\"example-detail-row\"></tr>\n        </table>\n        <mat-paginator #paginatorErrors [pageSizeOptions]=\"[5, 10, 25, 100]\"></mat-paginator>\n\n    </mat-expansion-panel>\n</mat-accordion>\n\n<mat-accordion>\n    <mat-expansion-panel class=\"border\">\n        <mat-expansion-panel-header>\n            <mat-panel-title>\n                Elenco prelievi\n            </mat-panel-title>\n\n        </mat-expansion-panel-header>\n\n        <!-- Content of expansion panel -->\n\n        <table mat-table [dataSource]=\"dataSourcePrelievi\"  #matSortPrelievi=\"matSort\" multiTemplateDataRows matSort>\n            <!-- State Column -->\n            <ng-container matColumnDef=\"state\">\n                <th mat-header-cell *matHeaderCellDef class=\"normalColumn\"> STATO </th>\n                <td mat-cell *matCellDef=\"let element\">\n                    <div [ngSwitch]=\"element.state\">\n                        <!-- 0: ok or problem solved, 1: warning , 2: not yet considered, 3: loading-->\n                        \n                        <mat-icon *ngSwitchCase=\"2\" aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"success\">\n                            check_circle\n                        </mat-icon>\n                        <!-- <div *ngSwitchCase=\"1\">\n                        </div> -->\n                        <!-- <mat-icon *ngSwitchCase=\"2\" aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"inactive\">\n                            cancel\n                        </mat-icon> -->\n                        <!-- <mat-icon *ngSwitchCase=\"5\" aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"looping\">\n                            loop\n                        </mat-icon> -->\n                        <mat-icon *ngSwitchCase=\"4\" aria-hidden=\"false\" aria-label=\"Example home icon\" color=\"looping\">\n                            check_circle\n                        </mat-icon>\n                        <div *ngSwitchDefault>\n                        </div>\n                    </div>\n                </td>\n            </ng-container>\n\n            <!-- Id Column -->\n            <ng-container matColumnDef=\"components\">\n                <th mat-header-cell *matHeaderCellDef class=\"normalColumn\" mat-sort-header> COMPONENTI </th>\n                <td mat-cell *matCellDef=\"let element\"> <b> {{element.components | uppercase }} </b></td>\n            </ng-container>\n\n            <!-- Hour Column -->\n            <ng-container matColumnDef=\"kit\">\n                <th mat-header-cell *matHeaderCellDef class=\"normalColumn\" mat-sort-header> KIT </th>\n                <td mat-cell *matCellDef=\"let element\"> {{element.kit}} </td>\n            </ng-container>\n\n            <!-- Problems Column -->\n            <ng-container matColumnDef=\"hour\">\n                <th mat-header-cell *matHeaderCellDef class=\"lastColumn\" mat-sort-header> ORA </th>\n                <td mat-cell *matCellDef=\"let element\" class=\"lastColumn\"> {{element.hour}}</td>\n            </ng-container>\n\n            <tr mat-header-row *matHeaderRowDef=\"displayedColumnsPrelievi\"></tr>\n            <tr mat-row *matRowDef=\"let row; columns: displayedColumnsPrelievi;\"></tr>\n        </table>\n        <mat-paginator #paginatorPrelievi [pageSizeOptions]=\"[5, 10, 25, 100]\"></mat-paginator>\n\n\n    </mat-expansion-panel>\n</mat-accordion>","import { Component, OnInit, Inject } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\n\n@Component({\n  selector: 'app-problem-image',\n  templateUrl: './problem-image.component.html',\n  styleUrls: ['./problem-image.component.css']\n})\nexport class ProblemImageComponent implements OnInit {\n\n  slides: Slide[]\n\n  constructor(private dialogRef: MatDialogRef<ProblemImageComponent>,\n    @Inject(MAT_DIALOG_DATA) data) {\n\n    this.slides = []\n\n    if (data.images)\n    this.slides = [...data.images]\n    \n  }\n\n  ngOnInit(): void {\n  }\n\n  closeDialog(){\n    this.dialogRef.close()\n  }\n}\n\nexport interface Slide {\n  image: string\n}\n\n","<div id=\"modal\">\n\n    <mat-icon id=\"closeIcon\" aria-hidden=\"false\" aria-label=\"Example home icon\" (click)=\"closeDialog()\">close</mat-icon>\n\n    <mat-carousel timings=\"250ms ease-in\" [autoplay]=\"true\" interval=\"5000\" color=\"black\" maxWidth=\"auto\"\n        proportion=\"100\" slides=\"slides.length\" [loop]=\"true\" [hideArrows]=\"false\" [hideIndicators]=\"true\"\n        [useKeyboard]=\"true\" [useMouseWheel]=\"false\" orientation=\"ltr\">\n        <mat-carousel-slide #matCarouselSlide *ngFor=\"let slide of slides; let i = index\" [image]=\"slide.image\"\n            overlayColor=\"#00000040\" [hideOverlay]=\"false\">\n        </mat-carousel-slide>\n    </mat-carousel>\n\n</div>","import { AfterViewInit, Component, OnInit } from '@angular/core';\nimport { WorkArea } from 'src/app/model/work-area.model';\nimport { Agv } from 'src/app/model/agv.model';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { EXPANSION_PANEL_ANIMATION_TIMING } from '@angular/material/expansion';\nimport { UCCService } from 'src/app/services/UC-C/uc-c-service.service';\nimport { Order } from 'src/app/model/order.model';\nimport { Task } from 'src/app/model/task.model';\nimport { SseService } from 'src/app/services/SseService/sse-service.service';\n\n@Component({\n  selector: 'app-dashboard',\n  templateUrl: './dashboard.component.html',\n  styleUrls: ['./dashboard.component.css'],\n  animations: [\n    // Each unique animation requires its own trigger. The first argument of the trigger function is the name\n    trigger('rotatedState', [\n      state('collapsed', style({ transform: 'rotate(0)' })),\n      state('expanded', style({ transform: 'rotate(-180deg)' })),\n      transition('expanded <=> collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n    ]),\n  ]\n})\nexport class DashboardComponent implements OnInit {\n\n\n  stateJPH: string\n  stateSat: string\n  stateCycleTime: string\n\n  expandPanel(expPanel, state) {\n    expPanel.toggle()\n    this.rotate(state)\n  }\n\n  rotate(state: string) {\n\n\n    switch (state) {\n      case 'stateSat':\n        this.stateSat = (this.stateSat === 'collapsed' ? 'expanded' : 'collapsed');\n        break;\n      case 'stateJPH':\n        this.stateJPH = (this.stateJPH === 'collapsed' ? 'expanded' : 'collapsed');\n\n        break;\n      case 'stateCycleTime':\n        this.stateCycleTime = (this.stateCycleTime === 'collapsed' ? 'expanded' : 'collapsed');\n\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  workAreas: WorkArea[]\n  progress: number\n\n  selectedWorkArea: WorkArea\n  selectedAgv: Agv\n\n\n  constructor(\n    private activatedRoute: ActivatedRoute,\n    private sseService: SseService,\n    private router: Router,\n    private UCCService: UCCService) {\n\n\n\n\n    this.stateJPH = 'collapsed';\n    this.stateSat = 'collapsed'\n    this.stateCycleTime = 'collapsed'\n\n    this.progress = 75\n    this.workAreas = []\n\n    let w1 = new WorkArea(0, \"AMR\", [new Agv(1)])\n    let w2 = new WorkArea(1, \"1\", [new Agv(2), new Agv(3)])\n    let w3 = new WorkArea(2, \"2\", [new Agv(4), new Agv(5)])\n    let w4 = new WorkArea(3, \"3\", [new Agv(6), new Agv(7)])\n    let w5 = new WorkArea(4, \"4\", [new Agv(8), new Agv(9)])\n    let w6 = new WorkArea(5, \"5\", [new Agv(10), new Agv(11)])\n\n    w1.agvList[0].setProgress(30)\n    w1.agvList[0].setError(true)\n\n    w2.agvList[0].setProgress(100)\n    w2.agvList[1].setProgress(52)\n    w2.agvList[1].setError(true)\n\n    w3.agvList[0].setProgress(100)\n    w3.agvList[1].setProgress(52)\n    w3.agvList[1].setError(true)\n\n    w4.agvList[0].setProgress(77)\n    w4.agvList[1].setProgress(99)\n    w4.agvList[1].setError(true)\n\n    w5.agvList[0].setProgress(1)\n    w5.agvList[1].setProgress(52)\n    w5.agvList[1].setError(true)\n\n    w6.agvList[0].setProgress(23)\n    w6.agvList[1].setProgress(90)\n    w6.agvList[1].setError(true)\n\n\n    this.workAreas.push(w1, w2, w3, w4, w5, w6)\n\n  }\n\n  ngOnInit(): void {\n\n    this.selectWorkArea(this.workAreas[0])\n    this.openAgvDetails(this.selectedWorkArea, this.selectedWorkArea.agvList[0]);\n\n    //TODO remove timestamp hardcoded\n    this.UCCService.getSubjectSelectedWorkAreaAndAgv().subscribe(workAreaAndAgvIds => {\n\n      this.selectWorkArea(this.workAreas.find(workArea => workArea.id === workAreaAndAgvIds[0]))\n      this.openAgvDetails(this.selectedWorkArea, this.selectedWorkArea.agvList.find(agv => agv.id === workAreaAndAgvIds[1]))\n    })\n    //TODO calcolo percentuali di risoluzione task corrente\n    this.UCCService.getOrdListByDateAndUC(\"UC-C\", \"2020-07-24\").subscribe((orders: Order[]) => {\n      //Ottengo il primo ordine non terminato e definisco questo come ordine corrente\n      this.UCCService.currentOrder = orders.find(order => order.order_ts_end == null)\n      //salvo nella sessione currentOrder\n      localStorage.setItem('currentOrder', JSON.stringify(this.UCCService.currentOrder));\n\n      this.UCCService.getTaskListOrder(this.UCCService.currentOrder.order_id).subscribe(task => {\n        //TODO QUI devo calcolare quella che poi sar la percentuale da mostrare per l'ordine\n\n\n      })\n    })\n\n\n\n\n    this.sseService\n      .getServerSentEvent(\"http://sseicosaf.cloud.reply.eu/events\")\n      .subscribe(data => {\n\n        //TODO:recompute percentage tasks\n\n      })\n\n\n  }\n\n  openAgvDetails(workArea: WorkArea, agv: Agv) {\n    this.router.navigate([\"Home\", { outlets: { dashboardContent: [\"work-area\", workArea.id, \"agv-details\", agv.id] } }]);\n    this.selectedAgv = agv\n    this.selectedWorkArea = workArea\n\n    console.log(this.selectedAgv);\n\n    event.stopPropagation();\n  }\n\n  selectWorkArea(workArea: WorkArea) {\n    this.selectedAgv = null\n    if (this.selectedWorkArea == workArea) {\n      //unselect the card\n      this.selectedWorkArea = null\n    }\n    else\n      this.selectedWorkArea = workArea\n\n    // remove details about card\n    this.router.navigate([\"Home\"])\n  }\n\n  openGraph(typeGraph: string) {\n    event.stopPropagation();\n    this.router.navigate([\"Home\", { outlets: { dashboardContent: [\"work-area\", this.selectedWorkArea.id, \"statistics\", typeGraph] } }]);\n  }\n\n\n}\n\n\n","<div class=\"horizontalContainer\">\r\n    <div class=\"externalHorizontalContainer\">\r\n\r\n        <div class=\"cardsContainer\">\r\n            <mat-card class=\"example-card\" *ngFor=\"let workArea of workAreas\" (click)=\"selectWorkArea(workArea)\"\r\n                [ngStyle]=\"{'width.vh': selectedWorkArea == workArea ? '75' : '50'}\">\r\n                <mat-card-header>\r\n                    <mat-card-title>\r\n                        <p class=\"titleCard\">Area di Lavoro {{workArea.name}}</p>\r\n                    </mat-card-title>\r\n                </mat-card-header>\r\n                <mat-card-content>\r\n                    <div #card class=\"horizontalContainer\">\r\n                        <mat-list role=\"list\">\r\n                            <mat-list-item *ngFor=\"let agv of workArea.agvList\" role=\"listitem\" class=\"agvLine\"\r\n                                (click)=\"openAgvDetails(workArea,agv)\"\r\n                                [ngStyle]=\"{'background-color': selectedAgv == agv ? '#97AFC9' : 'transparent'}\">\r\n                                <div class=\"option\">\r\n                                    <p #paragrafo>\r\n                                        <span class=\"dangerIconWrapper\">\r\n                                            <mat-icon class=\"card-icon\" *ngIf=\"agv.getError()\" svgIcon=\"danger-icon\"\r\n                                                aria-hidden=\"false\" aria-label=\"Example danger SVG icon\"\r\n                                                style=\"margin-right: 5%;\">\r\n                                            </mat-icon>\r\n                                        </span>\r\n                                        AGV {{workArea.id}}.{{agv.id}} </p>\r\n                                    <div style=\"width: 100%;\">\r\n                                        <mat-progress-bar #progressVal mode=\"determinate\" [value]=\"agv.getProgress()\">\r\n                                        </mat-progress-bar>\r\n                                        <span class=\"percentageProgressBar\"\r\n                                            [ngStyle]=\"{'left':  (agv.getProgress()) +'%'}\">\r\n                                            <div *ngIf=\"agv.getError(); then errorBlock else correctBlock\"></div>\r\n                                            <ng-template #errorBlock>\r\n                                                <mat-icon class=\"card-icon\" *ngIf=\"agv.getError()\" svgIcon=\"error-icon\"\r\n                                                    aria-hidden=\"false\" aria-label=\"Example error SVG icon\">\r\n                                                </mat-icon>\r\n                                            </ng-template>\r\n                                            <ng-template #correctBlock>\r\n                                                <div\r\n                                                    *ngIf=\"agv.getProgress() === 100; then successBlock else progressBlock\">\r\n                                                </div>\r\n                                                <ng-template #successBlock>\r\n                                                    <mat-icon class=\"card-icon\" svgIcon=\"success-icon\"\r\n                                                        aria-hidden=\"false\" aria-label=\"Example error SVG icon\">\r\n                                                    </mat-icon>\r\n                                                </ng-template>\r\n                                                <ng-template #progressBlock>\r\n                                                    <span class=\"percentageProgressBar\">{{agv.getProgress()}}%</span>\r\n                                                </ng-template>\r\n                                            </ng-template>\r\n\r\n                                        </span>\r\n                                    </div>\r\n                                </div>\r\n\r\n                            </mat-list-item>\r\n                        </mat-list>\r\n                        <div class=\"statistics\" *ngIf=\"selectedWorkArea == workArea\">\r\n                            <mat-accordion (click)=\"openGraph('MCT')\">\r\n                                <mat-expansion-panel #expPanelCycleTime disabled=\"true\">\r\n                                    <mat-expansion-panel-header>\r\n                                        <mat-panel-title>\r\n                                            Tempo ciclo medio\r\n                                        </mat-panel-title>\r\n                                        <mat-icon class=\"clickableIcon\" aria-hidden=\"false\"\r\n                                            aria-label=\"Example home icon\"\r\n                                            (click)=\"expandPanel(expPanelCycleTime,'stateCycleTime')\"\r\n                                            [@rotatedState]='stateCycleTime'>expand_more</mat-icon>\r\n                                    </mat-expansion-panel-header>\r\n                                    <p>I'm visible because I am open</p>\r\n                                </mat-expansion-panel>\r\n                            </mat-accordion>\r\n\r\n                            <mat-accordion (click)=\"openGraph('SAT')\">\r\n                                <mat-expansion-panel #expPanelSat disabled=\"true\">\r\n                                    <mat-expansion-panel-header>\r\n                                        <mat-panel-title>\r\n                                            Saturazione media\r\n                                        </mat-panel-title>\r\n                                        <mat-icon class=\"clickableIcon\" aria-hidden=\"false\"\r\n                                            aria-label=\"Example home icon\" (click)=\"expandPanel(expPanelSat,'stateSat')\"\r\n                                            [@rotatedState]='stateSat'>expand_more</mat-icon>\r\n                                    </mat-expansion-panel-header>\r\n                                    <p>I'm visible because I am open</p>\r\n                                </mat-expansion-panel>\r\n                            </mat-accordion>\r\n\r\n                            <mat-accordion (click)=\"openGraph('JPH')\">\r\n                                <mat-expansion-panel #expPanelJPH disabled=\"true\">\r\n                                    <mat-expansion-panel-header>\r\n                                        <mat-panel-title>\r\n                                            JPH media\r\n                                        </mat-panel-title>\r\n                                        <mat-icon class=\"clickableIcon\" aria-hidden=\"false\"\r\n                                            aria-label=\"Example home icon\" (click)=\"expandPanel(expPanelJPH,'stateJPH')\"\r\n                                            [@rotatedState]='stateJPH'>expand_more</mat-icon>\r\n                                    </mat-expansion-panel-header>\r\n                                    <p>I'm visible because I am open</p>\r\n                                </mat-expansion-panel>\r\n                            </mat-accordion>\r\n\r\n                        </div>\r\n                    </div>\r\n                </mat-card-content>\r\n                <!-- <mat-card-actions>\r\n                <button mat-button>LIKE</button>\r\n                <button mat-button>SHARE</button>\r\n            </mat-card-actions> -->\r\n            </mat-card>\r\n        </div>\r\n        <div class=\"detailsContainer\" [ngStyle]=\"{'left.%':  selectedWorkArea == null ? '25' : '46'}\">\r\n            <router-outlet name=\"dashboardContent\">\r\n            </router-outlet>\r\n        </div>\r\n    </div>\r\n</div>","import { Component } from '@angular/core';\r\nimport { Router } from '@angular/router';\r\n\r\nexport interface Tile {\r\n  color: string;\r\n  cols: number;\r\n  rows: number;\r\n  text: string;\r\n}\r\n\r\nconst navLinks = [\r\n  {\r\n    label: 'DiPreTreatUCChoice',\r\n    link: 'DiPreTreatUCChoice',\r\n  }\r\n];\r\n\r\n@Component({\r\n  selector: 'grid-list-uc',\r\n  templateUrl: './grid-list-uc.component.html',\r\n  styleUrls: ['./grid-list-uc.component.css'],\r\n})\r\nexport class GridListUCComponent {\r\n  tryBool: boolean = false\r\n\r\n\r\n  navLinks: any[]\r\n\r\n  constructor(private router: Router) {\r\n    this.navLinks = navLinks\r\n  }\r\n\r\n  buttons = [\r\n    { text: 'UC-A', value: \"A\", color: 'primary', image:'../../../assets/img/UC-A.png' },\r\n    { text: 'UC-B', value: \"B\", color: 'accent', image:'../../../assets/img/UC-B.png' },\r\n    { text: 'UC-C', value: \"C\", color: 'warn', image:'../../../assets/img/UC-C.png' },\r\n    { text: 'UC-D', value: \"D\", color: 'inactive', image:'../../../assets/img/UC-D.png' }\r\n  ]\r\n\r\n\r\n  onClickButton(useCase: string) {\r\n\r\n    switch (useCase) {\r\n\r\n      case 'A':\r\n        this.router.navigate(['UseCaseA'])\r\n        break;\r\n      case 'C':\r\n        this.router.navigate(['Home'])\r\n        break;\r\n      default: \r\n      this.router.navigate(['use-case-details'], { queryParams: { UC: useCase } })\r\n      break;\r\n    }\r\n  }\r\n\r\n\r\n}","<mat-grid-list cols=\"2\" rowHeight=\"2:1\">\n  <mat-grid-tile *ngFor=\"let b of buttons\">\n    <button class=\"uc-button\" mat-raised-button color={{b.color}} (click)=\"onClickButton(b.value)\">\n      <img [src]=\"b.image\" style=\"max-width:50%\">\n      <h1>{{b.text}}</h1>\n    </button>\n  </mat-grid-tile>\n</mat-grid-list>\n","import { Component, OnInit, Input } from '@angular/core';\nimport { MatDialogRef } from '@angular/material/dialog';\nimport { FormGroup, FormControl } from '@angular/forms';\nimport { AuthService } from 'src/app/services/auth.service';\n\n@Component({\n  selector: 'app-login-dialog',\n  templateUrl: './login-dialog.component.html',\n  styleUrls: ['./login-dialog.component.css']\n})\nexport class LoginDialogComponent implements OnInit {\n\n\n  loginForm: FormGroup\n  public dialogRef: MatDialogRef<LoginDialogComponent>\n  hide = true;\n\n  constructor(private authService: AuthService) {\n    this.loginForm = new FormGroup({\n      email: new FormControl(''),\n      password: new FormControl(''),\n    });\n  }\n\n\n\n  ngOnInit(): void {\n  }\n\n\n  onNoClick(): void {\n    this.dialogRef.close();\n  }\n\n\n\n\n  submit() {\n    if (this.loginForm.valid) {\n      this.save();\n    }\n  }\n  @Input() error: string | null;\n\n  save() {\n    this.authService.login(this.loginForm.value.email, this.loginForm.value.password).subscribe(response => {\n\n      console.log(response);\n\n      // if (response) {\n      //   var sess = {};\n      //   sess[\"email\"] = this.loginForm.value.email;\n      //   localStorage.setItem(\"session\", JSON.stringify(sess));\n      // }\n      // this.dialogRef.close();\n\n    }, error => {\n      this.error = error.error;\n    })\n\n\n  }\n\n  close() {\n    this.dialogRef.close();\n\n  }\n\n\n}\n\n/*@Component({\n  selector: 'dialog-overview-example-dialog',\n  templateUrl: 'dialog-overview-example-dialog.html',\n})\nexport class DialogOverviewExampleDialog {\n\n  constructor(\n    public dialogRef: MatDialogRef<DialogOverviewExampleDialog>,\n    @Inject(MAT_DIALOG_DATA) public data: DialogData) {}\n\n  onNoClick(): void {\n    this.dialogRef.close();\n  }\n\n}\n*/","<div>\n    <h1 mat-dialog-title>Login</h1>\n    <div mat-dialog-content>\n        <form [formGroup]=\"loginForm\" (ngSubmit)=\"submit()\">\n            <p>\n                <mat-form-field>\n                    <input required type=\"text\" matInput placeholder=\"Email\" formControlName=\"email\">\n                </mat-form-field>\n            </p>\n            <br>\n            <mat-form-field appearance=\"fill\">\n                <mat-label>Enter your password</mat-label>\n                <input matInput [type]=\"hide ? 'password' : 'text'\" formControlName=\"password\">\n                <button mat-icon-button matSuffix (click)=\"hide = !hide\" [attr.aria-label]=\"'Hide password'\"\n                    [attr.aria-pressed]=\"hide\">\n                    <mat-icon>{{hide ? 'visibility_off' : 'visibility'}}</mat-icon>\n                </button>\n            </mat-form-field>\n\n            <br>\n            <p *ngIf=\"error\" class=\"error\">\n                {{ error }}\n            </p>\n\n            <div>\n                <button mat-raised-button color=\"primary\">Confirm</button>\n                <button (click)=\"close()\" class=\"cancel\" mat-raised-button>Cancel</button>\n            </div>\n        </form>\n    </div>\n\n</div>","import { Component, Inject, OnInit } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { Router } from '@angular/router';\nimport { UCCService } from 'src/app/services/UC-C/uc-c-service.service';\n\n@Component({\n  selector: 'app-notification',\n  templateUrl: './notification.component.html',\n  styleUrls: ['./notification.component.css']\n})\nexport class NotificationComponent implements OnInit {\n\n  public dialogRef: MatDialogRef<NotificationComponent>\n\n  taskId: string\n  workAreaId: string\n  agvId: string\n  constructor(\n    private router: Router,\n    @Inject(MAT_DIALOG_DATA) public data, private UCCService: UCCService) {\n    if (data.taskId) this.taskId = data.taskId\n    if (data.workAreaId) this.workAreaId = data.workAreaId\n    if (data.agvId) this.agvId = data.agvId\n  }\n\n  ngOnInit(): void {\n  }\n\n  risolviOra() {\n    this.router.navigate([\"Home\", { outlets: { dashboardContent: [\"work-area\", this.workAreaId, \"agv-details\", this.agvId] } }], { queryParams: { taskId: this.taskId } });\n  }\n\n\n\n}\n","<mat-card id=\"modal\">\n    <h1 class=\"orangeText\" mat-dialog-title>NUOVA NOTIFICA</h1>\n\n    <div>\n        <p class=\"greyText\"> AREA LAVORO AMR </p>\n        <p class=\"greyText\"> AGV 1 </p>\n        <p class=\"greyText\"> COMPONENTE PN{{taskId}} </p>\n    </div>\n    <div>\n        <p class=\"errorText\">\n            E' stato rilevato l'errore<span id=\"tipologiaErrore\" class=\"orangeText\">\n            Tipologia Errore </span>durante il prelievo del componente PN{{taskId}}\n        </p>\n    </div>\n\n    <div class=\"actions\">\n        <button  mat-dialog-close class=\"whiteButton\" style=\"margin-right: 20px;\"\n            mat-button>POSPONI</button>\n        <button (click)=\"risolviOra()\"  mat-dialog-close class=\"darkBlueColor\" mat-button>RISOLVI ORA</button>\n    </div>\n</mat-card>","import { Component, OnInit } from '@angular/core';\nimport * as CanvasJS from '../../external-libraries/canvasjs.min'\n\n\ninterface Point {\n  x: number,\n  y: number\n}\n@Component({\n  selector: 'app-stats',\n  templateUrl: './stats.component.html',\n  styleUrls: ['./stats.component.css']\n})\nexport class StatsComponent implements OnInit {\n\n\n  constructor() {\n\n\n\n\n  }\n\n\n\n\n  ngOnInit() {\n    let chart = new CanvasJS.Chart(\"chartContainer\", {\n      zoomEnabled: true,\n      animationEnabled: true,\n      exportEnabled: true,\n      title: {\n        text: \"STATS\"\n      },\n      subtitles: [{\n        text: \"Try Zooming and Panning\"\n      }],\n      axisY: {\n        title: \"Humidity[%]\",\n      },\n      axisY2: {\n        title: \"Temperature[C]\", //TODO: definire unit \n      },\n      legend: {\n        cursor: \"pointer\",\n        verticalAlign: \"top\",\n        horizontalAlign: \"center\",\n        dockInsidePlotArea: true,\n      },\n      toolTip: {\n        shared: true\n      },\n      data: [\n        {\n          type: \"line\",\n          name: \"Humidity\",\n          axisYType: \"primary\",\n          showInLegend: true,\n          dataPoints: [{ x: 1, y: 2 } as Point, { x: 3, y: 5 } as Point]\n        },\n      ]\n    });\n\n    chart.render();\n  }\n\n}\n\n"," <div id=\"chartContainer\" style=\"height: 370px; width: 100%;\"></div>\n","import { Component, OnInit } from '@angular/core';\nimport { Router, ActivatedRoute } from '@angular/router';\nimport { MatIconRegistry } from '@angular/material/icon';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { Location } from '@angular/common';\n\n@Component({\n  selector: 'app-toolbar',\n  templateUrl: './toolbar.component.html',\n  styleUrls: ['./toolbar.component.css']\n})\nexport class ToolbarComponent implements OnInit {\n\n  path: string\n\n  constructor(private router: Router, public location: Location, iconRegistry: MatIconRegistry, sanitizer: DomSanitizer) {\n\n\n\n    iconRegistry.addSvgIcon(\n      'bell-icon-notified',\n      sanitizer.bypassSecurityTrustResourceUrl('assets/img/bellIconNotified.svg'));\n\n  }\n\n\n  ngOnInit(): void {\n\n    this.location.onUrlChange(() => {\n      this.path = \"\";\n      let url = this.location.path()\n      let normalizedUrl = url.slice(1, url.length)\n      let segments = normalizedUrl.split(\"/\")\n\n\n      for (let i = 0; i < segments.length; i++) {\n\n        console.log(segments[i])\n        switch (segments[i]) {\n          case \"(dashboardContent:work-area\":\n            segments[i] = \"Area di Lavoro\"\n            break;\n          case \"agv-details\":\n            segments[i] = \"AGV\"\n            break;\n          default:\n            break;\n        }\n\n        if (i == segments.length - 1) {\n          if (segments[i].endsWith(\")\")) {\n            this.path += segments[i].substring(0, segments[i].length - 1)\n          } else {\n            this.path += segments[i]\n          }\n        }\n        else\n          this.path += segments[i] + \" > \"\n      }\n    })\n\n  }\n\n\n  logout() {\n    // this.authService.logout()\n    this.router.navigate(['home'])\n  }\n}\n","<mat-toolbar>\n    <!-- <img routerLink=\"\" alt=\"Logo\" src=\"assets/logo.png\"/> -->\n    <p>\n        {{path}}\n    </p>\n    <span class=\"example-fill-remaining-space\"></span>\n    <!-- <span id=\"email\">{{authService.userMail}}</span> -->\n\n    <mat-divider [vertical]=\"true\"></mat-divider>\n    <mat-icon svgIcon=\"bell-icon-notified\" aria-hidden=\"false\" aria-label=\"Example of bell-icon-notified\">\n    </mat-icon>\n\n</mat-toolbar>","/*\n CanvasJS HTML5 & JavaScript Charts - v2.3.2 GA - https://canvasjs.com/\n Copyright 2018 fenopix\n\n  --------------------- License Information --------------------\n CanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.\n     https://canvasjs.com/license/\n\n*/\n/*eslint-disable*/\n/*jshint ignore:start*/\n(function () {\n    function qa(h, p) { h.prototype = eb(p.prototype); h.prototype.constructor = h; h.base = p.prototype; }\n    function eb(h) { function p() { } p.prototype = h; return new p; }\n    function Ya(h, p, D) {\n        \"millisecond\" === D ? h.setMilliseconds(h.getMilliseconds() + 1 * p) : \"second\" === D ? h.setSeconds(h.getSeconds() + 1 * p) : \"minute\" === D ? h.setMinutes(h.getMinutes() + 1 * p) : \"hour\" === D ? h.setHours(h.getHours() + 1 * p) : \"day\" === D ? h.setDate(h.getDate() + 1 * p) : \"week\" === D ? h.setDate(h.getDate() + 7 * p) : \"month\" === D ? h.setMonth(h.getMonth() + 1 * p) : \"year\" === D && h.setFullYear(h.getFullYear() +\n            1 * p);\n        return h;\n    }\n    function $(h, p) { var D = !1; 0 > h && (D = !0, h *= -1); h = \"\" + h; for (p = p ? p : 1; h.length < p;)\n        h = \"0\" + h; return D ? \"-\" + h : h; }\n    function Ia(h) { if (!h)\n        return h; h = h.replace(/^\\s\\s*/, \"\"); for (var p = /\\s/, D = h.length; p.test(h.charAt(--D));)\n        ; return h.slice(0, D + 1); }\n    function Ea(h) {\n        h.roundRect = function (h, D, r, u, H, F, z, v) {\n            z && (this.fillStyle = z);\n            v && (this.strokeStyle = v);\n            \"undefined\" === typeof H && (H = 5);\n            this.lineWidth = F;\n            this.beginPath();\n            this.moveTo(h + H, D);\n            this.lineTo(h + r - H, D);\n            this.quadraticCurveTo(h + r, D, h + r, D + H);\n            this.lineTo(h + r, D + u - H);\n            this.quadraticCurveTo(h + r, D + u, h + r - H, D + u);\n            this.lineTo(h + H, D + u);\n            this.quadraticCurveTo(h, D + u, h, D + u - H);\n            this.lineTo(h, D + H);\n            this.quadraticCurveTo(h, D, h + H, D);\n            this.closePath();\n            z && this.fill();\n            v && 0 < F && this.stroke();\n        };\n    }\n    function Sa(h, p) { return h - p; }\n    function Ta(h, p, D) {\n        if (h && p && D) {\n            D = D + \".\" + p;\n            var r = \"image/\" + p;\n            h = h.toDataURL(r);\n            var u = !1, H = document.createElement(\"a\");\n            H.download = D;\n            H.href = h;\n            if (\"undefined\" !== typeof Blob && new Blob) {\n                for (var F = h.replace(/^data:[a-z\\/]*;base64,/, \"\"), F = atob(F), z = new ArrayBuffer(F.length), z = new Uint8Array(z), v = 0; v < F.length; v++)\n                    z[v] = F.charCodeAt(v);\n                p = new Blob([z.buffer], { type: \"image/\" + p });\n                try {\n                    window.navigator.msSaveBlob(p, D), u = !0;\n                }\n                catch (L) {\n                    H.dataset.downloadurl = [r, H.download, H.href].join(\":\"), H.href = window.URL.createObjectURL(p);\n                }\n            }\n            if (!u)\n                try {\n                    event = document.createEvent(\"MouseEvents\"), event.initMouseEvent(\"click\", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), H.dispatchEvent ? H.dispatchEvent(event) : H.fireEvent && H.fireEvent(\"onclick\");\n                }\n                catch (E) {\n                    p = window.open(), p.document.write(\"<img src='\" + h + \"'></img><div>Please right click on the image and save it to your device</div>\"),\n                        p.document.close();\n                }\n        }\n    }\n    function N(h) { var p = ((h & 16711680) >> 16).toString(16), D = ((h & 65280) >> 8).toString(16); h = ((h & 255) >> 0).toString(16); p = 2 > p.length ? \"0\" + p : p; D = 2 > D.length ? \"0\" + D : D; h = 2 > h.length ? \"0\" + h : h; return \"#\" + p + D + h; }\n    function fb(h, p) { var D = this.length >>> 0, r = Number(p) || 0, r = 0 > r ? Math.ceil(r) : Math.floor(r); for (0 > r && (r += D); r < D; r++)\n        if (r in this && this[r] === h)\n            return r; return -1; }\n    function u(h) { return null === h || \"undefined\" === typeof h; }\n    function Fa(h) { h.indexOf || (h.indexOf = fb); return h; }\n    function gb(h) {\n        if (U.fSDec)\n            h[ja(\"`eeDwdouMhrudods\")](ja(\"e`u`@ohl`uhnoHuds`uhnoDoe\"), function () { U._fTWm && U._fTWm(h); });\n    }\n    function Za(h, p, D) {\n        D = D || \"normal\";\n        var r = h + \"_\" + p + \"_\" + D, u = $a[r];\n        if (isNaN(u)) {\n            try {\n                h = \"position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:\" + h + \"; font-size:\" + p + \"px; font-weight:\" + D + \";\";\n                if (!xa) {\n                    var H = document.body;\n                    xa = document.createElement(\"span\");\n                    xa.innerHTML = \"\";\n                    var F = document.createTextNode(\"Mpgyi\");\n                    xa.appendChild(F);\n                    H.appendChild(xa);\n                }\n                xa.style.display = \"\";\n                xa.setAttribute(\"style\", h);\n                u = Math.round(xa.offsetHeight);\n                xa.style.display = \"none\";\n            }\n            catch (z) {\n                u = Math.ceil(1.1 * p);\n            }\n            u = Math.max(u, p);\n            $a[r] = u;\n        }\n        return u;\n    }\n    function R(h, p) { var D = []; if (D = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1, 2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[h || \"solid\"])\n        for (var r = 0; r < D.length; r++)\n            D[r] *= p;\n    else\n        D = []; return D; }\n    function O(h, p, D, r, u) {\n        r = r || [];\n        u = u || !1;\n        r.push([h, p, D, u]);\n        return h.addEventListener ? (h.addEventListener(p, D, u), D) : h.attachEvent ?\n            (r = function (p) { p = p || window.event; p.preventDefault = p.preventDefault || function () { p.returnValue = !1; }; p.stopPropagation = p.stopPropagation || function () { p.cancelBubble = !0; }; D.call(h, p); }, h.attachEvent(\"on\" + p, r), r) : !1;\n    }\n    function ab(h, p, D) { h *= W; p *= W; h = D.getImageData(h, p, 2, 2).data; p = !0; for (D = 0; 4 > D; D++)\n        if (h[D] !== h[D + 4] | h[D] !== h[D + 8] | h[D] !== h[D + 12]) {\n            p = !1;\n            break;\n        } return p ? h[0] << 16 | h[1] << 8 | h[2] : 0; }\n    function na(h, p, D) { return h in p ? p[h] : D[h]; }\n    function Oa(h, p, D) {\n        if (r && bb) {\n            var u = h.getContext(\"2d\");\n            Pa = u.webkitBackingStorePixelRatio ||\n                u.mozBackingStorePixelRatio || u.msBackingStorePixelRatio || u.oBackingStorePixelRatio || u.backingStorePixelRatio || 1;\n            W = Ua / Pa;\n            h.width = p * W;\n            h.height = D * W;\n            Ua !== Pa && (h.style.width = p + \"px\", h.style.height = D + \"px\", u.scale(W, W));\n        }\n        else\n            h.width = p, h.height = D;\n    }\n    function hb(h) {\n        if (!ib) {\n            var p = !1, D = !1;\n            \"undefined\" === typeof ra.Chart.creditHref ? (h.creditHref = ja(\"iuuqr;..b`ow`rkr/bnl.\"), h.creditText = ja(\"B`ow`rKR/bnl\")) : (p = h.updateOption(\"creditText\"), D = h.updateOption(\"creditHref\"));\n            if (h.creditHref && h.creditText) {\n                h._creditLink ||\n                    (h._creditLink = document.createElement(\"a\"), h._creditLink.setAttribute(\"class\", \"canvasjs-chart-credit\"), h._creditLink.setAttribute(\"title\", \"JavaScript Charts\"), h._creditLink.setAttribute(\"style\", \"outline:none;margin:0px;position:absolute;right:2px;top:\" + (h.height - 14) + \"px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif\"), h._creditLink.setAttribute(\"tabIndex\", -1), h._creditLink.setAttribute(\"target\", \"_blank\"));\n                if (0 === h.renderCount ||\n                    p || D)\n                    h._creditLink.setAttribute(\"href\", h.creditHref), h._creditLink.innerHTML = h.creditText;\n                h._creditLink && h.creditHref && h.creditText ? (h._creditLink.parentElement || h._canvasJSContainer.appendChild(h._creditLink), h._creditLink.style.top = h.height - 14 + \"px\") : h._creditLink.parentElement && h._canvasJSContainer.removeChild(h._creditLink);\n            }\n        }\n    }\n    function ta(h, p) {\n        Ja && (this.canvasCount |= 0, window.console.log(++this.canvasCount));\n        var D = document.createElement(\"canvas\");\n        D.setAttribute(\"class\", \"canvasjs-chart-canvas\");\n        Oa(D, h, p);\n        r || \"undefined\" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(D);\n        return D;\n    }\n    function sa(h, p, D) { for (var r in D)\n        p.style[r] = D[r]; }\n    function ua(h, p, D) {\n        p.getAttribute(\"state\") || (p.style.backgroundColor = h.toolbar.backgroundColor, p.style.color = h.toolbar.fontColor, p.style.border = \"none\", sa(h, p, { WebkitUserSelect: \"none\", MozUserSelect: \"none\", msUserSelect: \"none\", userSelect: \"none\" }));\n        p.getAttribute(\"state\") !== D && (p.setAttribute(\"state\", D), p.setAttribute(\"type\", \"button\"), sa(h, p, { padding: \"5px 12px\",\n            cursor: \"pointer\", \"float\": \"left\", width: \"40px\", height: \"25px\", outline: \"0px\", verticalAlign: \"baseline\", lineHeight: \"0\" }), p.setAttribute(\"title\", h._cultureInfo[D + \"Text\"]), p.innerHTML = \"<img style='height:95%; pointer-events: none;' src='\" + jb[D].image + \"' alt='\" + h._cultureInfo[D + \"Text\"] + \"' />\");\n    }\n    function Qa() { for (var h = null, p = 0; p < arguments.length; p++)\n        h = arguments[p], h.style && (h.style.display = \"inline\"); }\n    function va() { for (var h = null, p = 0; p < arguments.length; p++)\n        (h = arguments[p]) && h.style && (h.style.display = \"none\"); }\n    function V(h, p, D, r, v) {\n        this._defaultsKey = h;\n        this._themeOptionsKey = p;\n        this._index = r;\n        this.parent = v;\n        this._eventListeners = [];\n        h = {};\n        this.theme && u(p) && u(r) ? h = u(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[p]) && (null === r ? h = this.parent.themeOptions[p] : 0 < this.parent.themeOptions[p].length && (r = Math.min(this.parent.themeOptions[p].length - 1, r), h = this.parent.themeOptions[p][r]));\n        this.themeOptions = h;\n        this.options = D ? D : { _isPlaceholder: !0 };\n        this.setOptions(this.options, h);\n    }\n    function Ga(h, p, r, u, v) { \"undefined\" === typeof v && (v = 0); this._padding = v; this._x1 = h; this._y1 = p; this._x2 = r; this._y2 = u; this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding; }\n    function ka(h, p) { ka.base.constructor.call(this, \"TextBlock\", null, p, null, null); this.ctx = h; this._isDirty = !0; this._wrappedText = null; this._initialize(); }\n    function Va(h, p) {\n        Va.base.constructor.call(this, \"Toolbar\", \"toolbar\", p, null, h);\n        this.chart = h;\n        this.canvas = h.canvas;\n        this.ctx = this.chart.ctx;\n        this.optionsName =\n            \"toolbar\";\n    }\n    function Aa(h, p) {\n        Aa.base.constructor.call(this, \"Title\", \"title\", p, null, h);\n        this.chart = h;\n        this.canvas = h.canvas;\n        this.ctx = this.chart.ctx;\n        this.optionsName = \"title\";\n        if (u(this.options.margin) && h.options.subtitles)\n            for (var r = h.options.subtitles, za = 0; za < r.length; za++)\n                if ((u(r[za].horizontalAlign) && \"center\" === this.horizontalAlign || r[za].horizontalAlign === this.horizontalAlign) && (u(r[za].verticalAlign) && \"top\" === this.verticalAlign || r[za].verticalAlign === this.verticalAlign) && !r[za].dockInsidePlotArea === !this.dockInsidePlotArea) {\n                    this.margin =\n                        0;\n                    break;\n                }\n        \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\n        this.height = this.width = null;\n        this.bounds = { x1: null, y1: null, x2: null, y2: null };\n    }\n    function Ka(h, p, r) {\n        Ka.base.constructor.call(this, \"Subtitle\", \"subtitles\", p, r, h);\n        this.chart = h;\n        this.canvas = h.canvas;\n        this.ctx = this.chart.ctx;\n        this.optionsName = \"subtitles\";\n        this.isOptionsInArray = !0;\n        \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\n        this.height = this.width = null;\n        this.bounds = { x1: null, y1: null, x2: null, y2: null };\n    }\n    function Wa() { this.pool = []; }\n    function La(h) { var p; h && Ma[h] && (p = Ma[h]); La.base.constructor.call(this, \"CultureInfo\", null, p, null, null); }\n    var Ja = !1, U = {}, r = !!document.createElement(\"canvas\").getContext, ra = { Chart: { width: 500, height: 400, zoomEnabled: !1, zoomType: \"x\", backgroundColor: \"white\", theme: \"light1\", animationEnabled: !1, animationDuration: 1200, dataPointWidth: null, dataPointMinWidth: null, dataPointMaxWidth: null, colorSet: \"colorSet1\", culture: \"en\", creditHref: \"\", creditText: \"CanvasJS\",\n            interactivityEnabled: !0, exportEnabled: !1, exportFileName: \"Chart\", rangeChanging: null, rangeChanged: null, publicProperties: { title: \"readWrite\", subtitles: \"readWrite\", toolbar: \"readWrite\", toolTip: \"readWrite\", legend: \"readWrite\", axisX: \"readWrite\", axisY: \"readWrite\", axisX2: \"readWrite\", axisY2: \"readWrite\", data: \"readWrite\", options: \"readWrite\", bounds: \"readOnly\", container: \"readOnly\" } }, Title: { padding: 0, text: null, verticalAlign: \"top\", horizontalAlign: \"center\", fontSize: 20, fontFamily: \"Calibri\", fontWeight: \"normal\", fontColor: \"black\",\n            fontStyle: \"normal\", borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: r ? \"transparent\" : null, margin: 5, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, Subtitle: { padding: 0, text: null, verticalAlign: \"top\", horizontalAlign: \"center\", fontSize: 14, fontFamily: \"Calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: null, margin: 2, wrap: !0, maxWidth: null,\n            dockInsidePlotArea: !1, publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, Toolbar: { backgroundColor: \"white\", backgroundColorOnHover: \"#2196f3\", borderColor: \"#2196f3\", borderThickness: 1, fontColor: \"black\", fontColorOnHover: \"white\", publicProperties: { options: \"readWrite\", chart: \"readOnly\" } }, Legend: { name: null, verticalAlign: \"center\", horizontalAlign: \"right\", fontSize: 14, fontFamily: \"calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", cursor: null, itemmouseover: null, itemmouseout: null,\n            itemmousemove: null, itemclick: null, dockInsidePlotArea: !1, reversed: !1, backgroundColor: r ? \"transparent\" : null, borderColor: r ? \"transparent\" : null, borderThickness: 0, cornerRadius: 0, maxWidth: null, maxHeight: null, markerMargin: null, itemMaxWidth: null, itemWidth: null, itemWrap: !0, itemTextFormatter: null, publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, ToolTip: { enabled: !0, shared: !1, animationEnabled: !0, content: null, contentFormatter: null, reversed: !1, backgroundColor: r ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\",\n            borderColor: null, borderThickness: 2, cornerRadius: 5, fontSize: 14, fontColor: \"black\", fontFamily: \"Calibri, Arial, Georgia, serif;\", fontWeight: \"normal\", fontStyle: \"italic\", publicProperties: { options: \"readWrite\", chart: \"readOnly\" } }, Axis: { minimum: null, maximum: null, viewportMinimum: null, viewportMaximum: null, interval: null, intervalType: null, reversed: !1, logarithmic: !1, logarithmBase: 10, title: null, titleFontColor: \"black\", titleFontSize: 20, titleFontFamily: \"arial\", titleFontWeight: \"normal\", titleFontStyle: \"normal\", titleWrap: !0,\n            titleMaxWidth: null, titleBackgroundColor: r ? \"transparent\" : null, titleBorderColor: r ? \"transparent\" : null, titleBorderThickness: 0, titleCornerRadius: 0, labelAngle: 0, labelFontFamily: \"arial\", labelFontColor: \"black\", labelFontSize: 12, labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelAutoFit: !0, labelWrap: !0, labelMaxWidth: null, labelFormatter: null, labelBackgroundColor: r ? \"transparent\" : null, labelBorderColor: r ? \"transparent\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelPlacement: \"outside\", prefix: \"\", suffix: \"\",\n            includeZero: !0, tickLength: 5, tickColor: \"black\", tickThickness: 1, lineColor: \"black\", lineThickness: 1, lineDashType: \"solid\", gridColor: \"A0A0A0\", gridThickness: 0, gridDashType: \"solid\", interlacedColor: r ? \"transparent\" : null, valueFormatString: null, margin: 2, publicProperties: { options: \"readWrite\", stripLines: \"readWrite\", scaleBreaks: \"readWrite\", crosshair: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, StripLine: { value: null, startValue: null, endValue: null, color: \"orange\", opacity: null, thickness: 2, lineDashType: \"solid\", label: \"\",\n            labelPlacement: \"inside\", labelAlign: \"far\", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: null, labelBorderColor: r ? \"transparent\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: \"arial\", labelFontColor: \"orange\", labelFontSize: 12, labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelFormatter: null, showOnTop: !1, publicProperties: { options: \"readWrite\", axis: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, ScaleBreaks: { autoCalculate: !1, collapsibleThreshold: \"25%\", maxNumberOfAutoBreaks: 2, spacing: 8,\n            type: \"straight\", color: \"#FFFFFF\", fillOpacity: 0.9, lineThickness: 2, lineColor: \"#E16E6E\", lineDashType: \"solid\", publicProperties: { options: \"readWrite\", customBreaks: \"readWrite\", axis: \"readOnly\", autoBreaks: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, Break: { startValue: null, endValue: null, spacing: 8, type: \"straight\", color: \"#FFFFFF\", fillOpacity: 0.9, lineThickness: 2, lineColor: \"#E16E6E\", lineDashType: \"solid\", publicProperties: { options: \"readWrite\", scaleBreaks: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, Crosshair: { enabled: !1,\n            snapToDataPoint: !1, color: \"grey\", opacity: null, thickness: 2, lineDashType: \"solid\", label: \"\", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: r ? \"grey\" : null, labelBorderColor: r ? \"grey\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: r ? \"Calibri, Optima, Candara, Verdana, Geneva, sans-serif\" : \"calibri\", labelFontSize: 12, labelFontColor: \"#fff\", labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelFormatter: null, valueFormatString: null, publicProperties: { options: \"readWrite\", axis: \"readOnly\", bounds: \"readOnly\",\n                chart: \"readOnly\" } }, DataSeries: { name: null, dataPoints: null, label: \"\", bevelEnabled: !1, highlightEnabled: !0, cursor: \"default\", indexLabel: \"\", indexLabelPlacement: \"auto\", indexLabelOrientation: \"horizontal\", indexLabelFontColor: \"black\", indexLabelFontSize: 12, indexLabelFontStyle: \"normal\", indexLabelFontFamily: \"Arial\", indexLabelFontWeight: \"normal\", indexLabelBackgroundColor: null, indexLabelLineColor: \"gray\", indexLabelLineThickness: 1, indexLabelLineDashType: \"solid\", indexLabelMaxWidth: null, indexLabelWrap: !0, indexLabelFormatter: null,\n            lineThickness: 2, lineDashType: \"solid\", connectNullData: !1, nullDataLineDashType: \"dash\", color: null, lineColor: null, risingColor: \"white\", fallingColor: \"red\", fillOpacity: null, startAngle: 0, radius: null, innerRadius: null, neckHeight: null, neckWidth: null, reversed: !1, valueRepresents: null, linkedDataSeriesIndex: null, whiskerThickness: 2, whiskerDashType: \"solid\", whiskerColor: null, whiskerLength: null, stemThickness: 2, stemColor: null, stemDashType: \"solid\", upperBoxColor: \"white\", lowerBoxColor: \"white\", type: \"column\", xValueType: \"number\",\n            axisXType: \"primary\", axisYType: \"primary\", axisXIndex: 0, axisYIndex: 0, xValueFormatString: null, yValueFormatString: null, zValueFormatString: null, percentFormatString: null, showInLegend: null, legendMarkerType: null, legendMarkerColor: null, legendText: null, legendMarkerBorderColor: r ? \"transparent\" : null, legendMarkerBorderThickness: 0, markerType: \"circle\", markerColor: null, markerSize: null, markerBorderColor: r ? \"transparent\" : null, markerBorderThickness: 0, mouseover: null, mouseout: null, mousemove: null, click: null, toolTipContent: null,\n            visible: !0, publicProperties: { options: \"readWrite\", axisX: \"readWrite\", axisY: \"readWrite\", chart: \"readOnly\" } }, TextBlock: { x: 0, y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: \"\", horizontalAlign: \"center\", fontSize: 12, fontFamily: \"calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: null, textBaseline: \"top\" }, CultureInfo: { decimalSeparator: \".\", digitGroupSeparator: \",\", zoomText: \"Zoom\", panText: \"Pan\", resetText: \"Reset\",\n            menuText: \"More Options\", saveJPGText: \"Save as JPEG\", savePNGText: \"Save as PNG\", printText: \"Print\", days: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), shortDays: \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"), months: \"January February March April May June July August September October November December\".split(\" \"), shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \") } }, Ma = { en: {} }, v = r ? \"Trebuchet MS, Helvetica, sans-serif\" : \"Arial\", Ha = r ? \"Impact, Charcoal, sans-serif\" : \"Arial\", Ba = { colorSet1: \"#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566\".split(\" \"), colorSet2: \"#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C\".split(\" \"), colorSet3: \"#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970\".split(\" \") }, I, fa, Q, ha, ga;\n    fa = \"#333333\";\n    Q = \"#000000\";\n    I = \"#666666\";\n    ga = ha = \"#000000\";\n    var X = 20, E = 14, Xa = { colorSet: \"colorSet1\",\n        backgroundColor: \"#FFFFFF\", title: { fontFamily: Ha, fontSize: 32, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: Ha, fontSize: E, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], data: [{ indexLabelFontFamily: v, indexLabelFontSize: E, indexLabelFontColor: fa, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: fa, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\",\n                lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisX2: [{ titleFontFamily: v,\n                titleFontSize: X, titleFontColor: fa, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1,\n                    lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisY: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: fa, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\",\n                        thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisY2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: fa, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1,\n                gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], legend: { fontFamily: v, fontSize: 14, fontColor: fa, fontWeight: \"bold\", verticalAlign: \"bottom\",\n            horizontalAlign: \"center\" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1 } };\n    Q = fa = \"#F5F5F5\";\n    I = \"#FFFFFF\";\n    ha = \"#40BAF1\";\n    ga = \"#F5F5F5\";\n    var X = 20, E = 14, cb = { colorSet: \"colorSet2\", title: { fontFamily: v, fontSize: 33, fontColor: \"#3A3A3A\", fontWeight: \"bold\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: v, fontSize: E, fontColor: \"#3A3A3A\", fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], data: [{ indexLabelFontFamily: v, indexLabelFontSize: E, indexLabelFontColor: \"#666666\", indexLabelFontWeight: \"normal\",\n                indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 1, lineColor: \"#BBBBBB\", tickThickness: 1, tickColor: \"#BBBBBB\", gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E,\n                    labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisX2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 1, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\",\n                stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisY: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: \"#666666\", titleFontWeight: \"normal\",\n                labelFontFamily: v, labelFontSize: E, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 0, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" },\n                scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisY2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 0, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null,\n                        color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], legend: { fontFamily: v, fontSize: 14, fontColor: \"#3A3A3A\", fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1 } };\n    Q = fa = \"#F5F5F5\";\n    I = \"#FFFFFF\";\n    ha = \"#40BAF1\";\n    ga = \"#F5F5F5\";\n    X = 20;\n    E = 14;\n    Ha = { colorSet: \"colorSet12\", backgroundColor: \"#2A2A2A\", title: { fontFamily: Ha, fontSize: 32, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: Ha, fontSize: E, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], toolbar: { backgroundColor: \"#666666\", backgroundColorOnHover: \"#FF7372\", borderColor: \"#FF7372\", borderThickness: 1, fontColor: \"#F5F5F5\", fontColorOnHover: \"#F5F5F5\" }, data: [{ indexLabelFontFamily: v, indexLabelFontSize: E,\n                indexLabelFontColor: Q, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v,\n                    labelFontSize: E, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisX2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{ labelFontFamily: v,\n                        labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: \"normal\", labelFontFamily: v,\n                labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\",\n                    lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#000000\",\n                    labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], legend: { fontFamily: v, fontSize: 14, fontColor: fa, fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1, fontColor: Q, backgroundColor: \"rgba(0, 0, 0, .7)\" } };\n    I = \"#FFFFFF\";\n    Q = fa = \"#FAFAFA\";\n    ha = \"#40BAF1\";\n    ga = \"#F5F5F5\";\n    var X = 20, E = 14, ya = { light1: Xa, light2: cb, dark1: Ha, dark2: { colorSet: \"colorSet2\", backgroundColor: \"#32373A\", title: { fontFamily: v, fontSize: 32, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: v, fontSize: E, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], toolbar: { backgroundColor: \"#666666\", backgroundColorOnHover: \"#FF7372\", borderColor: \"#FF7372\", borderThickness: 1, fontColor: \"#F5F5F5\", fontColorOnHover: \"#F5F5F5\" }, data: [{ indexLabelFontFamily: v, indexLabelFontSize: E,\n                    indexLabelFontColor: Q, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v,\n                        labelFontSize: E, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisX2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 1, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 0, gridColor: I, stripLines: [{ labelFontFamily: v,\n                            labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: \"normal\", labelFontFamily: v,\n                    labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 0, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\",\n                        lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY2: [{ titleFontFamily: v, titleFontSize: X, titleFontColor: Q, titleFontWeight: \"normal\", labelFontFamily: v, labelFontSize: E, labelFontColor: Q, labelFontWeight: \"normal\", lineThickness: 0, lineColor: I, tickThickness: 1, tickColor: I, gridThickness: 1, gridColor: I, stripLines: [{ labelFontFamily: v, labelFontSize: E, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: v, labelFontSize: E, labelFontColor: \"#000000\",\n                        labelFontWeight: \"normal\", labelBackgroundColor: ga, color: ha, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], legend: { fontFamily: v, fontSize: 14, fontColor: fa, fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1, fontColor: Q, backgroundColor: \"rgba(0, 0, 0, .7)\" } }, theme1: Xa, theme2: cb, theme3: Xa }, S = { numberDuration: 1,\n        yearDuration: 314496E5, monthDuration: 2592E6, weekDuration: 6048E5, dayDuration: 864E5, hourDuration: 36E5, minuteDuration: 6E4, secondDuration: 1E3, millisecondDuration: 1, dayOfWeekFromInt: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \") };\n    (function () {\n        U.fSDec = function (h) { for (var p = \"\", r = 0; r < h.length; r++)\n            p += String.fromCharCode(Math.ceil(h.length / 57 / 5) ^ h.charCodeAt(r)); return p; };\n        U.obj = { trVs: \"Ush`m!Wdsrhno\", fntStr: \"qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg\", txtBl: \"udyuC`rdmhod\",\n            fnt: \"gnou\", fSy: \"ghmmRuxmd\", fTx: \"ghmmUdyu\", grClr: \"fsdx\", cntx: \"buy\", tp: \"unq\" };\n        delete ra[U.fSDec(\"Bi`su\")][U.fSDec(\"bsdehuIsdg\")];\n        U.pro = { sCH: ra[U.fSDec(\"Bi`su\")][U.fSDec(\"bsdehuIsdg\")] };\n        U._fTWm = function (h) { if (\"undefined\" === typeof U.pro.sCH && !db)\n            try {\n                var p = h[U.fSDec(U.obj.cntx)];\n                p[U.fSDec(U.obj.txtBl)] = U.fSDec(U.obj.tp);\n                p[U.fSDec(U.obj.fnt)] = 11 + U.fSDec(U.obj.fntStr);\n                p[U.fSDec(U.obj.fSy)] = U.fSDec(U.obj.grClr);\n                p[U.fSDec(U.obj.fTx)](U.fSDec(U.obj.trVs), 2, h.height - 11 - 2);\n            }\n            catch (r) { } };\n    })();\n    var $a = {}, xa = null, kb = function () { this.ctx.clearRect(0, 0, this.width, this.height); this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height)); }, lb = function (h, p, r) { p = Math.min(this.width, this.height); return Math.max(\"theme4\" === this.theme ? 0 : 300 <= p ? 12 : 10, Math.round(p * (h / 400))); }, Ca = function () {\n        var h = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|\"[^\"]*\"|'[^']*'/g, p = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), r = \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"), u = \"January February March April May June July August September October November December\".split(\" \"), v = \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"), H = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g, F = /[^-+\\dA-Z]/g;\n        return function (z, E, L) {\n            var R = L ? L.days : p, I = L ? L.months : u, N = L ? L.shortDays : r, O = L ? L.shortMonths : v;\n            L = \"\";\n            var S = !1;\n            z = z && z.getTime ? z : z ? new Date(z) : new Date;\n            if (isNaN(z))\n                throw SyntaxError(\"invalid date\");\n            \"UTC:\" === E.slice(0, 4) && (E = E.slice(4), S = !0);\n            L = S ? \"getUTC\" : \"get\";\n            var U = z[L + \"Date\"](), V = z[L + \"Day\"](), M = z[L + \"Month\"](), Q = z[L + \"FullYear\"](), a = z[L + \"Hours\"](), d = z[L + \"Minutes\"](), b = z[L + \"Seconds\"](), c = z[L + \"Milliseconds\"](), e = S ? 0 : z.getTimezoneOffset();\n            return L = E.replace(h, function (g) {\n                switch (g) {\n                    case \"D\": return U;\n                    case \"DD\": return $(U, 2);\n                    case \"DDD\": return N[V];\n                    case \"DDDD\": return R[V];\n                    case \"M\": return M + 1;\n                    case \"MM\": return $(M + 1, 2);\n                    case \"MMM\": return O[M];\n                    case \"MMMM\": return I[M];\n                    case \"Y\": return parseInt(String(Q).slice(-2));\n                    case \"YY\": return $(String(Q).slice(-2), 2);\n                    case \"YYY\": return $(String(Q).slice(-3), 3);\n                    case \"YYYY\": return $(Q, 4);\n                    case \"h\": return a % 12 || 12;\n                    case \"hh\": return $(a % 12 || 12, 2);\n                    case \"H\": return a;\n                    case \"HH\": return $(a, 2);\n                    case \"m\": return d;\n                    case \"mm\": return $(d, 2);\n                    case \"s\": return b;\n                    case \"ss\": return $(b, 2);\n                    case \"f\": return String(c).slice(0, 1);\n                    case \"ff\": return $(String(c).slice(0, 2), 2);\n                    case \"fff\": return $(String(c).slice(0, 3), 3);\n                    case \"t\": return 12 > a ? \"a\" : \"p\";\n                    case \"tt\": return 12 > a ? \"am\" : \"pm\";\n                    case \"T\": return 12 > a ? \"A\" :\n                        \"P\";\n                    case \"TT\": return 12 > a ? \"AM\" : \"PM\";\n                    case \"K\": return S ? \"UTC\" : (String(z).match(H) || [\"\"]).pop().replace(F, \"\");\n                    case \"z\": return (0 < e ? \"-\" : \"+\") + Math.floor(Math.abs(e) / 60);\n                    case \"zz\": return (0 < e ? \"-\" : \"+\") + $(Math.floor(Math.abs(e) / 60), 2);\n                    case \"zzz\": return (0 < e ? \"-\" : \"+\") + $(Math.floor(Math.abs(e) / 60), 2) + $(Math.abs(e) % 60, 2);\n                    default: return g.slice(1, g.length - 1);\n                }\n            });\n        };\n    }(), ba = function (h, p, r) {\n        if (null === h)\n            return \"\";\n        if (!isFinite(h))\n            return h;\n        h = Number(h);\n        var u = 0 > h ? !0 : !1;\n        u && (h *= -1);\n        var v = r ? r.decimalSeparator : \".\", H = r ? r.digitGroupSeparator :\n            \",\", F = \"\";\n        p = String(p);\n        var F = 1, z = r = \"\", E = -1, L = [], R = [], I = 0, N = 0, S = 0, O = !1, U = 0, z = p.match(/\"[^\"]*\"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\\u2030|./g);\n        p = null;\n        for (var Q = 0; z && Q < z.length; Q++)\n            if (p = z[Q], \".\" === p && 0 > E)\n                E = Q;\n            else {\n                if (\"%\" === p)\n                    F *= 100;\n                else if (\"\\u2030\" === p) {\n                    F *= 1E3;\n                    continue;\n                }\n                else if (\",\" === p[0] && \".\" === p[p.length - 1]) {\n                    F /= Math.pow(1E3, p.length - 1);\n                    E = Q + p.length - 1;\n                    continue;\n                }\n                else\n                    \"E\" !== p[0] && \"e\" !== p[0] || \"0\" !== p[p.length - 1] || (O = !0);\n                0 > E ? (L.push(p), \"#\" === p || \"0\" === p ? I++ : \",\" === p && S++) : (R.push(p), \"#\" !== p && \"0\" !== p || N++);\n            }\n        O && (p = Math.floor(h),\n            z = -Math.floor(Math.log(h) / Math.LN10 + 1), U = 0 === h ? 0 : 0 === p ? -(I + z) : String(p).length - I, F /= Math.pow(10, U));\n        0 > E && (E = Q);\n        F = (h * F).toFixed(N);\n        p = F.split(\".\");\n        F = (p[0] + \"\").split(\"\");\n        h = (p[1] + \"\").split(\"\");\n        F && \"0\" === F[0] && F.shift();\n        for (O = z = Q = N = E = 0; 0 < L.length;)\n            if (p = L.pop(), \"#\" === p || \"0\" === p)\n                if (E++, E === I) {\n                    var M = F, F = [];\n                    if (\"0\" === p)\n                        for (p = I - N - (M ? M.length : 0); 0 < p;)\n                            M.unshift(\"0\"), p--;\n                    for (; 0 < M.length;)\n                        r = M.pop() + r, O++, 0 === O % z && (Q === S && 0 < M.length) && (r = H + r);\n                }\n                else\n                    0 < F.length ? (r = F.pop() + r, N++, O++) : \"0\" === p && (r = \"0\" + r, N++, O++), 0 === O %\n                        z && (Q === S && 0 < F.length) && (r = H + r);\n            else\n                \"E\" !== p[0] && \"e\" !== p[0] || \"0\" !== p[p.length - 1] || !/[eE][+-]*[0]+/.test(p) ? \",\" === p ? (Q++, z = O, O = 0, 0 < F.length && (r = H + r)) : r = 1 < p.length && ('\"' === p[0] && '\"' === p[p.length - 1] || \"'\" === p[0] && \"'\" === p[p.length - 1]) ? p.slice(1, p.length - 1) + r : p + r : (p = 0 > U ? p.replace(\"+\", \"\").replace(\"-\", \"\") : p.replace(\"-\", \"\"), r += p.replace(/[0]+/, function (h) { return $(U, h.length); }));\n        H = \"\";\n        for (L = !1; 0 < R.length;)\n            p = R.shift(), \"#\" === p || \"0\" === p ? 0 < h.length && 0 !== Number(h.join(\"\")) ? (H += h.shift(), L = !0) : \"0\" === p && (H += \"0\", L =\n                !0) : 1 < p.length && ('\"' === p[0] && '\"' === p[p.length - 1] || \"'\" === p[0] && \"'\" === p[p.length - 1]) ? H += p.slice(1, p.length - 1) : \"E\" !== p[0] && \"e\" !== p[0] || \"0\" !== p[p.length - 1] || !/[eE][+-]*[0]+/.test(p) ? H += p : (p = 0 > U ? p.replace(\"+\", \"\").replace(\"-\", \"\") : p.replace(\"-\", \"\"), H += p.replace(/[0]+/, function (h) { return $(U, h.length); }));\n        r += (L ? v : \"\") + H;\n        return u ? \"-\" + r : r;\n    }, Ra = function (h) {\n        var p = 0, r = 0;\n        h = h || window.event;\n        h.offsetX || 0 === h.offsetX ? (p = h.offsetX, r = h.offsetY) : h.layerX || 0 == h.layerX ? (p = h.layerX, r = h.layerY) : (p = h.pageX - h.target.offsetLeft,\n            r = h.pageY - h.target.offsetTop);\n        return { x: p, y: r };\n    }, bb = !0, Ua = window.devicePixelRatio || 1, Pa = 1, W = bb ? Ua / Pa : 1, ea = function (h, p, r, u, v, H, F, z, E, L, R, N, O) {\n        \"undefined\" === typeof O && (O = 1);\n        F = F || 0;\n        z = z || \"black\";\n        var I = 15 < u - p && 15 < v - r ? 8 : 0.35 * Math.min(u - p, v - r);\n        h.beginPath();\n        h.moveTo(p, r);\n        h.save();\n        h.fillStyle = H;\n        h.globalAlpha = O;\n        h.fillRect(p, r, u - p, v - r);\n        h.globalAlpha = 1;\n        0 < F && (O = 0 === F % 2 ? 0 : 0.5, h.beginPath(), h.lineWidth = F, h.strokeStyle = z, h.moveTo(p, r), h.rect(p - O, r - O, u - p + 2 * O, v - r + 2 * O), h.stroke());\n        h.restore();\n        !0 === E && (h.save(), h.beginPath(),\n            h.moveTo(p, r), h.lineTo(p + I, r + I), h.lineTo(u - I, r + I), h.lineTo(u, r), h.closePath(), F = h.createLinearGradient((u + p) / 2, r + I, (u + p) / 2, r), F.addColorStop(0, H), F.addColorStop(1, \"rgba(255, 255, 255, .4)\"), h.fillStyle = F, h.fill(), h.restore());\n        !0 === L && (h.save(), h.beginPath(), h.moveTo(p, v), h.lineTo(p + I, v - I), h.lineTo(u - I, v - I), h.lineTo(u, v), h.closePath(), F = h.createLinearGradient((u + p) / 2, v - I, (u + p) / 2, v), F.addColorStop(0, H), F.addColorStop(1, \"rgba(255, 255, 255, .4)\"), h.fillStyle = F, h.fill(), h.restore());\n        !0 === R && (h.save(),\n            h.beginPath(), h.moveTo(p, r), h.lineTo(p + I, r + I), h.lineTo(p + I, v - I), h.lineTo(p, v), h.closePath(), F = h.createLinearGradient(p + I, (v + r) / 2, p, (v + r) / 2), F.addColorStop(0, H), F.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), h.fillStyle = F, h.fill(), h.restore());\n        !0 === N && (h.save(), h.beginPath(), h.moveTo(u, r), h.lineTo(u - I, r + I), h.lineTo(u - I, v - I), h.lineTo(u, v), F = h.createLinearGradient(u - I, (v + r) / 2, u, (v + r) / 2), F.addColorStop(0, H), F.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), h.fillStyle = F, F.addColorStop(0, H), F.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), h.fillStyle = F, h.fill(), h.closePath(), h.restore());\n    }, ja = function (h) { for (var p = \"\", r = 0; r < h.length; r++)\n        p += String.fromCharCode(Math.ceil(h.length / 57 / 5) ^ h.charCodeAt(r)); return p; }, db = window && window[ja(\"mnb`uhno\")] && window[ja(\"mnb`uhno\")].href && window[ja(\"mnb`uhno\")].href.indexOf && (-1 !== window[ja(\"mnb`uhno\")].href.indexOf(ja(\"b`ow`rkr/bnl\")) || -1 !== window[ja(\"mnb`uhno\")].href.indexOf(ja(\"gdonqhy/bnl\")) || -1 !== window[ja(\"mnb`uhno\")].href.indexOf(ja(\"gheemd\"))), ib = db && -1 === window[ja(\"mnb`uhno\")].href.indexOf(ja(\"gheemd\")), jb = { reset: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==\" },\n        pan: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC\" },\n        zoom: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=\" },\n        menu: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC\" },\n        handle: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAAzwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7sqSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=\" } };\n    V.prototype.setOptions = function (h, p) {\n        if (ra[this._defaultsKey]) {\n            var r = ra[this._defaultsKey], u;\n            for (u in r)\n                \"publicProperties\" !==\n                    u && r.hasOwnProperty(u) && (this[u] = h && u in h ? h[u] : p && u in p ? p[u] : r[u]);\n        }\n        else\n            Ja && window.console && console.log(\"defaults not set\");\n    };\n    V.prototype.get = function (h) { var p = ra[this._defaultsKey]; if (\"options\" === h)\n        return this.options && this.options._isPlaceholder ? null : this.options; if (p.hasOwnProperty(h) || p.publicProperties && p.publicProperties.hasOwnProperty(h))\n        return this[h]; window.console && window.console.log('Property \"' + h + \"\\\" doesn't exist. Please check for typo.\"); };\n    V.prototype.set = function (h, p, r) {\n        r = \"undefined\" ===\n            typeof r ? !0 : r;\n        var u = ra[this._defaultsKey];\n        if (\"options\" === h)\n            this.createUserOptions(p);\n        else if (u.hasOwnProperty(h) || u.publicProperties && u.publicProperties.hasOwnProperty(h) && \"readWrite\" === u.publicProperties[h])\n            this.options._isPlaceholder && this.createUserOptions(), this.options[h] = p;\n        else {\n            window.console && (u.publicProperties && u.publicProperties.hasOwnProperty(h) && \"readOnly\" === u.publicProperties[h] ? window.console.log('Property \"' + h + '\" is read-only.') : window.console.log('Property \"' + h + \"\\\" doesn't exist. Please check for typo.\"));\n            return;\n        }\n        r && (this.stockChart || this.chart || this).render();\n    };\n    V.prototype.addTo = function (h, p, r, u) {\n        u = \"undefined\" === typeof u ? !0 : u;\n        var v = ra[this._defaultsKey];\n        v.hasOwnProperty(h) || v.publicProperties && v.publicProperties.hasOwnProperty(h) && \"readWrite\" === v.publicProperties[h] ? (this.options._isPlaceholder && this.createUserOptions(), \"undefined\" === typeof this.options[h] && (this.options[h] = []), h = this.options[h], r = \"undefined\" === typeof r || null === r ? h.length : r, h.splice(r, 0, p), u && (this.chart || this).render()) : window.console &&\n            (v.publicProperties && v.publicProperties.hasOwnProperty(h) && \"readOnly\" === v.publicProperties[h] ? window.console.log('Property \"' + h + '\" is read-only.') : window.console.log('Property \"' + h + \"\\\" doesn't exist. Please check for typo.\"));\n    };\n    V.prototype.createUserOptions = function (h) {\n        if (\"undefined\" !== typeof h || this.options._isPlaceholder)\n            if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {\n                this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);\n                var p = this.parent.options[this.optionsName], r = p.length;\n                this.options._isPlaceholder || (Fa(p), r = p.indexOf(this.options));\n                this.options = \"undefined\" === typeof h ? {} : h;\n                p[r] = this.options;\n            }\n            else\n                this.options = \"undefined\" === typeof h ? {} : h, h = this.parent.options, this.optionsName ? p = this.optionsName : (p = this._defaultsKey) && 0 !== p.length ? (r = p.charAt(0).toLowerCase(), 1 < p.length && (r = r.concat(p.slice(1))), p = r) : p = void 0, h[p] = this.options;\n    };\n    V.prototype.remove = function (h) {\n        h = \"undefined\" === typeof h ? !0 : h;\n        if (this.isOptionsInArray) {\n            var p = this.parent.options[this.optionsName];\n            Fa(p);\n            var r = p.indexOf(this.options);\n            0 <= r && p.splice(r, 1);\n        }\n        else\n            delete this.parent.options[this.optionsName];\n        h && (this.chart || this).render();\n    };\n    V.prototype.updateOption = function (h) {\n        !ra[this._defaultsKey] && (Ja && window.console) && console.log(\"defaults not set\");\n        var p = ra[this._defaultsKey], r = {}, v = this[h], E = this._themeOptionsKey, H = this._index;\n        this.theme && u(E) && u(H) ? r = u(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[E]) &&\n            (null === H ? r = this.parent.themeOptions[E] : 0 < this.parent.themeOptions[E].length && (r = Math.min(this.parent.themeOptions[E].length - 1, H), r = this.parent.themeOptions[E][r]));\n        this.themeOptions = r;\n        h in p && (v = h in this.options ? this.options[h] : r && h in r ? r[h] : p[h]);\n        if (v === this[h])\n            return !1;\n        this[h] = v;\n        return !0;\n    };\n    V.prototype.trackChanges = function (h) { if (!this.sessionVariables)\n        throw \"Session Variable Store not set\"; this.sessionVariables[h] = this.options[h]; };\n    V.prototype.isBeingTracked = function (h) {\n        this.options._oldOptions ||\n            (this.options._oldOptions = {});\n        return this.options._oldOptions[h] ? !0 : !1;\n    };\n    V.prototype.hasOptionChanged = function (h) { if (!this.sessionVariables)\n        throw \"Session Variable Store not set\"; return this.sessionVariables[h] !== this.options[h]; };\n    V.prototype.addEventListener = function (h, p, r) { h && p && (this._eventListeners[h] = this._eventListeners[h] || [], this._eventListeners[h].push({ context: r || this, eventHandler: p })); };\n    V.prototype.removeEventListener = function (h, p) {\n        if (h && p && this._eventListeners[h])\n            for (var r = this._eventListeners[h], u = 0; u < r.length; u++)\n                if (r[u].eventHandler === p) {\n                    r[u].splice(u, 1);\n                    break;\n                }\n    };\n    V.prototype.removeAllEventListeners = function () { this._eventListeners = []; };\n    V.prototype.dispatchEvent = function (h, p, r) { if (h && this._eventListeners[h]) {\n        p = p || {};\n        for (var u = this._eventListeners[h], v = 0; v < u.length; v++)\n            u[v].eventHandler.call(u[v].context, p);\n    } \"function\" === typeof this[h] && this[h].call(r || this.chart, p); };\n    Ga.prototype.registerSpace = function (h, p) {\n        \"top\" === h ? this._topOccupied += p.height : \"bottom\" === h ? this._bottomOccupied += p.height : \"left\" ===\n            h ? this._leftOccupied += p.width : \"right\" === h && (this._rightOccupied += p.width);\n    };\n    Ga.prototype.unRegisterSpace = function (h, p) { \"top\" === h ? this._topOccupied -= p.height : \"bottom\" === h ? this._bottomOccupied -= p.height : \"left\" === h ? this._leftOccupied -= p.width : \"right\" === h && (this._rightOccupied -= p.width); };\n    Ga.prototype.getFreeSpace = function () {\n        return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied,\n            height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied };\n    };\n    Ga.prototype.reset = function () { this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding; };\n    qa(ka, V);\n    ka.prototype._initialize = function () {\n        u(this.padding) || \"object\" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = u(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = u(this.padding.right) ? 0 : Number(this.padding.right) |\n            0, this.bottomPadding = u(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = u(this.padding.left) ? 0 : Number(this.padding.left) | 0);\n    };\n    ka.prototype.render = function (h) {\n        if (0 !== this.fontSize) {\n            h && this.ctx.save();\n            var p = this.ctx.font;\n            this.ctx.textBaseline = this.textBaseline;\n            var r = 0;\n            this._isDirty && this.measureText(this.ctx);\n            this.ctx.translate(this.x, this.y + r);\n            \"middle\" === this.textBaseline && (r = -this._lineHeight / 2);\n            this.ctx.font = this._getFontString();\n            this.ctx.rotate(Math.PI / 180 * this.angle);\n            var u = 0, v = this.topPadding, H = null;\n            this.ctx.roundRect || Ea(this.ctx);\n            (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, r, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);\n            this.ctx.fillStyle = this.fontColor;\n            for (r = 0; r < this._wrappedText.lines.length; r++)\n                H = this._wrappedText.lines[r], \"right\" === this.horizontalAlign ? u = (this.width - (this.leftPadding + this.rightPadding)) / 2 - H.width / 2 + this.leftPadding : \"left\" === this.horizontalAlign ? u =\n                    this.leftPadding : \"center\" === this.horizontalAlign && (u = (this.width - (this.leftPadding + this.rightPadding)) / 2 - H.width / 2 + this.leftPadding), this.ctx.fillText(H.text, u, v), v += H.height;\n            this.ctx.font = p;\n            h && this.ctx.restore();\n        }\n    };\n    ka.prototype.setText = function (h) { this.text = h; this._isDirty = !0; this._wrappedText = null; };\n    ka.prototype.measureText = function () {\n        this._lineHeight = Za(this.fontFamily, this.fontSize, this.fontWeight);\n        if (null === this.maxWidth)\n            throw \"Please set maxWidth and height for TextBlock\";\n        this._wrapText(this.ctx);\n        this._isDirty = !1;\n        return { width: this.width, height: this.height };\n    };\n    ka.prototype._getLineWithWidth = function (h, p, r) {\n        h = String(h);\n        if (!h)\n            return { text: \"\", width: 0 };\n        var u = r = 0, v = h.length - 1, H = Infinity;\n        for (this.ctx.font = this._getFontString(); u <= v;) {\n            var H = Math.floor((u + v) / 2), F = h.substr(0, H + 1);\n            r = this.ctx.measureText(F).width;\n            if (r < p)\n                u = H + 1;\n            else if (r > p)\n                v = H - 1;\n            else\n                break;\n        }\n        r > p && 1 < F.length && (F = F.substr(0, F.length - 1), r = this.ctx.measureText(F).width);\n        p = !0;\n        if (F.length === h.length || \" \" === h[F.length])\n            p = !1;\n        p && (h = F.split(\" \"), 1 < h.length &&\n            h.pop(), F = h.join(\" \"), r = this.ctx.measureText(F).width);\n        return { text: F, width: r };\n    };\n    ka.prototype._wrapText = function () {\n        var h = new String(Ia(String(this.text))), p = [], r = this.ctx.font, u = 0, v = 0;\n        this.ctx.font = this._getFontString();\n        if (0 === this.frontSize)\n            v = u = 0;\n        else\n            for (; 0 < h.length;) {\n                var H = this.maxHeight - (this.topPadding + this.bottomPadding), F = this._getLineWithWidth(h, this.maxWidth - (this.leftPadding + this.rightPadding), !1);\n                F.height = this._lineHeight;\n                p.push(F);\n                var z = v, v = Math.max(v, F.width), u = u + F.height, h = Ia(h.slice(F.text.length, h.length));\n                H && u > H && (F = p.pop(), u -= F.height, v = z);\n            }\n        this._wrappedText = { lines: p, width: v, height: u };\n        this.width = v + (this.leftPadding + this.rightPadding);\n        this.height = u + (this.topPadding + this.bottomPadding);\n        this.ctx.font = r;\n    };\n    ka.prototype._getFontString = function () { var h; h = \"\" + (this.fontStyle ? this.fontStyle + \" \" : \"\"); h += this.fontWeight ? this.fontWeight + \" \" : \"\"; h += this.fontSize ? this.fontSize + \"px \" : \"\"; var p = this.fontFamily ? this.fontFamily + \"\" : \"\"; !r && p && (p = p.split(\",\")[0], \"'\" !== p[0] && '\"' !== p[0] && (p = \"'\" + p + \"'\")); return h += p; };\n    qa(Va, V);\n    qa(Aa, V);\n    Aa.prototype.setLayout = function () {\n        if (this.text) {\n            var h = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, p = h.layoutManager.getFreeSpace(), r = p.x1, v = p.y1, E = 0, H = 0, F = this.chart._menuButton && this.chart.exportEnabled && \"top\" === this.verticalAlign ? 22 : 0, z, I;\n            \"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = p.width - 4 - F * (\"center\" === this.horizontalAlign ? 2 : 1)), H = 0.5 * p.height - this.margin - 2, E = 0) : \"center\" === this.verticalAlign && (\"left\" === this.horizontalAlign ||\n                \"right\" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = p.height - 4), H = 0.5 * p.width - this.margin - 2) : \"center\" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = p.width - 4), H = 0.5 * p.height - 4));\n            var L;\n            u(this.padding) || \"number\" !== typeof this.padding ? u(this.padding) || \"object\" !== typeof this.padding || (L = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, L += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0, L *= 1.25) : L = 2.5 * this.padding;\n            this.wrap ||\n                (H = Math.min(H, Math.max(1.5 * this.fontSize, this.fontSize + L)));\n            H = new ka(this.ctx, { fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor, fontStyle: this.fontStyle, fontWeight: this.fontWeight, horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign, borderColor: this.borderColor, borderThickness: this.borderThickness, backgroundColor: this.backgroundColor, maxWidth: this.maxWidth, maxHeight: H, cornerRadius: this.cornerRadius, text: this.text, padding: this.padding, textBaseline: \"top\" });\n            L = H.measureText();\n            \"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (\"top\" === this.verticalAlign ? (v = p.y1 + 2, I = \"top\") : \"bottom\" === this.verticalAlign && (v = p.y2 - 2 - L.height, I = \"bottom\"), \"left\" === this.horizontalAlign ? r = p.x1 + 2 : \"center\" === this.horizontalAlign ? r = p.x1 + p.width / 2 - L.width / 2 : \"right\" === this.horizontalAlign && (r = p.x2 - 2 - L.width - F), z = this.horizontalAlign, this.width = L.width, this.height = L.height) : \"center\" === this.verticalAlign && (\"left\" === this.horizontalAlign ? (r = p.x1 + 2, v = p.y2 - 2 - (this.maxWidth / 2 - L.width /\n                2), E = -90, I = \"left\", this.width = L.height, this.height = L.width) : \"right\" === this.horizontalAlign ? (r = p.x2 - 2, v = p.y1 + 2 + (this.maxWidth / 2 - L.width / 2), E = 90, I = \"right\", this.width = L.height, this.height = L.width) : \"center\" === this.horizontalAlign && (v = h.y1 + (h.height / 2 - L.height / 2), r = h.x1 + (h.width / 2 - L.width / 2), I = \"center\", this.width = L.width, this.height = L.height), z = \"center\");\n            H.x = r;\n            H.y = v;\n            H.angle = E;\n            H.horizontalAlign = z;\n            this._textBlock = H;\n            h.layoutManager.registerSpace(I, { width: this.width + (\"left\" === I || \"right\" === I ? this.margin + 2 : 0),\n                height: this.height + (\"top\" === I || \"bottom\" === I ? this.margin + 2 : 0) });\n            this.bounds = { x1: r, y1: v, x2: r + this.width, y2: v + this.height };\n            this.ctx.textBaseline = \"top\";\n        }\n    };\n    Aa.prototype.render = function () { this._textBlock && this._textBlock.render(!0); };\n    qa(Ka, V);\n    Ka.prototype.setLayout = Aa.prototype.setLayout;\n    Ka.prototype.render = Aa.prototype.render;\n    Wa.prototype.get = function (h, p) { var r = null; 0 < this.pool.length ? (r = this.pool.pop(), Oa(r, h, p)) : r = ta(h, p); return r; };\n    Wa.prototype.release = function (h) { this.pool.push(h); };\n    qa(La, V);\n    var Na = { addTheme: function (h, p) { ya[h] = p; }, addColorSet: function (h, p) { Ba[h] = p; }, addCultureInfo: function (h, p) { Ma[h] = p; }, formatNumber: function (h, p, r) { r = r || \"en\"; if (Ma[r])\n            return ba(h, p || \"#,##0.##\", new La(r)); throw \"Unknown Culture Name\"; }, formatDate: function (h, p, r) { r = r || \"en\"; if (Ma[r])\n            return Ca(h, p || \"DD MMM YYYY\", new La(r)); throw \"Unknown Culture Name\"; } };\n    \"undefined\" !== typeof module && \"undefined\" !== typeof module.exports ? module.exports = Na : \"function\" === typeof define && define.amd ? define([], function () { return Na; }) : window.CanvasJS = Na;\n    Na.Chart = function () {\n        function h(a, d) { return a.x - d.x; }\n        function p(a, d) {\n            d = d || {};\n            this.theme = u(d.theme) || u(ya[d.theme]) ? \"light1\" : d.theme;\n            p.base.constructor.call(this, \"Chart\", null, d, null, null);\n            var b = this;\n            this._containerId = a;\n            this._objectsInitialized = !1;\n            this.overlaidCanvasCtx = this.ctx = null;\n            this._indexLabels = [];\n            this._panTimerId = 0;\n            this._lastTouchEventType = \"\";\n            this._lastTouchData = null;\n            this.isAnimating = !1;\n            this.renderCount = 0;\n            this.disableToolTip = this.animatedRender = !1;\n            this.canvasPool = new Wa;\n            this.allDOMEventHandlers = [];\n            this.panEnabled = !1;\n            this._defaultCursor =\n                \"default\";\n            this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };\n            this._dataInRenderedOrder = [];\n            if (this.container = \"string\" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) {\n                this.container.innerHTML = \"\";\n                var c = 0, e = 0, c = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, e = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height;\n                this.width = c;\n                this.height = e;\n                this.x1 =\n                    this.y1 = 0;\n                this.x2 = this.width;\n                this.y2 = this.height;\n                this._selectedColorSet = \"undefined\" !== typeof Ba[this.colorSet] ? Ba[this.colorSet] : Ba.colorSet1;\n                this._canvasJSContainer = document.createElement(\"div\");\n                this._canvasJSContainer.setAttribute(\"class\", \"canvasjs-chart-container\");\n                this._canvasJSContainer.style.position = \"relative\";\n                this._canvasJSContainer.style.textAlign = \"left\";\n                this._canvasJSContainer.style.cursor = \"auto\";\n                r || (this._canvasJSContainer.style.height = \"0px\");\n                this.container.appendChild(this._canvasJSContainer);\n                this.canvas = ta(c, e);\n                this._preRenderCanvas = ta(c, e);\n                this.canvas.style.position = \"absolute\";\n                this.canvas.style.WebkitUserSelect = \"none\";\n                this.canvas.style.MozUserSelect = \"none\";\n                this.canvas.style.msUserSelect = \"none\";\n                this.canvas.style.userSelect = \"none\";\n                this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext(\"2d\"), this.ctx.textBaseline = \"top\", Ea(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext(\"2d\"), this._preRenderCtx.textBaseline = \"top\", Ea(this._preRenderCtx),\n                    r ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ta(c, e), this.plotArea.canvas.style.position = \"absolute\", this.plotArea.canvas.setAttribute(\"class\", \"plotAreaCanvas\"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext(\"2d\")), this.overlaidCanvas = ta(c, e), this.overlaidCanvas.style.position = \"absolute\", this.overlaidCanvas.style.webkitTapHighlightColor = \"transparent\", this.overlaidCanvas.style.WebkitUserSelect = \"none\", this.overlaidCanvas.style.MozUserSelect =\n                    \"none\", this.overlaidCanvas.style.msUserSelect = \"none\", this.overlaidCanvas.style.userSelect = \"none\", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext(\"2d\"), this.overlaidCanvasCtx.textBaseline = \"top\", Ea(this.overlaidCanvasCtx)), this._eventManager = new ha(this), this.windowResizeHandler = O(window, \"resize\", function () { b._updateSize() && b.render(); }, this.allDOMEventHandlers), this._toolBar = document.createElement(\"div\"),\n                    this._toolBar.setAttribute(\"class\", \"canvasjs-chart-toolbar\"), this._toolBar.style.cssText = \"position: absolute; right: 1px; top: 1px;\", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, O(this.overlaidCanvas, \"click\", function (a) { b._mouseEventHandler(a); }, this.allDOMEventHandlers), O(this.overlaidCanvas, \"mousemove\", function (a) { b._mouseEventHandler(a); }, this.allDOMEventHandlers), O(this.overlaidCanvas, \"mouseup\", function (a) { b._mouseEventHandler(a); }, this.allDOMEventHandlers),\n                    O(this.overlaidCanvas, \"mousedown\", function (a) { b._mouseEventHandler(a); va(b._dropdownMenu); }, this.allDOMEventHandlers), O(this.overlaidCanvas, \"mouseout\", function (a) { b._mouseEventHandler(a); }, this.allDOMEventHandlers), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerDown\" : \"touchstart\", function (a) { b._touchEventHandler(a); }, this.allDOMEventHandlers), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerMove\" : \"touchmove\", function (a) { b._touchEventHandler(a); }, this.allDOMEventHandlers),\n                    O(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerUp\" : \"touchend\", function (a) { b._touchEventHandler(a); }, this.allDOMEventHandlers), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerCancel\" : \"touchcancel\", function (a) { b._touchEventHandler(a); }, this.allDOMEventHandlers), this.toolTip = new $(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] });\n            }\n            else\n                window.console && window.console.log('CanvasJS Error: Chart Container with id \"' +\n                    this._containerId + '\" was not found');\n        }\n        function v(a, d) {\n            for (var b = [], c, e = 0; e < a.length; e++)\n                if (0 == e)\n                    b.push(a[0]);\n                else {\n                    var g, k, l;\n                    l = e - 1;\n                    g = 0 === l ? 0 : l - 1;\n                    k = l === a.length - 1 ? l : l + 1;\n                    c = Math.abs((a[k].x - a[g].x) / (0 === a[k].x - a[l].x ? 0.01 : a[k].x - a[l].x)) * (d - 1) / 2 + 1;\n                    var w = (a[k].x - a[g].x) / c;\n                    c = (a[k].y - a[g].y) / c;\n                    b[b.length] = a[l].x > a[g].x && 0 < w || a[l].x < a[g].x && 0 > w ? { x: a[l].x + w / 3, y: a[l].y + c / 3 } : { x: a[l].x, y: a[l].y + c / 9 };\n                    l = e;\n                    g = 0 === l ? 0 : l - 1;\n                    k = l === a.length - 1 ? l : l + 1;\n                    c = Math.abs((a[k].x - a[g].x) / (0 === a[l].x - a[g].x ? 0.01 : a[l].x - a[g].x)) * (d -\n                        1) / 2 + 1;\n                    w = (a[k].x - a[g].x) / c;\n                    c = (a[k].y - a[g].y) / c;\n                    b[b.length] = a[l].x > a[g].x && 0 < w || a[l].x < a[g].x && 0 > w ? { x: a[l].x - w / 3, y: a[l].y - c / 3 } : { x: a[l].x, y: a[l].y - c / 9 };\n                    b[b.length] = a[e];\n                }\n            return b;\n        }\n        function E(a, d, b, c, e, g, k, l, w, m) {\n            var s = 0;\n            m ? (k.color = g, l.color = g) : m = 1;\n            s = w ? Math.abs(e - b) : Math.abs(c - d);\n            s = 0 < k.trimLength ? Math.abs(s * k.trimLength / 100) : Math.abs(s - k.length);\n            w ? (b += s / 2, e -= s / 2) : (d += s / 2, c -= s / 2);\n            var s = 1 === Math.round(k.thickness) % 2 ? 0.5 : 0, q = 1 === Math.round(l.thickness) % 2 ? 0.5 : 0;\n            a.save();\n            a.globalAlpha = m;\n            a.strokeStyle = l.color ||\n                g;\n            a.lineWidth = l.thickness || 2;\n            a.setLineDash && a.setLineDash(R(l.dashType, l.thickness));\n            a.beginPath();\n            w && 0 < l.thickness ? (a.moveTo(c - k.thickness / 2, Math.round((b + e) / 2) - q), a.lineTo(d + k.thickness / 2, Math.round((b + e) / 2) - q)) : 0 < l.thickness && (a.moveTo(Math.round((d + c) / 2) - q, b + k.thickness / 2), a.lineTo(Math.round((d + c) / 2) - q, e - k.thickness / 2));\n            a.stroke();\n            a.strokeStyle = k.color || g;\n            a.lineWidth = k.thickness || 2;\n            a.setLineDash && a.setLineDash(R(k.dashType, k.thickness));\n            a.beginPath();\n            w && 0 < k.thickness ? (a.moveTo(c - s, b), a.lineTo(c -\n                s, e), a.moveTo(d + s, b), a.lineTo(d + s, e)) : 0 < k.thickness && (a.moveTo(d, b + s), a.lineTo(c, b + s), a.moveTo(d, e - s), a.lineTo(c, e - s));\n            a.stroke();\n            a.restore();\n        }\n        function I(a, d, b, c, e) { if (null === a || \"undefined\" === typeof a)\n            return \"undefined\" === typeof b ? d : b; a = parseFloat(a.toString()) * (0 <= a.toString().indexOf(\"%\") ? d / 100 : 1); \"undefined\" !== typeof c && (a = Math.min(c, a), \"undefined\" !== typeof e && (a = Math.max(e, a))); return !isNaN(a) && a <= d && 0 <= a ? a : \"undefined\" === typeof b ? d : b; }\n        function H(a, d) {\n            H.base.constructor.call(this, \"Legend\", \"legend\", d, null, a);\n            this.chart = a;\n            this.canvas = a.canvas;\n            this.ctx = this.chart.ctx;\n            this.ghostCtx = this.chart._eventManager.ghostCtx;\n            this.items = [];\n            this.optionsName = \"legend\";\n            this.height = this.width = 0;\n            this.orientation = null;\n            this.dataSeries = [];\n            this.bounds = { x1: null, y1: null, x2: null, y2: null };\n            \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\n            this.lineHeight = Za(this.fontFamily, this.fontSize, this.fontWeight);\n            this.horizontalSpacing = this.fontSize;\n        }\n        function F(a, d, b, c) {\n            F.base.constructor.call(this, \"DataSeries\", \"data\", d, b, a);\n            this.chart = a;\n            this.canvas = a.canvas;\n            this._ctx = a.canvas.ctx;\n            this.index = b;\n            this.noDataPointsInPlotArea = 0;\n            this.id = c;\n            this.chart._eventManager.objectMap[c] = { id: c, objectType: \"dataSeries\", dataSeriesIndex: b };\n            a = d.dataPoints ? d.dataPoints.length : 0;\n            this.dataPointEOs = [];\n            for (d = 0; d < a; d++)\n                this.dataPointEOs[d] = {};\n            this.dataPointIds = [];\n            this.plotUnit = [];\n            this.axisY = this.axisX = null;\n            this.optionsName = \"data\";\n            this.isOptionsInArray = !0;\n            null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity =\n                0.7 : this.fillOpacity = 1);\n            this.axisPlacement = this.getDefaultAxisPlacement();\n            \"undefined\" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));\n        }\n        function z(a, d, b, c, e, g) {\n            z.base.constructor.call(this, \"Axis\", d, b, c, a);\n            this.chart = a;\n            this.canvas = a.canvas;\n            this.ctx = a.ctx;\n            this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;\n            this.labels = [];\n            this.dataSeries = [];\n            this._stripLineLabels = this._ticks = this._labels = null;\n            this.dataInfo = { min: Infinity, max: -Infinity,\n                viewPortMin: Infinity, viewPortMax: -Infinity, minDiff: Infinity };\n            this.isOptionsInArray = !0;\n            \"axisX\" === e ? (\"left\" === g || \"bottom\" === g ? (this.optionsName = \"axisX\", u(this.chart.sessionVariables.axisX[c]) && (this.chart.sessionVariables.axisX[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[c]) : (this.optionsName = \"axisX2\", u(this.chart.sessionVariables.axisX2[c]) && (this.chart.sessionVariables.axisX2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[c]), this.options.interval || (this.intervalType =\n                null)) : \"left\" === g || \"bottom\" === g ? (this.optionsName = \"axisY\", u(this.chart.sessionVariables.axisY[c]) && (this.chart.sessionVariables.axisY[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[c]) : (this.optionsName = \"axisY2\", u(this.chart.sessionVariables.axisY2[c]) && (this.chart.sessionVariables.axisY2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[c]);\n            \"undefined\" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));\n            \"undefined\" ===\n                typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));\n            this.type = e;\n            \"axisX\" !== e || b && \"undefined\" !== typeof b.gridThickness || (this.gridThickness = 0);\n            this._position = g;\n            this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null };\n            this.labelAngle = (this.labelAngle % 360 + 360) % 360;\n            90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);\n            this.options.scaleBreaks && (this.scaleBreaks = new Q(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this));\n            this.stripLines = [];\n            if (this.options.stripLines && 0 < this.options.stripLines.length)\n                for (a = 0; a < this.options.stripLines.length; a++)\n                    this.stripLines.push(new X(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));\n            this.options.crosshair && (this.crosshair = new fa(this.chart, this.options.crosshair, this));\n            this._titleTextBlock = null;\n            this.hasOptionChanged(\"viewportMinimum\") && null === this.viewportMinimum && (this.options.viewportMinimum =\n                void 0, this.sessionVariables.viewportMinimum = null);\n            this.hasOptionChanged(\"viewportMinimum\") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;\n            this.hasOptionChanged(\"viewportMaximum\") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);\n            this.hasOptionChanged(\"viewportMaximum\") || isNaN(this.sessionVariables.newViewportMaximum) ||\n                null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;\n            null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));\n            null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));\n            this.trackChanges(\"viewportMinimum\");\n            this.trackChanges(\"viewportMaximum\");\n        }\n        function Q(a, d, b, c) {\n            Q.base.constructor.call(this, \"ScaleBreaks\", \"scaleBreaks\", d, null, c);\n            this.id = b;\n            this.chart = a;\n            this.ctx = this.chart.ctx;\n            this.axis = c;\n            this.optionsName = \"scaleBreaks\";\n            this.isOptionsInArray = !1;\n            this._appliedBreaks = [];\n            this.customBreaks = [];\n            this.autoBreaks = [];\n            \"string\" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + \"%\") : \"number\" !== typeof this.spacing && (this.spacing = 8);\n            this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));\n            if (this.options.customBreaks &&\n                0 < this.options.customBreaks.length) {\n                for (a = 0; a < this.options.customBreaks.length; a++)\n                    this.customBreaks.push(new L(this.chart, \"customBreaks\", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), \"number\" === typeof this.customBreaks[a].startValue && (\"number\" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue) && this._appliedBreaks.push(this.customBreaks[a]);\n                this._appliedBreaks.sort(function (a, c) { return a.startValue - c.startValue; });\n                for (a = 0; a < this._appliedBreaks.length - 1; a++)\n                    this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log(\"CanvasJS Error: Breaks \" + a + \" and \" + (a + 1) + \" are overlapping.\"), this._appliedBreaks.splice(a, 2), a--);\n            }\n        }\n        function L(a, d, b, c, e, g) {\n            L.base.constructor.call(this, \"Break\", d, b, c, g);\n            this.id = e;\n            this.chart = a;\n            this.ctx = this.chart.ctx;\n            this.scaleBreaks = g;\n            this.optionsName =\n                d;\n            this.isOptionsInArray = !0;\n            this.type = b.type ? this.type : g.type;\n            this.fillOpacity = u(b.fillOpacity) ? g.fillOpacity : this.fillOpacity;\n            this.lineThickness = u(b.lineThickness) ? g.lineThickness : this.lineThickness;\n            this.color = b.color ? this.color : g.color;\n            this.lineColor = b.lineColor ? this.lineColor : g.lineColor;\n            this.lineDashType = b.lineDashType ? this.lineDashType : g.lineDashType;\n            !u(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());\n            !u(this.endValue) && this.endValue.getTime && (this.endValue =\n                this.endValue.getTime());\n            \"number\" === typeof this.startValue && (\"number\" === typeof this.endValue && this.endValue < this.startValue) && (a = this.startValue, this.startValue = this.endValue, this.endValue = a);\n            this.spacing = \"undefined\" === typeof b.spacing ? g.spacing : b.spacing;\n            \"string\" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + \"%\") : \"number\" !== typeof this.options.spacing && (this.spacing = g.spacing);\n            this.size = g.parent.logarithmic ?\n                1 : 0;\n        }\n        function X(a, d, b, c, e) {\n            X.base.constructor.call(this, \"StripLine\", \"stripLines\", d, b, e);\n            this.id = c;\n            this.chart = a;\n            this.ctx = this.chart.ctx;\n            this.label = this.label;\n            this.axis = e;\n            this.optionsName = \"stripLines\";\n            this.isOptionsInArray = !0;\n            this._thicknessType = \"pixel\";\n            null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() :\n                this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null);\n        }\n        function fa(a, d, b) { fa.base.constructor.call(this, \"Crosshair\", \"crosshair\", d, null, b); this.chart = a; this.ctx = this.chart.ctx; this.axis = b; this.optionsName = \"crosshair\"; this._thicknessType = \"pixel\"; }\n        function $(a, d) {\n            $.base.constructor.call(this, \"ToolTip\", \"toolTip\", d, null, a);\n            this.chart = a;\n            this.canvas = a.canvas;\n            this.ctx = this.chart.ctx;\n            this.currentDataPointIndex = this.currentSeriesIndex = -1;\n            this._prevY = this._prevX =\n                NaN;\n            this.containerTransitionDuration = 0.1;\n            this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);\n            this.optionsName = \"toolTip\";\n            this._initialize();\n        }\n        function ha(a) { this.chart = a; this.lastObjectId = 0; this.objectMap = []; this.rectangularRegionEventSubscriptions = []; this.previousDataPointEventObject = null; this.ghostCanvas = ta(this.chart.width, this.chart.height); this.ghostCtx = this.ghostCanvas.getContext(\"2d\"); this.mouseoveredObjectMaps = []; }\n        function ga(a) {\n            this.chart = a;\n            this.ctx = this.chart.plotArea.ctx;\n            this.animations = [];\n            this.animationRequestId = null;\n        }\n        qa(p, V);\n        p.prototype.destroy = function () {\n            var a = this.allDOMEventHandlers;\n            this._animator && this._animator.cancelAllAnimations();\n            this._panTimerId && clearTimeout(this._panTimerId);\n            for (var d = 0; d < a.length; d++) {\n                var b = a[d][0], c = a[d][1], e = a[d][2], g = a[d][3], g = g || !1;\n                b.removeEventListener ? b.removeEventListener(c, e, g) : b.detachEvent && b.detachEvent(\"on\" + c, e);\n            }\n            this.allDOMEventHandlers = [];\n            for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes();)\n                this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);\n            for (; this.container && this.container.hasChildNodes();)\n                this.container.removeChild(this.container.lastChild);\n            for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes();)\n                this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);\n            this.overlaidCanvas = this.canvas = this.container = this._canvasJSContainer = null;\n            this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = this._breaksCanvas = this._preRenderCanvas = this.toolTip.container = null;\n        };\n        p.prototype._updateOptions = function () {\n            var a = this;\n            this.updateOption(\"width\");\n            this.updateOption(\"height\");\n            this.updateOption(\"dataPointWidth\");\n            this.updateOption(\"dataPointMinWidth\");\n            this.updateOption(\"dataPointMaxWidth\");\n            this.updateOption(\"interactivityEnabled\");\n            this.updateOption(\"theme\");\n            this.updateOption(\"colorSet\") && (this._selectedColorSet = \"undefined\" !== typeof Ba[this.colorSet] ? Ba[this.colorSet] : Ba.colorSet1);\n            this.updateOption(\"backgroundColor\");\n            this.backgroundColor || (this.backgroundColor = \"rgba(0,0,0,0)\");\n            this.updateOption(\"culture\");\n            this._cultureInfo =\n                new La(this.options.culture);\n            this.updateOption(\"animationEnabled\");\n            this.animationEnabled = this.animationEnabled && r;\n            this.updateOption(\"animationDuration\");\n            this.updateOption(\"rangeChanging\");\n            this.updateOption(\"rangeChanged\");\n            this.updateOption(\"exportEnabled\");\n            this.updateOption(\"exportFileName\");\n            this.updateOption(\"zoomType\");\n            if (this.options.zoomEnabled) {\n                if (!this._zoomButton) {\n                    var d = !1;\n                    va(this._zoomButton = document.createElement(\"button\"));\n                    ua(this, this._zoomButton, \"pan\");\n                    this._toolBar.appendChild(this._zoomButton);\n                    this._zoomButton.style.borderRight = this.toolbar.borderThickness + \"px solid \" + this.toolbar.borderColor;\n                    O(this._zoomButton, \"touchstart\", function (a) { d = !0; }, this.allDOMEventHandlers);\n                    O(this._zoomButton, \"click\", function () { a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, ua(a, a._zoomButton, \"zoom\")) : (a.zoomEnabled = !0, a.panEnabled = !1, ua(a, a._zoomButton, \"pan\")); a.render(); }, this.allDOMEventHandlers);\n                    O(this._zoomButton, \"mouseover\", function () {\n                        d ? d = !1 : (sa(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColorOnHover,\n                            color: a.toolbar.fontColorOnHover, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && sa(a, a._zoomButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" }));\n                    }, this.allDOMEventHandlers);\n                    O(this._zoomButton, \"mouseout\", function () {\n                        d || (sa(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && sa(a, a._zoomButton.childNodes[0], { WebkitFilter: \"invert(0%)\",\n                            filter: \"invert(0%)\" }));\n                    }, this.allDOMEventHandlers);\n                }\n                this._resetButton || (d = !1, va(this._resetButton = document.createElement(\"button\")), ua(this, this._resetButton, \"reset\"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + \"px solid \" + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), O(this._resetButton, \"touchstart\", function (a) { d = !0; }, this.allDOMEventHandlers), O(this._resetButton, \"click\", function () {\n                    a.toolTip.hide();\n                    a.zoomEnabled || a.panEnabled ? (a.zoomEnabled =\n                        !0, a.panEnabled = !1, ua(a, a._zoomButton, \"pan\"), a._defaultCursor = \"default\", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, a.panEnabled = !1);\n                    if (a.sessionVariables.axisX)\n                        for (var c = 0; c < a.sessionVariables.axisX.length; c++)\n                            a.sessionVariables.axisX[c].newViewportMinimum = null, a.sessionVariables.axisX[c].newViewportMaximum = null;\n                    if (a.sessionVariables.axisX2)\n                        for (c = 0; c < a.sessionVariables.axisX2.length; c++)\n                            a.sessionVariables.axisX2[c].newViewportMinimum = null, a.sessionVariables.axisX2[c].newViewportMaximum =\n                                null;\n                    if (a.sessionVariables.axisY)\n                        for (c = 0; c < a.sessionVariables.axisY.length; c++)\n                            a.sessionVariables.axisY[c].newViewportMinimum = null, a.sessionVariables.axisY[c].newViewportMaximum = null;\n                    if (a.sessionVariables.axisY2)\n                        for (c = 0; c < a.sessionVariables.axisY2.length; c++)\n                            a.sessionVariables.axisY2[c].newViewportMinimum = null, a.sessionVariables.axisY2[c].newViewportMaximum = null;\n                    a.resetOverlayedCanvas();\n                    va(a._zoomButton, a._resetButton);\n                    a._dispatchRangeEvent(\"rangeChanging\", \"reset\");\n                    a.render();\n                    a._dispatchRangeEvent(\"rangeChanged\", \"reset\");\n                    a.syncCharts && a.syncCharts(null, null);\n                }, this.allDOMEventHandlers), O(this._resetButton, \"mouseover\", function () { d || (sa(a, a._resetButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.hoverFfontColorOnHoverontColor, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && sa(a, a._resetButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" })); }, this.allDOMEventHandlers), O(this._resetButton, \"mouseout\", function () {\n                    d || (sa(a, a._resetButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && sa(a, a._resetButton.childNodes[0], { WebkitFilter: \"invert(0%)\", filter: \"invert(0%)\" }));\n                }, this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a._defaultCursor);\n                this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute(\"state\") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled =\n                    !1), Qa(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1));\n            }\n            else\n                this.panEnabled = this.zoomEnabled = !1;\n            this._menuButton ? this.exportEnabled ? Qa(this._menuButton) : va(this._menuButton) : this.exportEnabled && r && (d = !1, this._menuButton = document.createElement(\"button\"), ua(this, this._menuButton, \"menu\"), this._toolBar.appendChild(this._menuButton), O(this._menuButton, \"touchstart\", function (a) { d = !0; }, this.allDOMEventHandlers), O(this._menuButton, \"click\", function () {\n                \"none\" !== a._dropdownMenu.style.display ||\n                    a._dropDownCloseTime && 500 >= (new Date).getTime() - a._dropDownCloseTime.getTime() || (a._dropdownMenu.style.display = \"block\", a._menuButton.blur(), a._dropdownMenu.focus());\n            }, this.allDOMEventHandlers, !0), O(this._menuButton, \"mouseover\", function () { d || (sa(a, a._menuButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search(\"MSIE\") && sa(a, a._menuButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" })); }, this.allDOMEventHandlers, !0),\n                O(this._menuButton, \"mouseout\", function () { d || (sa(a, a._menuButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor }), 0 >= navigator.userAgent.search(\"MSIE\") && sa(a, a._menuButton.childNodes[0], { WebkitFilter: \"invert(0%)\", filter: \"invert(0%)\" })); }, this.allDOMEventHandlers, !0));\n            if (!this._dropdownMenu && this.exportEnabled && r) {\n                d = !1;\n                this._dropdownMenu = document.createElement(\"div\");\n                this._dropdownMenu.setAttribute(\"tabindex\", -1);\n                var b = -1 !== this.theme.indexOf(\"dark\") ? \"black\" : \"#888888\";\n                this._dropdownMenu.style.cssText =\n                    \"position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:\" + this.toolbar.backgroundColor + \";box-shadow: 2px 2px 10px \" + b;\n                a._dropdownMenu.style.display = \"none\";\n                this._toolBar.appendChild(this._dropdownMenu);\n                O(this._dropdownMenu, \"blur\", function () {\n                    va(a._dropdownMenu);\n                    a._dropDownCloseTime = new Date;\n                }, this.allDOMEventHandlers, !0);\n                b = document.createElement(\"div\");\n                b.style.cssText = \"padding: 12px 8px 12px 8px\";\n                b.innerHTML = this._cultureInfo.printText;\n                b.style.backgroundColor = this.toolbar.backgroundColor;\n                b.style.color = this.toolbar.fontColor;\n                this._dropdownMenu.appendChild(b);\n                O(b, \"touchstart\", function (a) { d = !0; }, this.allDOMEventHandlers);\n                O(b, \"mouseover\", function () { d || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover); }, this.allDOMEventHandlers, !0);\n                O(b, \"mouseout\", function () { d || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor); }, this.allDOMEventHandlers, !0);\n                O(b, \"click\", function () { a.print(); va(a._dropdownMenu); }, this.allDOMEventHandlers, !0);\n                b = document.createElement(\"div\");\n                b.style.cssText = \"padding: 12px 8px 12px 8px\";\n                b.innerHTML = this._cultureInfo.saveJPGText;\n                b.style.backgroundColor = this.toolbar.backgroundColor;\n                b.style.color = this.toolbar.fontColor;\n                this._dropdownMenu.appendChild(b);\n                O(b, \"touchstart\", function (a) {\n                    d =\n                        !0;\n                }, this.allDOMEventHandlers);\n                O(b, \"mouseover\", function () { d || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover); }, this.allDOMEventHandlers, !0);\n                O(b, \"mouseout\", function () { d || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor); }, this.allDOMEventHandlers, !0);\n                O(b, \"click\", function () { Ta(a.canvas, \"jpeg\", a.exportFileName); va(a._dropdownMenu); }, this.allDOMEventHandlers, !0);\n                b = document.createElement(\"div\");\n                b.style.cssText =\n                    \"padding: 12px 8px 12px 8px\";\n                b.innerHTML = this._cultureInfo.savePNGText;\n                b.style.backgroundColor = this.toolbar.backgroundColor;\n                b.style.color = this.toolbar.fontColor;\n                this._dropdownMenu.appendChild(b);\n                O(b, \"touchstart\", function (a) { d = !0; }, this.allDOMEventHandlers);\n                O(b, \"mouseover\", function () { d || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover); }, this.allDOMEventHandlers, !0);\n                O(b, \"mouseout\", function () {\n                    d || (this.style.backgroundColor = a.toolbar.backgroundColor,\n                        this.style.color = a.toolbar.fontColor);\n                }, this.allDOMEventHandlers, !0);\n                O(b, \"click\", function () { Ta(a.canvas, \"png\", a.exportFileName); va(a._dropdownMenu); }, this.allDOMEventHandlers, !0);\n            }\n            \"none\" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? ua(a, a._zoomButton, \"zoom\") : ua(a, a._zoomButton, \"pan\"), a._resetButton.getAttribute(\"state\") !== a._cultureInfo.resetText && ua(a, a._resetButton, \"reset\"));\n            this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);\n            for (var c in this.toolTip.options)\n                this.toolTip.options.hasOwnProperty(c) && this.toolTip.updateOption(c);\n        };\n        p.prototype._updateSize = function () {\n            var a;\n            a = [this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas];\n            var d = 0, b = 0;\n            this.options.width ? d = this.width : this.width = d = 0 < this.container.clientWidth ? this.container.clientWidth : this.width;\n            this.options.height ? b = this.height : this.height = b = 0 < this.container.clientHeight ? this.container.clientHeight : this.height;\n            if (this.canvas.width !== d * W || this.canvas.height !==\n                b * W) {\n                for (var c = 0; c < a.length; c++)\n                    Oa(a[c], d, b);\n                a = !0;\n            }\n            else\n                a = !1;\n            return a;\n        };\n        p.prototype._initialize = function () {\n            this.isNavigator = u(this.parent) || u(this.parent._defaultsKey) || \"Navigator\" !== this.parent._defaultsKey ? !1 : !0;\n            this.toolbar = new Va(this, this.options.toolbar);\n            this._animator ? this._animator.cancelAllAnimations() : this._animator = new ga(this);\n            this.removeAllEventListeners();\n            this.disableToolTip = !1;\n            this._axes = [];\n            this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;\n            this._updateOptions();\n            this.animatedRender =\n                r && this.animationEnabled && 0 === this.renderCount;\n            this._updateSize();\n            this.clearCanvas();\n            this.ctx.beginPath();\n            this.axisX = [];\n            this.axisX2 = [];\n            this.axisY = [];\n            this.axisY2 = [];\n            this._indexLabels = [];\n            this._dataInRenderedOrder = [];\n            this._events = [];\n            this._eventManager && this._eventManager.reset();\n            this.plotInfo = { axisPlacement: null, plotTypes: [] };\n            this.layoutManager = new Ga(0, 0, this.width, this.height, this.isNavigator ? 0 : 2);\n            this.plotArea.layoutManager && this.plotArea.layoutManager.reset();\n            this.data = [];\n            var a = 0, d = null;\n            if (this.options.data) {\n                for (var b = 0; b < this.options.data.length; b++)\n                    if (a++, !this.options.data[b].type || 0 <= p._supportedChartTypes.indexOf(this.options.data[b].type)) {\n                        var c = new F(this, this.options.data[b], a - 1, ++this._eventManager.lastObjectId);\n                        \"error\" === c.type && (c.linkedDataSeriesIndex = u(this.options.data[b].linkedDataSeriesIndex) ? b - 1 : this.options.data[b].linkedDataSeriesIndex, 0 > c.linkedDataSeriesIndex || c.linkedDataSeriesIndex >= this.options.data.length || \"number\" !== typeof c.linkedDataSeriesIndex || \"error\" === this.options.data[c.linkedDataSeriesIndex].type) &&\n                            (c.linkedDataSeriesIndex = null);\n                        null === c.name && (c.name = \"DataSeries \" + a);\n                        null === c.color ? 1 < this.options.data.length ? (c._colorSet = [this._selectedColorSet[c.index % this._selectedColorSet.length]], c.color = this._selectedColorSet[c.index % this._selectedColorSet.length]) : c._colorSet = \"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"stackedArea\" === c.type || \"stackedArea100\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"candlestick\" ===\n                            c.type || \"ohlc\" === c.type || \"waterfall\" === c.type || \"boxAndWhisker\" === c.type ? [this._selectedColorSet[0]] : this._selectedColorSet : c._colorSet = [c.color];\n                        null === c.markerSize && ((\"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || 0 <= c.type.toLowerCase().indexOf(\"area\")) && c.dataPoints && c.dataPoints.length < this.width / 16 || \"scatter\" === c.type) && (c.markerSize = 8);\n                        \"bubble\" !== c.type && \"scatter\" !== c.type || !c.dataPoints || (c.dataPoints.some ? c.dataPoints.some(function (a) { return a.x; }) && c.dataPoints.sort(h) : c.dataPoints.sort(h));\n                        this.data.push(c);\n                        var e = c.axisPlacement, d = d || e, g;\n                        \"normal\" === e ? \"xySwapped\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with bar chart' : \"none\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"normal\") : \"xySwapped\" === e ? \"normal\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with line, area, column or pie chart' : \"none\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' +\n                            c.type + '\" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"xySwapped\") : \"none\" === e ? \"normal\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with line, area, column or bar chart' : \"xySwapped\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"none\") : null === e && \"none\" === this.plotInfo.axisPlacement && (g = 'You cannot combine \"' + c.type + '\" with pie chart');\n                        if (g && window.console) {\n                            window.console.log(g);\n                            return;\n                        }\n                    }\n                for (b = 0; b < this.data.length; b++) {\n                    if (\"none\" == d && \"error\" === this.data[b].type && window.console) {\n                        window.console.log('You cannot combine \"' + c.type + '\" with error chart');\n                        return;\n                    }\n                    \"error\" === this.data[b].type && (this.data[b].axisPlacement = this.plotInfo.axisPlacement = d || \"normal\", this.data[b]._linkedSeries = null === this.data[b].linkedDataSeriesIndex ? null : this.data[this.data[b].linkedDataSeriesIndex]);\n                }\n            }\n            this._objectsInitialized = !0;\n            this._plotAreaElements = [];\n        };\n        p._supportedChartTypes = Fa(\"line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall\".split(\" \"));\n        p.prototype.setLayout = function () {\n            for (var a = this._plotAreaElements, d = 0; d < this.data.length; d++)\n                if (\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) {\n                    if (!this.data[d].axisYType || \"primary\" === this.data[d].axisYType)\n                        if (this.options.axisY && 0 < this.options.axisY.length) {\n                            if (!this.axisY.length)\n                                for (var b = 0; b < this.options.axisY.length; b++)\n                                    \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[b] = new z(this, \"axisY\", this.options.axisY[b], b, \"axisY\", \"left\")) : \"xySwapped\" ===\n                                        this.plotInfo.axisPlacement && this._axes.push(this.axisY[b] = new z(this, \"axisY\", this.options.axisY[b], b, \"axisY\", \"bottom\"));\n                            this.data[d].axisY = this.axisY[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY.length ? this.data[d].axisYIndex : 0];\n                            this.axisY[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY.length ? this.data[d].axisYIndex : 0].dataSeries.push(this.data[d]);\n                        }\n                        else\n                            this.axisY.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new z(this, \"axisY\", this.options.axisY, 0, \"axisY\", \"left\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new z(this, \"axisY\", this.options.axisY, 0, \"axisY\", \"bottom\"))), this.data[d].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[d]);\n                    if (\"secondary\" === this.data[d].axisYType)\n                        if (this.options.axisY2 && 0 < this.options.axisY2.length) {\n                            if (!this.axisY2.length)\n                                for (b = 0; b < this.options.axisY2.length; b++)\n                                    \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[b] = new z(this, \"axisY2\", this.options.axisY2[b], b, \"axisY\", \"right\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[b] = new z(this, \"axisY2\", this.options.axisY2[b], b, \"axisY\", \"top\"));\n                            this.data[d].axisY = this.axisY2[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY2.length ? this.data[d].axisYIndex : 0];\n                            this.axisY2[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY2.length ? this.data[d].axisYIndex : 0].dataSeries.push(this.data[d]);\n                        }\n                        else\n                            this.axisY2.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] =\n                                new z(this, \"axisY2\", this.options.axisY2, 0, \"axisY\", \"right\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new z(this, \"axisY2\", this.options.axisY2, 0, \"axisY\", \"top\"))), this.data[d].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[d]);\n                    if (!this.data[d].axisXType || \"primary\" === this.data[d].axisXType)\n                        if (this.options.axisX && 0 < this.options.axisX.length) {\n                            if (!this.axisX.length)\n                                for (b = 0; b < this.options.axisX.length; b++)\n                                    \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[b] =\n                                        new z(this, \"axisX\", this.options.axisX[b], b, \"axisX\", \"bottom\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[b] = new z(this, \"axisX\", this.options.axisX[b], b, \"axisX\", \"left\"));\n                            this.data[d].axisX = this.axisX[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX.length ? this.data[d].axisXIndex : 0];\n                            this.axisX[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX.length ? this.data[d].axisXIndex : 0].dataSeries.push(this.data[d]);\n                        }\n                        else\n                            this.axisX.length || (\"normal\" === this.plotInfo.axisPlacement ?\n                                this._axes.push(this.axisX[0] = new z(this, \"axisX\", this.options.axisX, 0, \"axisX\", \"bottom\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new z(this, \"axisX\", this.options.axisX, 0, \"axisX\", \"left\"))), this.data[d].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[d]);\n                    if (\"secondary\" === this.data[d].axisXType)\n                        if (this.options.axisX2 && 0 < this.options.axisX2.length) {\n                            if (!this.axisX2.length)\n                                for (b = 0; b < this.options.axisX2.length; b++)\n                                    \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[b] =\n                                        new z(this, \"axisX2\", this.options.axisX2[b], b, \"axisX\", \"top\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[b] = new z(this, \"axisX2\", this.options.axisX2[b], b, \"axisX\", \"right\"));\n                            this.data[d].axisX = this.axisX2[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX2.length ? this.data[d].axisXIndex : 0];\n                            this.axisX2[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX2.length ? this.data[d].axisXIndex : 0].dataSeries.push(this.data[d]);\n                        }\n                        else\n                            this.axisX2.length || (\"normal\" ===\n                                this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new z(this, \"axisX2\", this.options.axisX2, 0, \"axisX\", \"top\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new z(this, \"axisX2\", this.options.axisX2, 0, \"axisX\", \"right\"))), this.data[d].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[d]);\n                }\n            if (this.axisY) {\n                for (b = 1; b < this.axisY.length; b++)\n                    \"undefined\" === typeof this.axisY[b].options.gridThickness && (this.axisY[b].gridThickness = 0);\n                for (b = 0; b < this.axisY.length - 1; b++)\n                    \"undefined\" ===\n                        typeof this.axisY[b].options.margin && (this.axisY[b].margin = 10);\n            }\n            if (this.axisY2) {\n                for (b = 1; b < this.axisY2.length; b++)\n                    \"undefined\" === typeof this.axisY2[b].options.gridThickness && (this.axisY2[b].gridThickness = 0);\n                for (b = 0; b < this.axisY2.length - 1; b++)\n                    \"undefined\" === typeof this.axisY2[b].options.margin && (this.axisY2[b].margin = 10);\n            }\n            this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && \"undefined\" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness =\n                0 : 0 < this.axisY2[0].gridThickness && \"undefined\" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));\n            if (this.axisX)\n                for (b = 0; b < this.axisX.length; b++)\n                    \"undefined\" === typeof this.axisX[b].options.gridThickness && (this.axisX[b].gridThickness = 0);\n            if (this.axisX2)\n                for (b = 0; b < this.axisX2.length; b++)\n                    \"undefined\" === typeof this.axisX2[b].options.gridThickness && (this.axisX2[b].gridThickness = 0);\n            this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness &&\n                \"undefined\" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && \"undefined\" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));\n            b = !1;\n            if (0 < this._axes.length && (this.zoomEnabled || this.panEnabled))\n                for (d = 0; d < this._axes.length; d++)\n                    if (null !== this._axes[d].viewportMinimum || null !== this._axes[d].viewportMaximum) {\n                        b = !0;\n                        break;\n                    }\n            b ? (Qa(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + \"px solid \" +\n                this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + \"px solid \" + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + \"px solid \" + this.toolbar.borderColor) : (va(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + \"px solid transparent\", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1));\n            gb(this);\n            this._processData();\n            this.options.title && (this.title = new Aa(this, this.options.title), this.title.dockInsidePlotArea ? a.push(this.title) : this.title.setLayout());\n            this.subtitles = [];\n            if (this.options.subtitles)\n                for (d = 0; d < this.options.subtitles.length; d++)\n                    b = new Ka(this, this.options.subtitles[d], d), this.subtitles.push(b), b.dockInsidePlotArea ? a.push(b) : b.setLayout();\n            this.legend = new H(this, this.options.legend);\n            for (d = 0; d < this.data.length; d++)\n                (this.data[d].showInLegend || \"pie\" === this.data[d].type || \"doughnut\" === this.data[d].type || \"funnel\" === this.data[d].type || \"pyramid\" === this.data[d].type) &&\n                    this.legend.dataSeries.push(this.data[d]);\n            this.legend.dockInsidePlotArea ? a.push(this.legend) : this.legend.setLayout();\n            for (d = 0; d < this._axes.length; d++)\n                if (this._axes[d].scaleBreaks && this._axes[d].scaleBreaks._appliedBreaks.length) {\n                    r ? (this._breaksCanvas = ta(this.width, this.height, !0), this._breaksCanvasCtx = this._breaksCanvas.getContext(\"2d\")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);\n                    break;\n                }\n            this._preRenderCanvas = ta(this.width, this.height);\n            this._preRenderCtx = this._preRenderCanvas.getContext(\"2d\");\n            \"normal\" !== this.plotInfo.axisPlacement && \"xySwapped\" !== this.plotInfo.axisPlacement || z.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());\n        };\n        p.prototype.renderElements = function () {\n            var a = this._plotAreaElements;\n            this.title && !this.title.dockInsidePlotArea && this.title.render();\n            for (var d = 0; d < this.subtitles.length; d++)\n                this.subtitles[d].dockInsidePlotArea || this.subtitles[d].render();\n            this.legend.dockInsidePlotArea || this.legend.render();\n            if (\"normal\" ===\n                this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement)\n                z.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement);\n            else if (\"none\" === this.plotInfo.axisPlacement)\n                this.preparePlotArea();\n            else\n                return;\n            for (d = 0; d < a.length; d++)\n                a[d].setLayout(), a[d].render();\n            var b = [];\n            if (this.animatedRender) {\n                var c = ta(this.width, this.height);\n                c.getContext(\"2d\").drawImage(this.canvas, 0, 0, this.width, this.height);\n            }\n            hb(this);\n            var a = this.ctx.miterLimit, e;\n            this.ctx.miterLimit = 3;\n            r && this._breaksCanvas &&\n                (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = \"source-atop\", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height));\n            for (d = 0; d < this.plotInfo.plotTypes.length; d++)\n                for (var g = this.plotInfo.plotTypes[d], k = 0; k < g.plotUnits.length; k++) {\n                    var l = g.plotUnits[k], w = null;\n                    l.targetCanvas =\n                        null;\n                    this.animatedRender && (l.targetCanvas = ta(this.width, this.height), l.targetCanvasCtx = l.targetCanvas.getContext(\"2d\"), e = l.targetCanvasCtx.miterLimit, l.targetCanvasCtx.miterLimit = 3);\n                    \"line\" === l.type ? w = this.renderLine(l) : \"stepLine\" === l.type ? w = this.renderStepLine(l) : \"spline\" === l.type ? w = this.renderSpline(l) : \"column\" === l.type ? w = this.renderColumn(l) : \"bar\" === l.type ? w = this.renderBar(l) : \"area\" === l.type ? w = this.renderArea(l) : \"stepArea\" === l.type ? w = this.renderStepArea(l) : \"splineArea\" === l.type ? w = this.renderSplineArea(l) :\n                        \"stackedColumn\" === l.type ? w = this.renderStackedColumn(l) : \"stackedColumn100\" === l.type ? w = this.renderStackedColumn100(l) : \"stackedBar\" === l.type ? w = this.renderStackedBar(l) : \"stackedBar100\" === l.type ? w = this.renderStackedBar100(l) : \"stackedArea\" === l.type ? w = this.renderStackedArea(l) : \"stackedArea100\" === l.type ? w = this.renderStackedArea100(l) : \"bubble\" === l.type ? w = w = this.renderBubble(l) : \"scatter\" === l.type ? w = this.renderScatter(l) : \"pie\" === l.type ? this.renderPie(l) : \"doughnut\" === l.type ? this.renderPie(l) : \"funnel\" === l.type ?\n                            w = this.renderFunnel(l) : \"pyramid\" === l.type ? w = this.renderFunnel(l) : \"candlestick\" === l.type ? w = this.renderCandlestick(l) : \"ohlc\" === l.type ? w = this.renderCandlestick(l) : \"rangeColumn\" === l.type ? w = this.renderRangeColumn(l) : \"error\" === l.type ? w = this.renderError(l) : \"rangeBar\" === l.type ? w = this.renderRangeBar(l) : \"rangeArea\" === l.type ? w = this.renderRangeArea(l) : \"rangeSplineArea\" === l.type ? w = this.renderRangeSplineArea(l) : \"waterfall\" === l.type ? w = this.renderWaterfall(l) : \"boxAndWhisker\" === l.type && (w = this.renderBoxAndWhisker(l));\n                    for (var m = 0; m < l.dataSeriesIndexes.length; m++)\n                        this._dataInRenderedOrder.push(this.data[l.dataSeriesIndexes[m]]);\n                    this.animatedRender && (l.targetCanvasCtx.miterLimit = e, w && b.push(w));\n                }\n            this.ctx.miterLimit = a;\n            this.animatedRender && this._breaksCanvasCtx && b.push({ source: this._breaksCanvasCtx, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 });\n            this.animatedRender && 0 < this._indexLabels.length && (e = ta(this.width, this.height).getContext(\"2d\"),\n                b.push(this.renderIndexLabels(e)));\n            var s = this;\n            if (0 < b.length)\n                s.disableToolTip = !0, s._animator.animate(200, s.animationDuration, function (a) {\n                    s.ctx.clearRect(0, 0, s.width, s.height);\n                    s.ctx.drawImage(c, 0, 0, Math.floor(s.width * W), Math.floor(s.height * W), 0, 0, s.width, s.height);\n                    for (var e = 0; e < b.length; e++)\n                        w = b[e], 1 > a && \"undefined\" !== typeof w.startTimePercent ? a >= w.startTimePercent && w.animationCallback(w.easingFunction(a - w.startTimePercent, 0, 1, 1 - w.startTimePercent), w) : w.animationCallback(w.easingFunction(a, 0, 1, 1), w);\n                    s.dispatchEvent(\"dataAnimationIterationEnd\", { chart: s });\n                }, function () { b = []; for (var a = 0; a < s.plotInfo.plotTypes.length; a++)\n                    for (var e = s.plotInfo.plotTypes[a], d = 0; d < e.plotUnits.length; d++)\n                        e.plotUnits[d].targetCanvas = null; c = null; s.disableToolTip = !1; });\n            else {\n                if (s._breaksCanvas)\n                    if (r)\n                        s.plotArea.ctx.drawImage(s._breaksCanvas, 0, 0, this.width, this.height);\n                    else\n                        for (m = 0; m < s._axes.length; m++)\n                            s._axes[m].createMask();\n                0 < s._indexLabels.length && s.renderIndexLabels();\n                s.dispatchEvent(\"dataAnimationIterationEnd\", { chart: s });\n            }\n            this.attachPlotAreaEventHandlers();\n            this.zoomEnabled || (this.panEnabled || !this._zoomButton || \"none\" === this._zoomButton.style.display) || va(this._zoomButton, this._resetButton);\n            this.toolTip._updateToolTip();\n            this.renderCount++;\n            Ja && (s = this, setTimeout(function () { var a = document.getElementById(\"ghostCanvasCopy\"); a && (Oa(a, s.width, s.height), a.getContext(\"2d\").drawImage(s._eventManager.ghostCanvas, 0, 0)); }, 2E3));\n            this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);\n            for (m = 0; m < this._axes.length; m++)\n                this._axes[m].maskCanvas && (delete this._axes[m].maskCanvas,\n                    delete this._axes[m].maskCtx);\n        };\n        p.prototype.render = function (a) { a && (this.options = a); this._initialize(); this.setLayout(); this.renderElements(); this._preRenderCanvas = null; };\n        p.prototype.attachPlotAreaEventHandlers = function () { this.attachEvent({ context: this, chart: this, mousedown: this._plotAreaMouseDown, mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.panEnabled ? \"move\" : \"default\", capture: !0, bounds: this.plotArea }); };\n        p.prototype.categoriseDataSeries = function () {\n            for (var a = \"\", d = 0; d < this.data.length; d++)\n                if (a =\n                    this.data[d], a.dataPoints && (0 !== a.dataPoints.length && a.visible) && 0 <= p._supportedChartTypes.indexOf(a.type)) {\n                    for (var b = null, c = !1, e = null, g = !1, k = 0; k < this.plotInfo.plotTypes.length; k++)\n                        if (this.plotInfo.plotTypes[k].type === a.type) {\n                            c = !0;\n                            b = this.plotInfo.plotTypes[k];\n                            break;\n                        }\n                    c || (b = { type: a.type, totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(b));\n                    for (k = 0; k < b.plotUnits.length; k++)\n                        if (b.plotUnits[k].axisYType === a.axisYType && b.plotUnits[k].axisXType === a.axisXType && b.plotUnits[k].axisYIndex === a.axisYIndex &&\n                            b.plotUnits[k].axisXIndex === a.axisXIndex) {\n                            g = !0;\n                            e = b.plotUnits[k];\n                            break;\n                        }\n                    g || (e = { type: a.type, previousDataSeriesCount: 0, index: b.plotUnits.length, plotType: b, axisXType: a.axisXType, axisYType: a.axisYType, axisYIndex: a.axisYIndex, axisXIndex: a.axisXIndex, axisY: \"primary\" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0], axisX: \"primary\" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ?\n                            a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0], dataSeriesIndexes: [], yTotals: [] }, b.plotUnits.push(e));\n                    b.totalDataSeries++;\n                    e.dataSeriesIndexes.push(d);\n                    a.plotUnit = e;\n                }\n            for (d = 0; d < this.plotInfo.plotTypes.length; d++)\n                for (b = this.plotInfo.plotTypes[d], k = a = 0; k < b.plotUnits.length; k++)\n                    b.plotUnits[k].previousDataSeriesCount = a, a += b.plotUnits[k].dataSeriesIndexes.length;\n        };\n        p.prototype.assignIdToDataPoints = function () {\n            for (var a = 0; a < this.data.length; a++) {\n                var d = this.data[a];\n                if (d.dataPoints)\n                    for (var b = d.dataPoints.length, c = 0; c < b; c++)\n                        d.dataPointIds[c] = ++this._eventManager.lastObjectId;\n            }\n        };\n        p.prototype._processData = function () {\n            this.assignIdToDataPoints();\n            this.categoriseDataSeries();\n            for (var a = 0; a < this.plotInfo.plotTypes.length; a++)\n                for (var d = this.plotInfo.plotTypes[a], b = 0; b < d.plotUnits.length; b++) {\n                    var c = d.plotUnits[b];\n                    \"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"column\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"bar\" === c.type || \"bubble\" ===\n                        c.type || \"scatter\" === c.type ? this._processMultiseriesPlotUnit(c) : \"stackedColumn\" === c.type || \"stackedBar\" === c.type || \"stackedArea\" === c.type ? this._processStackedPlotUnit(c) : \"stackedColumn100\" === c.type || \"stackedBar100\" === c.type || \"stackedArea100\" === c.type ? this._processStacked100PlotUnit(c) : \"candlestick\" === c.type || \"ohlc\" === c.type || \"rangeColumn\" === c.type || \"rangeBar\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"error\" === c.type || \"boxAndWhisker\" === c.type ? this._processMultiYPlotUnit(c) : \"waterfall\" ===\n                        c.type && this._processSpecificPlotUnit(c);\n                }\n            this.calculateAutoBreaks();\n        };\n        p.prototype._processMultiseriesPlotUnit = function (a) {\n            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))\n                for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, k = 0; k < a.dataSeriesIndexes.length; k++) {\n                    var l = this.data[a.dataSeriesIndexes[k]], w = 0, m = !1, s = !1, q;\n                    if (\"normal\" === l.axisPlacement || \"xySwapped\" === l.axisPlacement)\n                        var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX &&\n                            this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, f = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;\n                    if (l.dataPoints[w].x && l.dataPoints[w].x.getTime || \"dateTime\" ===\n                        l.xValueType)\n                        g = !0;\n                    for (w = 0; w < l.dataPoints.length; w++) {\n                        \"undefined\" === typeof l.dataPoints[w].x && (l.dataPoints[w].x = w + (a.axisX.logarithmic ? 1 : 0));\n                        l.dataPoints[w].x.getTime ? (g = !0, c = l.dataPoints[w].x.getTime()) : c = l.dataPoints[w].x;\n                        e = l.dataPoints[w].y;\n                        c < b.min && (b.min = c);\n                        c > b.max && (b.max = c);\n                        e < d.min && \"number\" === typeof e && (d.min = e);\n                        e > d.max && \"number\" === typeof e && (d.max = e);\n                        if (0 < w) {\n                            if (a.axisX.logarithmic) {\n                                var B = c / l.dataPoints[w - 1].x;\n                                1 > B && (B = 1 / B);\n                                b.minDiff > B && 1 !== B && (b.minDiff = B);\n                            }\n                            else\n                                B = c - l.dataPoints[w - 1].x, 0 > B &&\n                                    (B *= -1), b.minDiff > B && 0 !== B && (b.minDiff = B);\n                            null !== e && null !== l.dataPoints[w - 1].y && (a.axisY.logarithmic ? (B = e / l.dataPoints[w - 1].y, 1 > B && (B = 1 / B), d.minDiff > B && 1 !== B && (d.minDiff = B)) : (B = e - l.dataPoints[w - 1].y, 0 > B && (B *= -1), d.minDiff > B && 0 !== B && (d.minDiff = B)));\n                        }\n                        if (c < n && !m)\n                            null !== e && (q = c);\n                        else {\n                            if (!m && (m = !0, 0 < w)) {\n                                w -= 2;\n                                continue;\n                            }\n                            if (c > f && !s)\n                                s = !0;\n                            else if (c > f && s)\n                                continue;\n                            l.dataPoints[w].label && (a.axisX.labels[c] = l.dataPoints[w].label);\n                            c < b.viewPortMin && (b.viewPortMin = c);\n                            c > b.viewPortMax && (b.viewPortMax = c);\n                            null === e ? b.viewPortMin ===\n                                c && q < c && (b.viewPortMin = q) : (e < d.viewPortMin && \"number\" === typeof e && (d.viewPortMin = e), e > d.viewPortMax && \"number\" === typeof e && (d.viewPortMax = e));\n                        }\n                    }\n                    l.axisX.valueType = l.xValueType = g ? \"dateTime\" : \"number\";\n                }\n        };\n        p.prototype._processStackedPlotUnit = function (a) {\n            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n                for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, k = [], l = [], w = Infinity, m = -Infinity, s = 0; s < a.dataSeriesIndexes.length; s++) {\n                    var q = this.data[a.dataSeriesIndexes[s]], n = 0, f = !1, B = !1, h;\n                    if (\"normal\" === q.axisPlacement ||\n                        \"xySwapped\" === q.axisPlacement)\n                        var p = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ?\n                            this.options.axisX.maximum : Infinity;\n                    if (q.dataPoints[n].x && q.dataPoints[n].x.getTime || \"dateTime\" === q.xValueType)\n                        g = !0;\n                    for (n = 0; n < q.dataPoints.length; n++) {\n                        \"undefined\" === typeof q.dataPoints[n].x && (q.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0));\n                        q.dataPoints[n].x.getTime ? (g = !0, c = q.dataPoints[n].x.getTime()) : c = q.dataPoints[n].x;\n                        e = u(q.dataPoints[n].y) ? 0 : q.dataPoints[n].y;\n                        c < b.min && (b.min = c);\n                        c > b.max && (b.max = c);\n                        if (0 < n) {\n                            if (a.axisX.logarithmic) {\n                                var r = c / q.dataPoints[n - 1].x;\n                                1 > r && (r = 1 / r);\n                                b.minDiff > r && 1 !== r && (b.minDiff =\n                                    r);\n                            }\n                            else\n                                r = c - q.dataPoints[n - 1].x, 0 > r && (r *= -1), b.minDiff > r && 0 !== r && (b.minDiff = r);\n                            null !== e && null !== q.dataPoints[n - 1].y && (a.axisY.logarithmic ? 0 < e && (r = e / q.dataPoints[n - 1].y, 1 > r && (r = 1 / r), d.minDiff > r && 1 !== r && (d.minDiff = r)) : (r = e - q.dataPoints[n - 1].y, 0 > r && (r *= -1), d.minDiff > r && 0 !== r && (d.minDiff = r)));\n                        }\n                        if (c < p && !f)\n                            null !== q.dataPoints[n].y && (h = c);\n                        else {\n                            if (!f && (f = !0, 0 < n)) {\n                                n -= 2;\n                                continue;\n                            }\n                            if (c > t && !B)\n                                B = !0;\n                            else if (c > t && B)\n                                continue;\n                            q.dataPoints[n].label && (a.axisX.labels[c] = q.dataPoints[n].label);\n                            c < b.viewPortMin && (b.viewPortMin =\n                                c);\n                            c > b.viewPortMax && (b.viewPortMax = c);\n                            null === q.dataPoints[n].y ? b.viewPortMin === c && h < c && (b.viewPortMin = h) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? k[c] ? k[c] += e : (k[c] = e, w = Math.min(e, w)) : l[c] ? l[c] += e : (l[c] = e, m = Math.max(e, m)));\n                        }\n                    }\n                    a.axisY.scaleBreaks && (a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (d.dataPointYPositiveSums ? (d.dataPointYPositiveSums.push.apply(d.dataPointYPositiveSums, k), d.dataPointYNegativeSums.push.apply(d.dataPointYPositiveSums, l)) : (d.dataPointYPositiveSums =\n                        k, d.dataPointYNegativeSums = l));\n                    q.axisX.valueType = q.xValueType = g ? \"dateTime\" : \"number\";\n                }\n                for (n in k)\n                    k.hasOwnProperty(n) && !isNaN(n) && (a = k[n], a < d.min && (d.min = Math.min(a, w)), a > d.max && (d.max = a), n < b.viewPortMin || n > b.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = Math.min(a, w)), a > d.viewPortMax && (d.viewPortMax = a)));\n                for (n in l)\n                    l.hasOwnProperty(n) && !isNaN(n) && (a = l[n], a < d.min && (d.min = a), a > d.max && (d.max = Math.max(a, m)), n < b.viewPortMin || n > b.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = a), a > d.viewPortMax && (d.viewPortMax =\n                        Math.max(a, m))));\n            }\n        };\n        p.prototype._processStacked100PlotUnit = function (a) {\n            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n                for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, k = !1, l = !1, w = [], m = 0; m < a.dataSeriesIndexes.length; m++) {\n                    var s = this.data[a.dataSeriesIndexes[m]], q = 0, n = !1, f = !1, B;\n                    if (\"normal\" === s.axisPlacement || \"xySwapped\" === s.axisPlacement)\n                        var h = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ?\n                            this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, r = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;\n                    if (s.dataPoints[q].x && s.dataPoints[q].x.getTime || \"dateTime\" === s.xValueType)\n                        g = !0;\n                    for (q = 0; q < s.dataPoints.length; q++) {\n                        \"undefined\" ===\n                            typeof s.dataPoints[q].x && (s.dataPoints[q].x = q + (a.axisX.logarithmic ? 1 : 0));\n                        s.dataPoints[q].x.getTime ? (g = !0, c = s.dataPoints[q].x.getTime()) : c = s.dataPoints[q].x;\n                        e = u(s.dataPoints[q].y) ? null : s.dataPoints[q].y;\n                        c < b.min && (b.min = c);\n                        c > b.max && (b.max = c);\n                        if (0 < q) {\n                            if (a.axisX.logarithmic) {\n                                var t = c / s.dataPoints[q - 1].x;\n                                1 > t && (t = 1 / t);\n                                b.minDiff > t && 1 !== t && (b.minDiff = t);\n                            }\n                            else\n                                t = c - s.dataPoints[q - 1].x, 0 > t && (t *= -1), b.minDiff > t && 0 !== t && (b.minDiff = t);\n                            u(e) || null === s.dataPoints[q - 1].y || (a.axisY.logarithmic ? 0 < e && (t = e / s.dataPoints[q -\n                                1].y, 1 > t && (t = 1 / t), d.minDiff > t && 1 !== t && (d.minDiff = t)) : (t = e - s.dataPoints[q - 1].y, 0 > t && (t *= -1), d.minDiff > t && 0 !== t && (d.minDiff = t)));\n                        }\n                        if (c < h && !n)\n                            null !== e && (B = c);\n                        else {\n                            if (!n && (n = !0, 0 < q)) {\n                                q -= 2;\n                                continue;\n                            }\n                            if (c > r && !f)\n                                f = !0;\n                            else if (c > r && f)\n                                continue;\n                            s.dataPoints[q].label && (a.axisX.labels[c] = s.dataPoints[q].label);\n                            c < b.viewPortMin && (b.viewPortMin = c);\n                            c > b.viewPortMax && (b.viewPortMax = c);\n                            null === e ? b.viewPortMin === c && B < c && (b.viewPortMin = B) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? k = !0 : 0 > e && (l = !0), w[c] = w[c] ? w[c] +\n                                Math.abs(e) : Math.abs(e));\n                        }\n                    }\n                    s.axisX.valueType = s.xValueType = g ? \"dateTime\" : \"number\";\n                }\n                a.axisY.logarithmic ? (d.max = u(d.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(d.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), d.min = u(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : k && !l ? (d.max = u(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = u(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : k && l ? (d.max = u(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = u(d.viewPortMin) ? -99 : Math.min(d.viewPortMin, -99)) : !k && l && (d.max = u(d.viewPortMax) ? -1 : Math.max(d.viewPortMax, -1), d.min = u(d.viewPortMin) ? -99 : Math.min(d.viewPortMin, -99));\n                d.viewPortMin = d.min;\n                d.viewPortMax = d.max;\n                a.dataPointYSums = w;\n            }\n        };\n        p.prototype._processMultiYPlotUnit = function (a) {\n            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))\n                for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g, k, l = !1, w = 0; w < a.dataSeriesIndexes.length; w++) {\n                    var m = this.data[a.dataSeriesIndexes[w]], s = 0, q = !1, n = !1, f, B, h;\n                    if (\"normal\" === m.axisPlacement || \"xySwapped\" === m.axisPlacement)\n                        var r = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ?\n                            this.options.axisX.maximum : Infinity;\n                    if (m.dataPoints[s].x && m.dataPoints[s].x.getTime || \"dateTime\" === m.xValueType)\n                        l = !0;\n                    for (s = 0; s < m.dataPoints.length; s++) {\n                        \"undefined\" === typeof m.dataPoints[s].x && (m.dataPoints[s].x = s + (a.axisX.logarithmic ? 1 : 0));\n                        m.dataPoints[s].x.getTime ? (l = !0, c = m.dataPoints[s].x.getTime()) : c = m.dataPoints[s].x;\n                        if ((e = m.dataPoints[s].y) && e.length) {\n                            g = Math.min.apply(null, e);\n                            k = Math.max.apply(null, e);\n                            B = !0;\n                            for (var p = 0; p < e.length; p++)\n                                null === e.k && (B = !1);\n                            B && (q || (h = f), f = c);\n                        }\n                        c < b.min && (b.min = c);\n                        c > b.max &&\n                            (b.max = c);\n                        g < d.min && (d.min = g);\n                        k > d.max && (d.max = k);\n                        0 < s && (a.axisX.logarithmic ? (B = c / m.dataPoints[s - 1].x, 1 > B && (B = 1 / B), b.minDiff > B && 1 !== B && (b.minDiff = B)) : (B = c - m.dataPoints[s - 1].x, 0 > B && (B *= -1), b.minDiff > B && 0 !== B && (b.minDiff = B)), e && (null !== e[0] && m.dataPoints[s - 1].y && null !== m.dataPoints[s - 1].y[0]) && (a.axisY.logarithmic ? (B = e[0] / m.dataPoints[s - 1].y[0], 1 > B && (B = 1 / B), d.minDiff > B && 1 !== B && (d.minDiff = B)) : (B = e[0] - m.dataPoints[s - 1].y[0], 0 > B && (B *= -1), d.minDiff > B && 0 !== B && (d.minDiff = B))));\n                        if (!(c < r) || q) {\n                            if (!q && (q = !0, 0 < s)) {\n                                s -=\n                                    2;\n                                f = h;\n                                continue;\n                            }\n                            if (c > t && !n)\n                                n = !0;\n                            else if (c > t && n)\n                                continue;\n                            m.dataPoints[s].label && (a.axisX.labels[c] = m.dataPoints[s].label);\n                            c < b.viewPortMin && (b.viewPortMin = c);\n                            c > b.viewPortMax && (b.viewPortMax = c);\n                            if (b.viewPortMin === c && e)\n                                for (p = 0; p < e.length; p++)\n                                    if (null === e[p] && f < c) {\n                                        b.viewPortMin = f;\n                                        break;\n                                    }\n                            null === e ? b.viewPortMin === c && f < c && (b.viewPortMin = f) : (g < d.viewPortMin && (d.viewPortMin = g), k > d.viewPortMax && (d.viewPortMax = k));\n                        }\n                    }\n                    m.axisX.valueType = m.xValueType = l ? \"dateTime\" : \"number\";\n                }\n        };\n        p.prototype._processSpecificPlotUnit = function (a) {\n            if (\"waterfall\" ===\n                a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))\n                for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, k = 0; k < a.dataSeriesIndexes.length; k++) {\n                    var l = this.data[a.dataSeriesIndexes[k]], w = 0, m = !1, s = !1, q = c = 0;\n                    if (\"normal\" === l.axisPlacement || \"xySwapped\" === l.axisPlacement)\n                        var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ?\n                            this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, f = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;\n                    if (l.dataPoints[w].x && l.dataPoints[w].x.getTime || \"dateTime\" === l.xValueType)\n                        g = !0;\n                    for (w = 0; w < l.dataPoints.length; w++)\n                        \"undefined\" !== typeof l.dataPoints[w].isCumulativeSum && !0 === l.dataPoints[w].isCumulativeSum ?\n                            (l.dataPointEOs[w].cumulativeSumYStartValue = 0, l.dataPointEOs[w].cumulativeSum = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum, l.dataPoints[w].y = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum) : \"undefined\" !== typeof l.dataPoints[w].isIntermediateSum && !0 === l.dataPoints[w].isIntermediateSum ? (l.dataPointEOs[w].cumulativeSumYStartValue = q, l.dataPointEOs[w].cumulativeSum = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum, l.dataPoints[w].y = 0 === w ? 0 : c, q = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum, c = 0) : (e = \"number\" !== typeof l.dataPoints[w].y ?\n                            0 : l.dataPoints[w].y, l.dataPointEOs[w].cumulativeSumYStartValue = 0 === w ? 0 : l.dataPointEOs[w - 1].cumulativeSum, l.dataPointEOs[w].cumulativeSum = 0 === w ? e : l.dataPointEOs[w - 1].cumulativeSum + e, c += e);\n                    for (w = 0; w < l.dataPoints.length; w++)\n                        if (\"undefined\" === typeof l.dataPoints[w].x && (l.dataPoints[w].x = w + (a.axisX.logarithmic ? 1 : 0)), l.dataPoints[w].x.getTime ? (g = !0, c = l.dataPoints[w].x.getTime()) : c = l.dataPoints[w].x, e = l.dataPoints[w].y, c < b.min && (b.min = c), c > b.max && (b.max = c), l.dataPointEOs[w].cumulativeSum < d.min && (d.min = l.dataPointEOs[w].cumulativeSum),\n                            l.dataPointEOs[w].cumulativeSum > d.max && (d.max = l.dataPointEOs[w].cumulativeSum), 0 < w && (a.axisX.logarithmic ? (q = c / l.dataPoints[w - 1].x, 1 > q && (q = 1 / q), b.minDiff > q && 1 !== q && (b.minDiff = q)) : (q = c - l.dataPoints[w - 1].x, 0 > q && (q *= -1), b.minDiff > q && 0 !== q && (b.minDiff = q)), null !== e && null !== l.dataPoints[w - 1].y && (a.axisY.logarithmic ? (e = l.dataPointEOs[w].cumulativeSum / l.dataPointEOs[w - 1].cumulativeSum, 1 > e && (e = 1 / e), d.minDiff > e && 1 !== e && (d.minDiff = e)) : (e = l.dataPointEOs[w].cumulativeSum - l.dataPointEOs[w - 1].cumulativeSum, 0 > e &&\n                            (e *= -1), d.minDiff > e && 0 !== e && (d.minDiff = e)))), !(c < n) || m) {\n                            if (!m && (m = !0, 0 < w)) {\n                                w -= 2;\n                                continue;\n                            }\n                            if (c > f && !s)\n                                s = !0;\n                            else if (c > f && s)\n                                continue;\n                            l.dataPoints[w].label && (a.axisX.labels[c] = l.dataPoints[w].label);\n                            c < b.viewPortMin && (b.viewPortMin = c);\n                            c > b.viewPortMax && (b.viewPortMax = c);\n                            0 < w && (l.dataPointEOs[w - 1].cumulativeSum < d.viewPortMin && (d.viewPortMin = l.dataPointEOs[w - 1].cumulativeSum), l.dataPointEOs[w - 1].cumulativeSum > d.viewPortMax && (d.viewPortMax = l.dataPointEOs[w - 1].cumulativeSum));\n                            l.dataPointEOs[w].cumulativeSum <\n                                d.viewPortMin && (d.viewPortMin = l.dataPointEOs[w].cumulativeSum);\n                            l.dataPointEOs[w].cumulativeSum > d.viewPortMax && (d.viewPortMax = l.dataPointEOs[w].cumulativeSum);\n                        }\n                    l.axisX.valueType = l.xValueType = g ? \"dateTime\" : \"number\";\n                }\n        };\n        p.prototype.calculateAutoBreaks = function () {\n            function a(a, c, b, e) {\n                if (e)\n                    return b = Math.pow(Math.min(b * a / c, c / a), 0.2), 1 >= b && (b = Math.pow(1 > a ? 1 / a : Math.min(c / a, a), 0.25)), { startValue: a * b, endValue: c / b };\n                b = 0.2 * Math.min(b - c + a, c - a);\n                0 >= b && (b = 0.25 * Math.min(c - a, Math.abs(a)));\n                return { startValue: a + b, endValue: c -\n                        b };\n            }\n            function d(a) {\n                if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\n                    var c = a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks, b = a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks;\n                    if (c || b)\n                        for (var d = a.axisY.dataInfo, f = a.axisX.dataInfo, g, m = f.min, l = f.max, k = d.min, n = d.max, f = f._dataRanges, d = d._dataRanges, q, w = 0, s = 0; s < a.dataSeriesIndexes.length; s++) {\n                            var h = e.data[a.dataSeriesIndexes[s]];\n                            if (!(4 > h.dataPoints.length))\n                                for (w =\n                                    0; w < h.dataPoints.length; w++)\n                                    if (c && (q = (l + 1 - m) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, g = h.dataPoints[w].x.getTime ? h.dataPoints[w].x.getTime() : h.dataPoints[w].x, q = Math.floor((g - m) / q), g < f[q].min && (f[q].min = g), g > f[q].max && (f[q].max = g)), b) {\n                                        var r = (n + 1 - k) * Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;\n                                        if ((g = \"waterfall\" === a.type ? h.dataPointEOs[w].cumulativeSum : h.dataPoints[w].y) && g.length)\n                                            for (var p = 0; p < g.length; p++)\n                                                q = Math.floor((g[p] - k) / r), g[p] <\n                                                    d[q].min && (d[q].min = g[p]), g[p] > d[q].max && (d[q].max = g[p]);\n                                        else\n                                            u(g) || (q = Math.floor((g - k) / r), g < d[q].min && (d[q].min = g), g > d[q].max && (d[q].max = g));\n                                    }\n                        }\n                }\n            }\n            function b(a) {\n                if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length) && a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks)\n                    for (var c = a.axisX.dataInfo, b = c.min, d = c.max, f = c._dataRanges, g, m = 0, l = 0; l < a.dataSeriesIndexes.length; l++) {\n                        var k = e.data[a.dataSeriesIndexes[l]];\n                        if (!(4 > k.dataPoints.length))\n                            for (m = 0; m < k.dataPoints.length; m++)\n                                g =\n                                    (d + 1 - b) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, c = k.dataPoints[m].x.getTime ? k.dataPoints[m].x.getTime() : k.dataPoints[m].x, g = Math.floor((c - b) / g), c < f[g].min && (f[g].min = c), c > f[g].max && (f[g].max = c);\n                    }\n            }\n            for (var c, e = this, g = !1, k = 0; k < this._axes.length; k++)\n                if (this._axes[k].scaleBreaks && this._axes[k].scaleBreaks.autoCalculate && 1 <= this._axes[k].scaleBreaks.maxNumberOfAutoBreaks) {\n                    g = !0;\n                    this._axes[k].dataInfo._dataRanges = [];\n                    for (var l = 0; l < 100 / Math.max(parseFloat(this._axes[k].scaleBreaks.collapsibleThreshold) ||\n                        10, 10); l++)\n                        this._axes[k].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity });\n                }\n            if (g) {\n                for (k = 0; k < this.plotInfo.plotTypes.length; k++)\n                    for (g = this.plotInfo.plotTypes[k], l = 0; l < g.plotUnits.length; l++)\n                        c = g.plotUnits[l], \"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"column\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"bar\" === c.type || \"bubble\" === c.type || \"scatter\" === c.type || \"candlestick\" === c.type || \"ohlc\" === c.type || \"rangeColumn\" === c.type || \"rangeBar\" === c.type || \"rangeArea\" ===\n                            c.type || \"rangeSplineArea\" === c.type || \"waterfall\" === c.type || \"error\" === c.type || \"boxAndWhisker\" === c.type ? d(c) : 0 <= c.type.indexOf(\"stacked\") && b(c);\n                for (k = 0; k < this._axes.length; k++)\n                    if (this._axes[k].dataInfo._dataRanges) {\n                        var w = this._axes[k].dataInfo.min;\n                        c = (this._axes[k].dataInfo.max + 1 - w) * Math.max(parseFloat(this._axes[k].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;\n                        var m = this._axes[k].dataInfo._dataRanges, s, q, g = [];\n                        if (this._axes[k].dataInfo.dataPointYPositiveSums) {\n                            var n = this._axes[k].dataInfo.dataPointYPositiveSums;\n                            s = m;\n                            for (l in n)\n                                if (n.hasOwnProperty(l) && !isNaN(l) && (q = n[l], !u(q))) {\n                                    var f = Math.floor((q - w) / c);\n                                    q < s[f].min && (s[f].min = q);\n                                    q > s[f].max && (s[f].max = q);\n                                }\n                            delete this._axes[k].dataInfo.dataPointYPositiveSums;\n                        }\n                        if (this._axes[k].dataInfo.dataPointYNegativeSums) {\n                            n = this._axes[k].dataInfo.dataPointYNegativeSums;\n                            s = m;\n                            for (l in n)\n                                n.hasOwnProperty(l) && !isNaN(l) && (q = -1 * n[l], u(q) || (f = Math.floor((q - w) / c), q < s[f].min && (s[f].min = q), q > s[f].max && (s[f].max = q)));\n                            delete this._axes[k].dataInfo.dataPointYNegativeSums;\n                        }\n                        for (l = 0; l < m.length -\n                            1; l++)\n                            if (s = m[l].max, isFinite(s))\n                                for (; l < m.length - 1;)\n                                    if (w = m[l + 1].min, isFinite(w)) {\n                                        q = w - s;\n                                        q > c && g.push({ diff: q, start: s, end: w });\n                                        break;\n                                    }\n                                    else\n                                        l++;\n                        if (this._axes[k].scaleBreaks.customBreaks)\n                            for (l = 0; l < this._axes[k].scaleBreaks.customBreaks.length; l++)\n                                for (c = 0; c < g.length; c++)\n                                    if (this._axes[k].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[k].scaleBreaks.customBreaks[l].endValue || this._axes[k].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[k].scaleBreaks.customBreaks[l].endValue ||\n                                        g[c].start <= this._axes[k].scaleBreaks.customBreaks[l].startValue && this._axes[k].scaleBreaks.customBreaks[l].startValue <= g[c].end || g[c].start <= this._axes[k].scaleBreaks.customBreaks[l].endValue && this._axes[k].scaleBreaks.customBreaks[l].endValue <= g[c].end)\n                                        g.splice(c, 1), c--;\n                        g.sort(function (a, c) { return c.diff - a.diff; });\n                        for (l = 0; l < Math.min(g.length, this._axes[k].scaleBreaks.maxNumberOfAutoBreaks); l++)\n                            c = a(g[l].start, g[l].end, this._axes[k].logarithmic ? this._axes[k].dataInfo.max / this._axes[k].dataInfo.min :\n                                this._axes[k].dataInfo.max - this._axes[k].dataInfo.min, this._axes[k].logarithmic), this._axes[k].scaleBreaks.autoBreaks.push(new L(this, \"autoBreaks\", c, l, ++this._eventManager.lastObjectId, this._axes[k].scaleBreaks)), this._axes[k].scaleBreaks._appliedBreaks.push(this._axes[k].scaleBreaks.autoBreaks[this._axes[k].scaleBreaks.autoBreaks.length - 1]);\n                        this._axes[k].scaleBreaks._appliedBreaks.sort(function (a, c) { return a.startValue - c.startValue; });\n                    }\n            }\n        };\n        p.prototype.getDataPointAtXY = function (a, d, b) {\n            b = b || !1;\n            for (var c = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) {\n                var g = null;\n                (g = this._dataInRenderedOrder[e].getDataPointAtXY(a, d, b)) && c.push(g);\n            }\n            a = null;\n            d = !1;\n            for (b = 0; b < c.length; b++)\n                if (\"line\" === c[b].dataSeries.type || \"stepLine\" === c[b].dataSeries.type || \"area\" === c[b].dataSeries.type || \"stepArea\" === c[b].dataSeries.type)\n                    if (e = na(\"markerSize\", c[b].dataPoint, c[b].dataSeries) || 8, c[b].distance <= e / 2) {\n                        d = !0;\n                        break;\n                    }\n            for (b = 0; b < c.length; b++)\n                d && \"line\" !== c[b].dataSeries.type && \"stepLine\" !== c[b].dataSeries.type && \"area\" !== c[b].dataSeries.type &&\n                    \"stepArea\" !== c[b].dataSeries.type || (a ? c[b].distance <= a.distance && (a = c[b]) : a = c[b]);\n            return a;\n        };\n        p.prototype.getObjectAtXY = function (a, d, b) { var c = null; if (b = this.getDataPointAtXY(a, d, b || !1))\n            c = b.dataSeries.dataPointIds[b.dataPointIndex];\n        else if (r)\n            c = ab(a, d, this._eventManager.ghostCtx);\n        else\n            for (b = 0; b < this.legend.items.length; b++) {\n                var e = this.legend.items[b];\n                a >= e.x1 && (a <= e.x2 && d >= e.y1 && d <= e.y2) && (c = e.id);\n            } return c; };\n        p.prototype.getAutoFontSize = lb;\n        p.prototype.resetOverlayedCanvas = function () {\n            this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);\n        };\n        p.prototype.clearCanvas = kb;\n        p.prototype.attachEvent = function (a) { this._events.push(a); };\n        p.prototype._touchEventHandler = function (a) {\n            if (a.changedTouches && this.interactivityEnabled) {\n                var d = [], b = a.changedTouches, c = b ? b[0] : a, e = null;\n                switch (a.type) {\n                    case \"touchstart\":\n                    case \"MSPointerDown\":\n                        d = [\"mousemove\", \"mousedown\"];\n                        this._lastTouchData = Ra(c);\n                        this._lastTouchData.time = new Date;\n                        break;\n                    case \"touchmove\":\n                    case \"MSPointerMove\":\n                        d = [\"mousemove\"];\n                        break;\n                    case \"touchend\":\n                    case \"MSPointerUp\":\n                        var g = this._lastTouchData &&\n                            this._lastTouchData.time ? new Date - this._lastTouchData.time : 0, d = \"touchstart\" === this._lastTouchEventType || \"MSPointerDown\" === this._lastTouchEventType || 300 > g ? [\"mouseup\", \"click\"] : [\"mouseup\"];\n                        break;\n                    default: return;\n                }\n                if (!(b && 1 < b.length)) {\n                    e = Ra(c);\n                    e.time = new Date;\n                    try {\n                        var k = e.y - this._lastTouchData.y, g = e.time - this._lastTouchData.time;\n                        if (1 < Math.abs(k) && this._lastTouchData.scroll || 5 < Math.abs(k) && 250 > g)\n                            this._lastTouchData.scroll = !0;\n                    }\n                    catch (l) { }\n                    this._lastTouchEventType = a.type;\n                    if (this._lastTouchData.scroll && this.zoomEnabled)\n                        this.isDrag &&\n                            this.resetOverlayedCanvas(), this.isDrag = !1;\n                    else\n                        for (b = 0; b < d.length; b++)\n                            if (e = d[b], k = document.createEvent(\"MouseEvent\"), k.initMouseEvent(e, !0, !0, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null), c.target.dispatchEvent(k), !u(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < g || \"click\" === e)\n                                a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault();\n                }\n            }\n        };\n        p.prototype._dispatchRangeEvent = function (a, d) {\n            var b = { chart: this };\n            b.type =\n                a;\n            b.trigger = d;\n            var c = [];\n            this.axisX && 0 < this.axisX.length && c.push(\"axisX\");\n            this.axisX2 && 0 < this.axisX2.length && c.push(\"axisX2\");\n            this.axisY && 0 < this.axisY.length && c.push(\"axisY\");\n            this.axisY2 && 0 < this.axisY2.length && c.push(\"axisY2\");\n            for (var e = 0; e < c.length; e++)\n                if (u(b[c[e]]) && (b[c[e]] = []), \"axisY\" === c[e])\n                    for (var g = 0; g < this.axisY.length; g++)\n                        b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\n                else if (\"axisY2\" === c[e])\n                    for (g =\n                        0; g < this.axisY2.length; g++)\n                        b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\n                else if (\"axisX\" === c[e])\n                    for (g = 0; g < this.axisX.length; g++)\n                        b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\n                else if (\"axisX2\" === c[e])\n                    for (g = 0; g < this.axisX2.length; g++)\n                        b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum,\n                            viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\n            this.dispatchEvent(a, b, this);\n        };\n        p.prototype._mouseEventHandler = function (a) {\n            \"undefined\" === typeof a.target && a.srcElement && (a.target = a.srcElement);\n            var d = Ra(a), b = a.type, c, e;\n            a.which ? e = 3 == a.which : a.button && (e = 2 == a.button);\n            p.capturedEventParam && (c = p.capturedEventParam, \"mouseup\" === b && (p.capturedEventParam = null, c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(\"mouseup\", c.chart._mouseEventHandler, !1)), c.hasOwnProperty(b) && (\"mouseup\" !== b || c.chart.overlaidCanvas.releaseCapture ? a.target !== c.chart.overlaidCanvas && r || c[b].call(c.context, d.x, d.y) : a.target !== c.chart.overlaidCanvas && (c.chart.isDrag = !1)));\n            if (this.interactivityEnabled)\n                if (this._ignoreNextEvent)\n                    this._ignoreNextEvent = !1;\n                else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), Ja && window.console && (window.console.log(b + \" --\\x3e x: \" + d.x + \"; y:\" + d.y), e && window.console.log(a.which),\n                    \"mouseup\" === b && window.console.log(\"mouseup\")), !e) {\n                    if (!p.capturedEventParam && this._events) {\n                        for (var g = 0; g < this._events.length; g++)\n                            if (this._events[g].hasOwnProperty(b))\n                                if (c = this._events[g], e = c.bounds, d.x >= e.x1 && d.x <= e.x2 && d.y >= e.y1 && d.y <= e.y2) {\n                                    c[b].call(c.context, d.x, d.y);\n                                    \"mousedown\" === b && !0 === c.capture ? (p.capturedEventParam = c, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener(\"mouseup\", this._mouseEventHandler, !1)) : \"mouseup\" === b && (c.chart.overlaidCanvas.releaseCapture ?\n                                        c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(\"mouseup\", this._mouseEventHandler, !1));\n                                    break;\n                                }\n                                else\n                                    c = null;\n                        a.target.style.cursor = c && c.cursor ? c.cursor : this._defaultCursor;\n                    }\n                    b = this.plotArea;\n                    if (d.x < b.x1 || d.x > b.x2 || d.y < b.y1 || d.y > b.y2)\n                        this.toolTip && this.toolTip.enabled ? this.toolTip.hide() : this.resetOverlayedCanvas();\n                    this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a);\n                }\n        };\n        p.prototype._plotAreaMouseDown = function (a, d) {\n            this.isDrag = !0;\n            this.dragStartPoint =\n                { x: a, y: d };\n        };\n        p.prototype._plotAreaMouseUp = function (a, d) {\n            if ((\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) && this.isDrag) {\n                var b = d - this.dragStartPoint.y, c = a - this.dragStartPoint.x, e = 0 <= this.zoomType.indexOf(\"x\"), g = 0 <= this.zoomType.indexOf(\"y\"), k = !1;\n                this.resetOverlayedCanvas();\n                if (\"xySwapped\" === this.plotInfo.axisPlacement)\n                    var l = g, g = e, e = l;\n                if (this.panEnabled || this.zoomEnabled) {\n                    if (this.panEnabled)\n                        for (e = g = 0; e < this._axes.length; e++)\n                            b = this._axes[e], b.logarithmic ? b.viewportMinimum <\n                                b.minimum ? (g = b.minimum / b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum * g, b.sessionVariables.newViewportMaximum = b.viewportMaximum * g, k = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum / b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum / g, b.sessionVariables.newViewportMaximum = b.viewportMaximum / g, k = !0) : b.viewportMinimum < b.minimum ? (g = b.minimum - b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum + g, b.sessionVariables.newViewportMaximum = b.viewportMaximum +\n                                g, k = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum - b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum - g, b.sessionVariables.newViewportMaximum = b.viewportMaximum - g, k = !0);\n                    else if ((!e || 2 < Math.abs(c)) && (!g || 2 < Math.abs(b)) && this.zoomEnabled) {\n                        if (!this.dragStartPoint)\n                            return;\n                        b = e ? this.dragStartPoint.x : this.plotArea.x1;\n                        c = g ? this.dragStartPoint.y : this.plotArea.y1;\n                        e = e ? a : this.plotArea.x2;\n                        g = g ? d : this.plotArea.y2;\n                        2 < Math.abs(b - e) && 2 < Math.abs(c - g) && this._zoomPanToSelectedRegion(b, c, e, g) && (k = !0);\n                    }\n                    k &&\n                        (this._ignoreNextEvent = !0, this._dispatchRangeEvent(\"rangeChanging\", \"zoom\"), this.render(), this._dispatchRangeEvent(\"rangeChanged\", \"zoom\"), k && (this.zoomEnabled && \"none\" === this._zoomButton.style.display) && (Qa(this._zoomButton, this._resetButton), ua(this, this._zoomButton, \"pan\"), ua(this, this._resetButton, \"reset\")));\n                }\n            }\n            this.isDrag = !1;\n            if (\"none\" !== this.plotInfo.axisPlacement) {\n                this.resetOverlayedCanvas();\n                if (this.axisX && 0 < this.axisX.length)\n                    for (k = 0; k < this.axisX.length; k++)\n                        this.axisX[k].crosshair && this.axisX[k].crosshair.enabled &&\n                            this.axisX[k].renderCrosshair(a, d);\n                if (this.axisX2 && 0 < this.axisX2.length)\n                    for (k = 0; k < this.axisX2.length; k++)\n                        this.axisX2[k].crosshair && this.axisX2[k].crosshair.enabled && this.axisX2[k].renderCrosshair(a, d);\n                if (this.axisY && 0 < this.axisY.length)\n                    for (k = 0; k < this.axisY.length; k++)\n                        this.axisY[k].crosshair && this.axisY[k].crosshair.enabled && this.axisY[k].renderCrosshair(a, d);\n                if (this.axisY2 && 0 < this.axisY2.length)\n                    for (k = 0; k < this.axisY2.length; k++)\n                        this.axisY2[k].crosshair && this.axisY2[k].crosshair.enabled && this.axisY2[k].renderCrosshair(a, d);\n            }\n        };\n        p.prototype._plotAreaMouseMove = function (a, d) {\n            if (this.isDrag && \"none\" !== this.plotInfo.axisPlacement) {\n                var b = 0, c = 0, e = b = null, e = 0 <= this.zoomType.indexOf(\"x\"), g = 0 <= this.zoomType.indexOf(\"y\"), k = this;\n                \"xySwapped\" === this.plotInfo.axisPlacement && (b = g, g = e, e = b);\n                b = this.dragStartPoint.x - a;\n                c = this.dragStartPoint.y - d;\n                2 < Math.abs(b) && 8 > Math.abs(b) && (this.panEnabled || this.zoomEnabled) ? this.toolTip.hide() : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, d);\n                if ((!e || 2 < Math.abs(b) || !g || 2 < Math.abs(c)) &&\n                    (this.panEnabled || this.zoomEnabled))\n                    if (this.panEnabled)\n                        e = { x1: e ? this.plotArea.x1 + b : this.plotArea.x1, y1: g ? this.plotArea.y1 + c : this.plotArea.y1, x2: e ? this.plotArea.x2 + b : this.plotArea.x2, y2: g ? this.plotArea.y2 + c : this.plotArea.y2 }, clearTimeout(k._panTimerId), k._panTimerId = setTimeout(function (c, b, e, f) { return function () { k._zoomPanToSelectedRegion(c, b, e, f, !0) && (k._dispatchRangeEvent(\"rangeChanging\", \"pan\"), k.render(), k._dispatchRangeEvent(\"rangeChanged\", \"pan\"), k.dragStartPoint.x = a, k.dragStartPoint.y = d); }; }(e.x1, e.y1, e.x2, e.y2), 0);\n                    else if (this.zoomEnabled) {\n                        this.resetOverlayedCanvas();\n                        b = this.overlaidCanvasCtx.globalAlpha;\n                        this.overlaidCanvasCtx.fillStyle = \"#A89896\";\n                        var c = e ? this.dragStartPoint.x : this.plotArea.x1, l = g ? this.dragStartPoint.y : this.plotArea.y1, w = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, m = g ? d - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;\n                        this.validateRegion(c, l, e ? a : this.plotArea.x2 - this.plotArea.x1, g ? d : this.plotArea.y2 - this.plotArea.y1, \"xy\" !== this.zoomType).isValid && (this.resetOverlayedCanvas(),\n                            this.overlaidCanvasCtx.fillStyle = \"#99B2B5\");\n                        this.overlaidCanvasCtx.globalAlpha = 0.7;\n                        this.overlaidCanvasCtx.fillRect(c, l, w, m);\n                        this.overlaidCanvasCtx.globalAlpha = b;\n                    }\n            }\n            else if (this.toolTip.mouseMoveHandler(a, d), \"none\" !== this.plotInfo.axisPlacement) {\n                if (this.axisX && 0 < this.axisX.length)\n                    for (e = 0; e < this.axisX.length; e++)\n                        this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a, d);\n                if (this.axisX2 && 0 < this.axisX2.length)\n                    for (e = 0; e < this.axisX2.length; e++)\n                        this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled &&\n                            this.axisX2[e].renderCrosshair(a, d);\n                if (this.axisY && 0 < this.axisY.length)\n                    for (e = 0; e < this.axisY.length; e++)\n                        this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(a, d);\n                if (this.axisY2 && 0 < this.axisY2.length)\n                    for (e = 0; e < this.axisY2.length; e++)\n                        this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a, d);\n            }\n        };\n        p.prototype._zoomPanToSelectedRegion = function (a, d, b, c, e) {\n            a = this.validateRegion(a, d, b, c, e);\n            d = a.axesWithValidRange;\n            b = a.axesRanges;\n            if (a.isValid)\n                for (c =\n                    0; c < d.length; c++)\n                    e = b[c], d[c].setViewPortRange(e.val1, e.val2), this.syncCharts && this.syncCharts(e.val1, e.val2);\n            return a.isValid;\n        };\n        p.prototype.validateRegion = function (a, d, b, c, e) {\n            e = e || !1;\n            for (var g = 0 <= this.zoomType.indexOf(\"x\"), k = 0 <= this.zoomType.indexOf(\"y\"), l = !1, w = [], m = [], s = [], q = 0; q < this._axes.length; q++)\n                (\"axisX\" === this._axes[q].type && g || \"axisY\" === this._axes[q].type && k) && m.push(this._axes[q]);\n            for (k = 0; k < m.length; k++) {\n                var q = m[k], g = !1, n = q.convertPixelToValue({ x: a, y: d }), f = q.convertPixelToValue({ x: b, y: c });\n                if (n > f)\n                    var B = f, f = n, n = B;\n                if (q.scaleBreaks)\n                    for (B = 0; !g && B < q.scaleBreaks._appliedBreaks.length; B++)\n                        g = q.scaleBreaks._appliedBreaks[B].startValue <= n && q.scaleBreaks._appliedBreaks[B].endValue >= f;\n                if (isFinite(q.dataInfo.minDiff))\n                    if (B = q.getApparentDifference(n, f, null, !0), !(g || !(this.panEnabled && q.scaleBreaks && q.scaleBreaks._appliedBreaks.length) && (q.logarithmic && B < Math.pow(q.dataInfo.minDiff, 3) || !q.logarithmic && B < 3 * Math.abs(q.dataInfo.minDiff)) || n < q.minimum || f > q.maximum))\n                        w.push(q), s.push({ val1: n, val2: f }), l =\n                            !0;\n                    else if (!e) {\n                        l = !1;\n                        break;\n                    }\n            }\n            return { isValid: l, axesWithValidRange: w, axesRanges: s };\n        };\n        p.prototype.preparePlotArea = function () {\n            var a = this.plotArea;\n            !r && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);\n            if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {\n                var d = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;\n                if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {\n                    var b = this.axisY[0];\n                    a.x1 = d.x1 < d.x2 ? d.x1 : b.lineCoordinates.x1;\n                    a.y1 = d.y1 < b.lineCoordinates.y1 ? d.y1 : b.lineCoordinates.y1;\n                    a.x2 = d.x2 > b.lineCoordinates.x2 ? d.x2 : b.lineCoordinates.x2;\n                    a.y2 = d.y2 > d.y1 ? d.y2 : b.lineCoordinates.y2;\n                    a.width = a.x2 - a.x1;\n                    a.height = a.y2 - a.y1;\n                }\n                this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (b = this.axisY2[0], a.x1 = d.x1 < d.x2 ? d.x1 : b.lineCoordinates.x1, a.y1 = d.y1 < b.lineCoordinates.y1 ? d.y1 : b.lineCoordinates.y1, a.x2 = d.x2 > b.lineCoordinates.x2 ? d.x2 : b.lineCoordinates.x2, a.y2 = d.y2 > d.y1 ? d.y2 : b.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1);\n            }\n            else\n                d = this.layoutManager.getFreeSpace(), a.x1 = d.x1, a.x2 = d.x2, a.y1 =\n                    d.y1, a.y2 = d.y2, a.width = d.width, a.height = d.height;\n            r || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + \"px\", a.canvas.style.top = a.y1 + \"px\", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1));\n            a.layoutManager = new Ga(a.x1, a.y1, a.x2, a.y2, 2);\n        };\n        p.prototype.renderIndexLabels = function (a) {\n            var d = a || this.plotArea.ctx, b = this.plotArea, c = 0, e = 0, g = 0, k = 0, l = c = k = e = g = 0, w = 0;\n            for (a = 0; a < this._indexLabels.length; a++) {\n                var m = this._indexLabels[a], s = m.chartType.toLowerCase(), q, n, l = na(\"indexLabelFontColor\", m.dataPoint, m.dataSeries), w = na(\"indexLabelFontSize\", m.dataPoint, m.dataSeries);\n                q = na(\"indexLabelFontFamily\", m.dataPoint, m.dataSeries);\n                n = na(\"indexLabelFontStyle\", m.dataPoint, m.dataSeries);\n                var k = na(\"indexLabelFontWeight\", m.dataPoint, m.dataSeries), f = na(\"indexLabelBackgroundColor\", m.dataPoint, m.dataSeries), e = na(\"indexLabelMaxWidth\", m.dataPoint, m.dataSeries), g = na(\"indexLabelWrap\", m.dataPoint, m.dataSeries), B = na(\"indexLabelLineDashType\", m.dataPoint, m.dataSeries), h = na(\"indexLabelLineColor\", m.dataPoint, m.dataSeries), p = u(m.dataPoint.indexLabelLineThickness) ? u(m.dataSeries.options.indexLabelLineThickness) ? 0 : m.dataSeries.options.indexLabelLineThickness : m.dataPoint.indexLabelLineThickness, c = 0 < p ? Math.min(10, (\"normal\" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, t = { percent: null, total: null }, C = null;\n                if (0 <= m.dataSeries.type.indexOf(\"stacked\") || \"pie\" === m.dataSeries.type || \"doughnut\" === m.dataSeries.type)\n                    t = this.getPercentAndTotal(m.dataSeries, m.dataPoint);\n                if (m.dataSeries.indexLabelFormatter ||\n                    m.dataPoint.indexLabelFormatter)\n                    C = { chart: this, dataSeries: m.dataSeries, dataPoint: m.dataPoint, index: m.indexKeyword, total: t.total, percent: t.percent };\n                var x = m.dataPoint.indexLabelFormatter ? m.dataPoint.indexLabelFormatter(C) : m.dataPoint.indexLabel ? this.replaceKeywordsWithValue(m.dataPoint.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : m.dataSeries.indexLabelFormatter ? m.dataSeries.indexLabelFormatter(C) : m.dataSeries.indexLabel ? this.replaceKeywordsWithValue(m.dataSeries.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : null;\n                if (null !== x && \"\" !== x) {\n                    var t = na(\"indexLabelPlacement\", m.dataPoint, m.dataSeries), C = na(\"indexLabelOrientation\", m.dataPoint, m.dataSeries), ma = m.direction, y = m.dataSeries.axisX, A = m.dataSeries.axisY, v = !1, f = new ka(d, { x: 0, y: 0, maxWidth: e ? e : 0.5 * this.width, maxHeight: g ? 5 * w : 1.5 * w, angle: \"horizontal\" === C ? 0 : -90, text: x, padding: 0, backgroundColor: f, horizontalAlign: \"left\", fontSize: w, fontFamily: q, fontWeight: k, fontColor: l, fontStyle: n, textBaseline: \"top\" });\n                    f.measureText();\n                    m.dataSeries.indexLabelMaxWidth =\n                        f.maxWidth;\n                    if (\"stackedarea100\" === s) {\n                        if (m.point.x < b.x1 || m.point.x > b.x2 || m.point.y < b.y1 - 1 || m.point.y > b.y2 + 1)\n                            continue;\n                    }\n                    else if (\"rangearea\" === s || \"rangesplinearea\" === s) {\n                        if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > A.viewportMaximum)\n                            continue;\n                    }\n                    else if (0 <= s.indexOf(\"line\") || 0 <= s.indexOf(\"area\") || 0 <= s.indexOf(\"bubble\") || 0 <= s.indexOf(\"scatter\")) {\n                        if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum ||\n                            m.dataPoint.y < A.viewportMinimum || m.dataPoint.y > A.viewportMaximum)\n                            continue;\n                    }\n                    else if (0 <= s.indexOf(\"column\") || \"waterfall\" === s || \"error\" === s && !m.axisSwapped) {\n                        if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum || m.bounds.y1 > b.y2 || m.bounds.y2 < b.y1)\n                            continue;\n                    }\n                    else if (0 <= s.indexOf(\"bar\") || \"error\" === s) {\n                        if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum || m.bounds.x1 > b.x2 || m.bounds.x2 < b.x1)\n                            continue;\n                    }\n                    else if (\"candlestick\" === s || \"ohlc\" === s) {\n                        if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x >\n                            y.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > A.viewportMaximum)\n                            continue;\n                    }\n                    else if (m.dataPoint.x < y.viewportMinimum || m.dataPoint.x > y.viewportMaximum)\n                        continue;\n                    e = k = 2;\n                    \"horizontal\" === C ? (l = f.width, w = f.height) : (w = f.width, l = f.height);\n                    if (\"normal\" === this.plotInfo.axisPlacement) {\n                        if (0 <= s.indexOf(\"line\") || 0 <= s.indexOf(\"area\"))\n                            t = \"auto\", k = 4;\n                        else if (0 <= s.indexOf(\"stacked\"))\n                            \"auto\" === t && (t = \"inside\");\n                        else if (\"bubble\" === s || \"scatter\" === s)\n                            t = \"inside\";\n                        q = m.point.x -\n                            l / 2;\n                        \"inside\" !== t ? (e = b.y1, g = b.y2, 0 < ma ? (n = m.point.y - w - k - c, n < e && (n = \"auto\" === t ? Math.max(m.point.y, e) + k + c : e + k + c, v = n + w > m.point.y)) : (n = m.point.y + k + c, n > g - w - k - c && (n = \"auto\" === t ? Math.min(m.point.y, g) - w - k - c : g - w - k - c, v = n < m.point.y))) : (e = Math.max(m.bounds.y1, b.y1), g = Math.min(m.bounds.y2, b.y2), c = 0 <= s.indexOf(\"range\") || \"error\" === s ? 0 < ma ? Math.max(m.bounds.y1, b.y1) + w / 2 + k : Math.min(m.bounds.y2, b.y2) - w / 2 - k : (Math.max(m.bounds.y1, b.y1) + Math.min(m.bounds.y2, b.y2)) / 2, 0 < ma ? (n = Math.max(m.point.y, c) - w / 2, n < e && (\"bubble\" === s || \"scatter\" ===\n                            s) && (n = Math.max(m.point.y - w - k, b.y1 + k))) : (n = Math.min(m.point.y, c) - w / 2, n > g - w - k && (\"bubble\" === s || \"scatter\" === s) && (n = Math.min(m.point.y + k, b.y2 - w - k))), n = Math.min(n, g - w));\n                    }\n                    else\n                        0 <= s.indexOf(\"line\") || 0 <= s.indexOf(\"area\") || 0 <= s.indexOf(\"scatter\") ? (t = \"auto\", e = 4) : 0 <= s.indexOf(\"stacked\") ? \"auto\" === t && (t = \"inside\") : \"bubble\" === s && (t = \"inside\"), n = m.point.y - w / 2, \"inside\" !== t ? (k = b.x1, g = b.x2, 0 > ma ? (q = m.point.x - l - e - c, q < k && (q = \"auto\" === t ? Math.max(m.point.x, k) + e + c : k + e + c, v = q + l > m.point.x)) : (q = m.point.x + e + c, q > g - l - e - c && (q = \"auto\" ===\n                            t ? Math.min(m.point.x, g) - l - e - c : g - l - e - c, v = q < m.point.x))) : (k = Math.max(m.bounds.x1, b.x1), Math.min(m.bounds.x2, b.x2), c = 0 <= s.indexOf(\"range\") || \"error\" === s ? 0 > ma ? Math.max(m.bounds.x1, b.x1) + l / 2 + e : Math.min(m.bounds.x2, b.x2) - l / 2 - e : (Math.max(m.bounds.x1, b.x1) + Math.min(m.bounds.x2, b.x2)) / 2, q = 0 > ma ? Math.max(m.point.x, c) - l / 2 : Math.min(m.point.x, c) - l / 2, q = Math.max(q, k));\n                    \"vertical\" === C && (n += w);\n                    f.x = q;\n                    f.y = n;\n                    f.render(!0);\n                    p && (\"inside\" !== t && (0 > s.indexOf(\"bar\") && (\"error\" !== s || !m.axisSwapped) && m.point.x > b.x1 && m.point.x < b.x2 ||\n                        !v) && (0 > s.indexOf(\"column\") && (\"error\" !== s || m.axisSwapped) && m.point.y > b.y1 && m.point.y < b.y2 || !v)) && (d.lineWidth = p, d.strokeStyle = h ? h : \"gray\", d.setLineDash && d.setLineDash(R(B, p)), d.beginPath(), d.moveTo(m.point.x, m.point.y), 0 <= s.indexOf(\"bar\") || \"error\" === s && m.axisSwapped ? d.lineTo(q + (0 < m.direction ? 0 : l), n + (\"horizontal\" === C ? w : -w) / 2) : 0 <= s.indexOf(\"column\") || \"error\" === s && !m.axisSwapped ? d.lineTo(q + l / 2, n + ((0 < m.direction ? w : -w) + (\"horizontal\" === C ? w : -w)) / 2) : d.lineTo(q + l / 2, n + ((n < m.point.y ? w : -w) + (\"horizontal\" === C ? w :\n                        -w)) / 2), d.stroke());\n                }\n            }\n            d = { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 };\n            for (a = 0; a < this._indexLabels.length; a++)\n                m = this._indexLabels[a], f = na(\"indexLabelBackgroundColor\", m.dataPoint, m.dataSeries), m.dataSeries.indexLabelBackgroundColor = u(f) ? r ? \"transparent\" : null : f;\n            return d;\n        };\n        p.prototype.renderLine = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = this._eventManager.ghostCtx;\n                b.save();\n                var e = this.plotArea;\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                for (var g = [], k, l = 0; l < a.dataSeriesIndexes.length; l++) {\n                    var w = a.dataSeriesIndexes[l], m = this.data[w];\n                    b.lineWidth = m.lineThickness;\n                    var s = m.dataPoints, q = \"solid\";\n                    if (b.setLineDash) {\n                        var n = R(m.nullDataLineDashType, m.lineThickness), q = m.lineDashType, f = R(q, m.lineThickness);\n                        b.setLineDash(f);\n                    }\n                    var B = m.id;\n                    this._eventManager.objectMap[B] = { objectType: \"dataSeries\", dataSeriesIndex: w };\n                    B = N(B);\n                    c.strokeStyle = B;\n                    c.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;\n                    var B = m._colorSet, h = B = m.lineColor = m.options.lineColor ? m.options.lineColor : B[0];\n                    b.strokeStyle = B;\n                    var p = !0, t = 0, C, x;\n                    b.beginPath();\n                    if (0 < s.length) {\n                        for (var u = !1, t = 0; t < s.length; t++)\n                            if (C = s[t].x.getTime ? s[t].x.getTime() : s[t].x, !(C < a.axisX.dataInfo.viewPortMin || C > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !u)))\n                                if (\"number\" !== typeof s[t].y)\n                                    0 < t && !(m.connectNullData || u || p) && (b.stroke(), r && c.stroke()), u = !0;\n                                else {\n                                    C = a.axisX.convertValueToPixel(C);\n                                    x =\n                                        a.axisY.convertValueToPixel(s[t].y);\n                                    var y = m.dataPointIds[t];\n                                    this._eventManager.objectMap[y] = { id: y, objectType: \"dataPoint\", dataSeriesIndex: w, dataPointIndex: t, x1: C, y1: x };\n                                    p || u ? (!p && m.connectNullData ? (b.setLineDash && (m.options.nullDataLineDashType || q === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(k.x, k.y), q = m.nullDataLineDashType, b.setLineDash(n)), b.lineTo(C, x), r && c.lineTo(C, x)) : (b.beginPath(), b.moveTo(C, x), r && (c.beginPath(), c.moveTo(C, x))), u = p = !1) : (b.lineTo(C, x), r && c.lineTo(C, x), 0 == t % 500 && (b.stroke(), b.beginPath(), b.moveTo(C, x), r && (c.stroke(), c.beginPath(), c.moveTo(C, x))));\n                                    k = { x: C, y: x };\n                                    t < s.length - 1 && (h !== (s[t].lineColor || B) || q !== (s[t].lineDashType || m.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(C, x), h = s[t].lineColor || B, b.strokeStyle = h, b.setLineDash && (s[t].lineDashType ? (q = s[t].lineDashType, b.setLineDash(R(q, m.lineThickness))) : (q = m.lineDashType, b.setLineDash(f))));\n                                    if (0 < s[t].markerSize || 0 < m.markerSize) {\n                                        var A = m.getMarkerProperties(t, C, x, b);\n                                        g.push(A);\n                                        y = N(y);\n                                        r && g.push({ x: C, y: x, ctx: c, type: A.type, size: A.size, color: y, borderColor: y, borderThickness: A.borderThickness });\n                                    }\n                                    (s[t].indexLabel || m.indexLabel || s[t].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: \"line\", dataPoint: s[t], dataSeries: m, point: { x: C, y: x }, direction: 0 > s[t].y === a.axisY.reversed ? 1 : -1, color: B });\n                                }\n                        b.stroke();\n                        r && c.stroke();\n                    }\n                }\n                ia.drawMarkers(g);\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas &&\n                    b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());\n                b.restore();\n                b.beginPath();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };\n            }\n        };\n        p.prototype.renderStepLine = function (a) {\n            var d = a.targetCanvasCtx ||\n                this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = this._eventManager.ghostCtx;\n                b.save();\n                var e = this.plotArea;\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                for (var g = [], k, l = 0; l < a.dataSeriesIndexes.length; l++) {\n                    var w = a.dataSeriesIndexes[l], m = this.data[w];\n                    b.lineWidth = m.lineThickness;\n                    var s = m.dataPoints, q = \"solid\";\n                    if (b.setLineDash) {\n                        var n = R(m.nullDataLineDashType, m.lineThickness), q = m.lineDashType, f = R(q, m.lineThickness);\n                        b.setLineDash(f);\n                    }\n                    var B = m.id;\n                    this._eventManager.objectMap[B] =\n                        { objectType: \"dataSeries\", dataSeriesIndex: w };\n                    B = N(B);\n                    c.strokeStyle = B;\n                    c.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;\n                    var B = m._colorSet, h = B = m.lineColor = m.options.lineColor ? m.options.lineColor : B[0];\n                    b.strokeStyle = B;\n                    var p = !0, t = 0, C, x;\n                    b.beginPath();\n                    if (0 < s.length) {\n                        for (var u = !1, t = 0; t < s.length; t++)\n                            if (C = s[t].getTime ? s[t].x.getTime() : s[t].x, !(C < a.axisX.dataInfo.viewPortMin || C > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !u)))\n                                if (\"number\" !== typeof s[t].y)\n                                    0 < t && !(m.connectNullData || u || p) && (b.stroke(),\n                                        r && c.stroke()), u = !0;\n                                else {\n                                    var y = x;\n                                    C = a.axisX.convertValueToPixel(C);\n                                    x = a.axisY.convertValueToPixel(s[t].y);\n                                    var A = m.dataPointIds[t];\n                                    this._eventManager.objectMap[A] = { id: A, objectType: \"dataPoint\", dataSeriesIndex: w, dataPointIndex: t, x1: C, y1: x };\n                                    p || u ? (!p && m.connectNullData ? (b.setLineDash && (m.options.nullDataLineDashType || q === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(k.x, k.y), q = m.nullDataLineDashType, b.setLineDash(n)), b.lineTo(C, y), b.lineTo(C, x), r && (c.lineTo(C, y), c.lineTo(C, x))) : (b.beginPath(), b.moveTo(C, x), r && (c.beginPath(), c.moveTo(C, x))), u = p = !1) : (b.lineTo(C, y), r && c.lineTo(C, y), b.lineTo(C, x), r && c.lineTo(C, x), 0 == t % 500 && (b.stroke(), b.beginPath(), b.moveTo(C, x), r && (c.stroke(), c.beginPath(), c.moveTo(C, x))));\n                                    k = { x: C, y: x };\n                                    t < s.length - 1 && (h !== (s[t].lineColor || B) || q !== (s[t].lineDashType || m.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(C, x), h = s[t].lineColor || B, b.strokeStyle = h, b.setLineDash && (s[t].lineDashType ? (q = s[t].lineDashType, b.setLineDash(R(q, m.lineThickness))) :\n                                        (q = m.lineDashType, b.setLineDash(f))));\n                                    if (0 < s[t].markerSize || 0 < m.markerSize)\n                                        y = m.getMarkerProperties(t, C, x, b), g.push(y), A = N(A), r && g.push({ x: C, y: x, ctx: c, type: y.type, size: y.size, color: A, borderColor: A, borderThickness: y.borderThickness });\n                                    (s[t].indexLabel || m.indexLabel || s[t].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stepLine\", dataPoint: s[t], dataSeries: m, point: { x: C, y: x }, direction: 0 > s[t].y === a.axisY.reversed ? 1 : -1, color: B });\n                                }\n                        b.stroke();\n                        r && c.stroke();\n                    }\n                }\n                ia.drawMarkers(g);\n                r &&\n                    (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());\n                b.restore();\n                b.beginPath();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation,\n                    easingFunction: M.easing.linear, animationBase: 0 };\n            }\n        };\n        p.prototype.renderSpline = function (a) {\n            function d(a) {\n                a = v(a, 2);\n                if (0 < a.length) {\n                    c.beginPath();\n                    r && e.beginPath();\n                    c.moveTo(a[0].x, a[0].y);\n                    a[0].newStrokeStyle && (c.strokeStyle = a[0].newStrokeStyle);\n                    a[0].newLineDashArray && c.setLineDash(a[0].newLineDashArray);\n                    r && e.moveTo(a[0].x, a[0].y);\n                    for (var b = 0; b < a.length - 3; b += 3)\n                        if (c.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), r && e.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y),\n                            0 < b && 0 === b % 3E3 || a[b + 3].newStrokeStyle || a[b + 3].newLineDashArray)\n                            c.stroke(), c.beginPath(), c.moveTo(a[b + 3].x, a[b + 3].y), a[b + 3].newStrokeStyle && (c.strokeStyle = a[b + 3].newStrokeStyle), a[b + 3].newLineDashArray && c.setLineDash(a[b + 3].newLineDashArray), r && (e.stroke(), e.beginPath(), e.moveTo(a[b + 3].x, a[b + 3].y));\n                    c.stroke();\n                    r && e.stroke();\n                }\n            }\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var e = this._eventManager.ghostCtx;\n                c.save();\n                var g = this.plotArea;\n                c.beginPath();\n                c.rect(g.x1, g.y1, g.width, g.height);\n                c.clip();\n                for (var k = [], l = 0; l < a.dataSeriesIndexes.length; l++) {\n                    var w = a.dataSeriesIndexes[l], m = this.data[w];\n                    c.lineWidth = m.lineThickness;\n                    var s = m.dataPoints, q = \"solid\";\n                    if (c.setLineDash) {\n                        var n = R(m.nullDataLineDashType, m.lineThickness), q = m.lineDashType, f = R(q, m.lineThickness);\n                        c.setLineDash(f);\n                    }\n                    var B = m.id;\n                    this._eventManager.objectMap[B] = { objectType: \"dataSeries\", dataSeriesIndex: w };\n                    B = N(B);\n                    e.strokeStyle = B;\n                    e.lineWidth = 0 < m.lineThickness ? Math.max(m.lineThickness, 4) : 0;\n                    var B = m._colorSet, h = B = m.lineColor = m.options.lineColor ? m.options.lineColor : B[0];\n                    c.strokeStyle = B;\n                    var p = 0, t, u, x = [];\n                    c.beginPath();\n                    if (0 < s.length)\n                        for (u = !1, p = 0; p < s.length; p++)\n                            if (t = s[p].getTime ? s[p].x.getTime() : s[p].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !u)))\n                                if (\"number\" !== typeof s[p].y)\n                                    0 < p && !u && (m.connectNullData ? c.setLineDash && (0 < x.length && (m.options.nullDataLineDashType || !s[p - 1].lineDashType)) && (x[x.length - 1].newLineDashArray = n, q = m.nullDataLineDashType) : (d(x), x = [])), u = !0;\n                                else {\n                                    t = a.axisX.convertValueToPixel(t);\n                                    u = a.axisY.convertValueToPixel(s[p].y);\n                                    var ma = m.dataPointIds[p];\n                                    this._eventManager.objectMap[ma] = { id: ma, objectType: \"dataPoint\", dataSeriesIndex: w, dataPointIndex: p, x1: t, y1: u };\n                                    x[x.length] = { x: t, y: u };\n                                    p < s.length - 1 && (h !== (s[p].lineColor || B) || q !== (s[p].lineDashType || m.lineDashType)) && (h = s[p].lineColor || B, x[x.length - 1].newStrokeStyle = h, c.setLineDash && (s[p].lineDashType ? (q = s[p].lineDashType, x[x.length - 1].newLineDashArray = R(q, m.lineThickness)) : (q = m.lineDashType, x[x.length -\n                                        1].newLineDashArray = f)));\n                                    if (0 < s[p].markerSize || 0 < m.markerSize) {\n                                        var y = m.getMarkerProperties(p, t, u, c);\n                                        k.push(y);\n                                        ma = N(ma);\n                                        r && k.push({ x: t, y: u, ctx: e, type: y.type, size: y.size, color: ma, borderColor: ma, borderThickness: y.borderThickness });\n                                    }\n                                    (s[p].indexLabel || m.indexLabel || s[p].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: \"spline\", dataPoint: s[p], dataSeries: m, point: { x: t, y: u }, direction: 0 > s[p].y === a.axisY.reversed ? 1 : -1, color: B });\n                                    u = !1;\n                                }\n                    d(x);\n                }\n                ia.drawMarkers(k);\n                r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), e.beginPath());\n                c.restore();\n                c.beginPath();\n                return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear,\n                    animationBase: 0 };\n            }\n        };\n        p.prototype.renderColumn = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = null, e = this.plotArea, g = 0, k, l, w, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0, q = a.axisX.dataInfo.minDiff;\n                isFinite(q) || (q = 0.3 * Math.abs(a.axisX.range));\n                q = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n                this.dataPointMaxWidth && g > s && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, s));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && s < g) && (s = Math.max(this.options.dataPointWidth ?\n                    this.dataPointWidth : -Infinity, g));\n                q < g && (q = g);\n                q > s && (q = s);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n                for (s = 0; s < a.dataSeriesIndexes.length; s++) {\n                    var n = a.dataSeriesIndexes[s], f = this.data[n], B = f.dataPoints;\n                    if (0 < B.length)\n                        for (var p = 5 < q && f.bevelEnabled ? !0 : !1, g = 0; g < B.length; g++)\n                            if (B[g].getTime ? w = B[g].x.getTime() :\n                                w = B[g].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof B[g].y) {\n                                k = a.axisX.convertValueToPixel(w);\n                                l = a.axisY.convertValueToPixel(B[g].y);\n                                k = a.axisX.reversed ? k + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + s) * q << 0 : k - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount + s) * q << 0;\n                                var h = a.axisX.reversed ? k - q << 0 : k + q << 0, t;\n                                0 <= B[g].y ? t = m : (t = l, l = m);\n                                l > t && (c = l, l = t, t = c);\n                                c = B[g].color ? B[g].color : f._colorSet[g % f._colorSet.length];\n                                ea(b, k, l, h, t, c, 0, null, p && 0 <= B[g].y, 0 > B[g].y && p, !1, !1, f.fillOpacity);\n                                c = f.dataPointIds[g];\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g, x1: k, y1: l, x2: h, y2: t };\n                                c = N(c);\n                                r && ea(this._eventManager.ghostCtx, k, l, h, t, c, 0, null, !1, !1, !1, !1);\n                                (B[g].indexLabel || f.indexLabel || B[g].indexLabelFormatter || f.indexLabelFormatter) && this._indexLabels.push({ chartType: \"column\", dataPoint: B[g], dataSeries: f, point: { x: k + (h - k) / 2, y: 0 > B[g].y === a.axisY.reversed ? l : t }, direction: 0 > B[g].y === a.axisY.reversed ? 1 : -1, bounds: { x1: k,\n                                        y1: Math.min(l, t), x2: h, y2: Math.max(l, t) }, color: c });\n                            }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.yScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: m < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : m > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : m };\n            }\n        };\n        p.prototype.renderStackedColumn = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = null, e = this.plotArea, g = [], k = [], l = [], w = [], m = 0, s, q, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ?\n                    this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n                s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;\n                var f = a.axisX.dataInfo.minDiff;\n                isFinite(f) || (f = 0.3 * Math.abs(a.axisX.range));\n                f = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(f) / Math.log(a.axisX.range) : Math.abs(f) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\n                this.dataPointMaxWidth && m > s && (m = Math.min(this.options.dataPointWidth ?\n                    this.dataPointWidth : Infinity, s));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && s < m) && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));\n                f < m && (f = m);\n                f > s && (f = s);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n                for (var B = 0; B < a.dataSeriesIndexes.length; B++) {\n                    var h = a.dataSeriesIndexes[B], p = this.data[h], t = p.dataPoints;\n                    if (0 < t.length) {\n                        var u = 5 < f && p.bevelEnabled ? !0 : !1;\n                        b.strokeStyle = \"#4572A7 \";\n                        for (m = 0; m < t.length; m++)\n                            if (c = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof t[m].y) {\n                                s = a.axisX.convertValueToPixel(c);\n                                var x = s - a.plotType.plotUnits.length * f / 2 + a.index * f << 0, v = x + f << 0, y;\n                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y)\n                                    l[c] = t[m].y + (l[c] ? l[c] : 0), 0 < l[c] && (q = a.axisY.convertValueToPixel(l[c]),\n                                        y = \"undefined\" !== typeof g[c] ? g[c] : n, g[c] = q);\n                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)\n                                    w[c] = t[m].y + (w[c] ? w[c] : 0), y = a.axisY.convertValueToPixel(w[c]), q = \"undefined\" !== typeof k[c] ? k[c] : n, k[c] = y;\n                                else if (q = a.axisY.convertValueToPixel(t[m].y), 0 <= t[m].y) {\n                                    var A = \"undefined\" !== typeof g[c] ? g[c] : 0;\n                                    q -= A;\n                                    y = n - A;\n                                    g[c] = A + (y - q);\n                                }\n                                else\n                                    A = k[c] ? k[c] : 0, y = q + A, q = n + A, k[c] = A + (y - q);\n                                c = t[m].color ? t[m].color : p._colorSet[m % p._colorSet.length];\n                                ea(b, x, q, v, y, c, 0, null, u && 0 <= t[m].y, 0 > t[m].y && u, !1, !1, p.fillOpacity);\n                                c = p.dataPointIds[m];\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: h, dataPointIndex: m, x1: x, y1: q, x2: v, y2: y };\n                                c = N(c);\n                                r && ea(this._eventManager.ghostCtx, x, q, v, y, c, 0, null, !1, !1, !1, !1);\n                                (t[m].indexLabel || p.indexLabel || t[m].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedColumn\", dataPoint: t[m], dataSeries: p, point: { x: s, y: 0 <= t[m].y ? q : y }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: x, y1: Math.min(q, y), x2: v, y2: Math.max(q, y) }, color: c });\n                            }\n                    }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx,\n                    animationCallback: M.yScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n };\n            }\n        };\n        p.prototype.renderStackedColumn100 = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = null, e = this.plotArea, g = [], k = [], l = [], w = [], m = 0, s, q, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth :\n                    this.options.dataPointWidth ? this.dataPointWidth : 1;\n                s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;\n                var f = a.axisX.dataInfo.minDiff;\n                isFinite(f) || (f = 0.3 * Math.abs(a.axisX.range));\n                f = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(f) / Math.log(a.axisX.range) : Math.abs(f) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\n                this.dataPointMaxWidth && m > s && (m = Math.min(this.options.dataPointWidth ?\n                    this.dataPointWidth : Infinity, s));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && s < m) && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));\n                f < m && (f = m);\n                f > s && (f = s);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n                for (var B = 0; B < a.dataSeriesIndexes.length; B++) {\n                    var p = a.dataSeriesIndexes[B], h = this.data[p], t = h.dataPoints;\n                    if (0 < t.length)\n                        for (var u = 5 < f && h.bevelEnabled ? !0 : !1, m = 0; m < t.length; m++)\n                            if (c = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof t[m].y) {\n                                s = a.axisX.convertValueToPixel(c);\n                                q = 0 !== a.dataPointYSums[c] ? 100 * (t[m].y / a.dataPointYSums[c]) : 0;\n                                var x = s - a.plotType.plotUnits.length * f / 2 + a.index * f << 0, v = x + f << 0, y;\n                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y) {\n                                    l[c] = q +\n                                        (\"undefined\" !== typeof l[c] ? l[c] : 0);\n                                    if (0 >= l[c])\n                                        continue;\n                                    q = a.axisY.convertValueToPixel(l[c]);\n                                    y = g[c] ? g[c] : n;\n                                    g[c] = q;\n                                }\n                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)\n                                    w[c] = q + (\"undefined\" !== typeof w[c] ? w[c] : 0), y = a.axisY.convertValueToPixel(w[c]), q = k[c] ? k[c] : n, k[c] = y;\n                                else if (q = a.axisY.convertValueToPixel(q), 0 <= t[m].y) {\n                                    var A = \"undefined\" !== typeof g[c] ? g[c] : 0;\n                                    q -= A;\n                                    y = n - A;\n                                    a.dataSeriesIndexes.length - 1 === B && 1 >= Math.abs(e.y1 - q) && (q = e.y1);\n                                    g[c] = A + (y - q);\n                                }\n                                else\n                                    A = \"undefined\" !== typeof k[c] ?\n                                        k[c] : 0, y = q + A, q = n + A, a.dataSeriesIndexes.length - 1 === B && 1 >= Math.abs(e.y2 - y) && (y = e.y2), k[c] = A + (y - q);\n                                c = t[m].color ? t[m].color : h._colorSet[m % h._colorSet.length];\n                                ea(b, x, q, v, y, c, 0, null, u && 0 <= t[m].y, 0 > t[m].y && u, !1, !1, h.fillOpacity);\n                                c = h.dataPointIds[m];\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: p, dataPointIndex: m, x1: x, y1: q, x2: v, y2: y };\n                                c = N(c);\n                                r && ea(this._eventManager.ghostCtx, x, q, v, y, c, 0, null, !1, !1, !1, !1);\n                                (t[m].indexLabel || h.indexLabel || t[m].indexLabelFormatter || h.indexLabelFormatter) &&\n                                    this._indexLabels.push({ chartType: \"stackedColumn100\", dataPoint: t[m], dataSeries: h, point: { x: s, y: 0 <= t[m].y ? q : y }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: x, y1: Math.min(q, y), x2: v, y2: Math.max(q, y) }, color: c });\n                            }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx &&\n                    this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.yScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n };\n            }\n        };\n        p.prototype.renderBar = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = null, e = this.plotArea, g = 0, k, l, w, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0, q = a.axisX.dataInfo.minDiff;\n                isFinite(q) || (q = 0.3 * Math.abs(a.axisX.range));\n                q = this.options.dataPointWidth ?\n                    this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n                this.dataPointMaxWidth && g > s && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, s));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && s < g) && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g));\n                q < g && (q = g);\n                q > s && (q = s);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n                for (s = 0; s < a.dataSeriesIndexes.length; s++) {\n                    var n = a.dataSeriesIndexes[s], f = this.data[n], B = f.dataPoints;\n                    if (0 < B.length) {\n                        var h = 5 < q && f.bevelEnabled ? !0 : !1;\n                        b.strokeStyle = \"#4572A7 \";\n                        for (g = 0; g < B.length; g++)\n                            if (B[g].getTime ? w = B[g].x.getTime() : w = B[g].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof B[g].y) {\n                                l = a.axisX.convertValueToPixel(w);\n                                k = a.axisY.convertValueToPixel(B[g].y);\n                                l = a.axisX.reversed ? l + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + s) * q << 0 : l - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount + s) * q << 0;\n                                var p = a.axisX.reversed ? l - q << 0 : l + q << 0, t;\n                                0 <= B[g].y ? t = m : (t = k, k = m);\n                                c = B[g].color ? B[g].color : f._colorSet[g % f._colorSet.length];\n                                ea(b, t, l, k, p, c, 0, null, h, !1, !1, !1, f.fillOpacity);\n                                c = f.dataPointIds[g];\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g, x1: t, y1: l, x2: k, y2: p };\n                                c =\n                                    N(c);\n                                r && ea(this._eventManager.ghostCtx, t, l, k, p, c, 0, null, !1, !1, !1, !1);\n                                (B[g].indexLabel || f.indexLabel || B[g].indexLabelFormatter || f.indexLabelFormatter) && this._indexLabels.push({ chartType: \"bar\", dataPoint: B[g], dataSeries: f, point: { x: 0 <= B[g].y ? k : t, y: l + (p - l) / 2 }, direction: 0 > B[g].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(t, k), y1: l, x2: Math.max(t, k), y2: p }, color: c });\n                            }\n                    }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.xScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: m < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : m > a.axisY.bounds.x2 ? a.axisY.bounds.x2 :\n                        m };\n            }\n        };\n        p.prototype.renderStackedBar = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = null, e = this.plotArea, g = [], k = [], l = [], w = [], m = 0, s, q, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n                q = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height <<\n                    0;\n                var f = a.axisX.dataInfo.minDiff;\n                isFinite(f) || (f = 0.3 * Math.abs(a.axisX.range));\n                f = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(f) / Math.log(a.axisX.range) : Math.abs(f) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\n                this.dataPointMaxWidth && m > q && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, q));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && q < m) && (q = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));\n                f <\n                    m && (f = m);\n                f > q && (f = q);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n                for (var B = 0; B < a.dataSeriesIndexes.length; B++) {\n                    var p = a.dataSeriesIndexes[B], h = this.data[p], t = h.dataPoints;\n                    if (0 < t.length) {\n                        var u = 5 < f && h.bevelEnabled ? !0 : !1;\n                        b.strokeStyle = \"#4572A7 \";\n                        for (m = 0; m < t.length; m++)\n                            if (c = t[m].x.getTime ? t[m].x.getTime() :\n                                t[m].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof t[m].y) {\n                                q = a.axisX.convertValueToPixel(c);\n                                var x = q - a.plotType.plotUnits.length * f / 2 + a.index * f << 0, v = x + f << 0, y;\n                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y)\n                                    l[c] = t[m].y + (l[c] ? l[c] : 0), 0 < l[c] && (y = g[c] ? g[c] : n, g[c] = s = a.axisY.convertValueToPixel(l[c]));\n                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)\n                                    w[c] = t[m].y + (w[c] ? w[c] : 0), s = k[c] ?\n                                        k[c] : n, k[c] = y = a.axisY.convertValueToPixel(w[c]);\n                                else if (s = a.axisY.convertValueToPixel(t[m].y), 0 <= t[m].y) {\n                                    var A = g[c] ? g[c] : 0;\n                                    y = n + A;\n                                    s += A;\n                                    g[c] = A + (s - y);\n                                }\n                                else\n                                    A = k[c] ? k[c] : 0, y = s - A, s = n - A, k[c] = A + (s - y);\n                                c = t[m].color ? t[m].color : h._colorSet[m % h._colorSet.length];\n                                ea(b, y, x, s, v, c, 0, null, u, !1, !1, !1, h.fillOpacity);\n                                c = h.dataPointIds[m];\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: p, dataPointIndex: m, x1: y, y1: x, x2: s, y2: v };\n                                c = N(c);\n                                r && ea(this._eventManager.ghostCtx, y, x, s, v, c, 0, null, !1, !1, !1, !1);\n                                (t[m].indexLabel || h.indexLabel || t[m].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedBar\", dataPoint: t[m], dataSeries: h, point: { x: 0 <= t[m].y ? s : y, y: q }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(y, s), y1: x, x2: Math.max(y, s), y2: v }, color: c });\n                            }\n                    }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas &&\n                    b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.xScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n };\n            }\n        };\n        p.prototype.renderStackedBar100 = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = null, e = this.plotArea, g = [], k = [], l = [], w = [], m = 0, s, q, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n                q = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0;\n                var f = a.axisX.dataInfo.minDiff;\n                isFinite(f) ||\n                    (f = 0.3 * Math.abs(a.axisX.range));\n                f = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(f) / Math.log(a.axisX.range) : Math.abs(f) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\n                this.dataPointMaxWidth && m > q && (m = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, q));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && q < m) && (q = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, m));\n                f < m && (f = m);\n                f > q && (f = q);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n                for (var B = 0; B < a.dataSeriesIndexes.length; B++) {\n                    var h = a.dataSeriesIndexes[B], p = this.data[h], t = p.dataPoints;\n                    if (0 < t.length) {\n                        var u = 5 < f && p.bevelEnabled ? !0 : !1;\n                        b.strokeStyle = \"#4572A7 \";\n                        for (m = 0; m < t.length; m++)\n                            if (c = t[m].x.getTime ? t[m].x.getTime() : t[m].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) &&\n                                \"number\" === typeof t[m].y) {\n                                q = a.axisX.convertValueToPixel(c);\n                                var x;\n                                x = 0 !== a.dataPointYSums[c] ? 100 * (t[m].y / a.dataPointYSums[c]) : 0;\n                                var v = q - a.plotType.plotUnits.length * f / 2 + a.index * f << 0, y = v + f << 0;\n                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[m].y) {\n                                    l[c] = x + (l[c] ? l[c] : 0);\n                                    if (0 >= l[c])\n                                        continue;\n                                    x = g[c] ? g[c] : n;\n                                    g[c] = s = a.axisY.convertValueToPixel(l[c]);\n                                }\n                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[m].y)\n                                    w[c] = x + (w[c] ? w[c] : 0), s = k[c] ? k[c] :\n                                        n, k[c] = x = a.axisY.convertValueToPixel(w[c]);\n                                else if (s = a.axisY.convertValueToPixel(x), 0 <= t[m].y) {\n                                    var A = g[c] ? g[c] : 0;\n                                    x = n + A;\n                                    s += A;\n                                    a.dataSeriesIndexes.length - 1 === B && 1 >= Math.abs(e.x2 - s) && (s = e.x2);\n                                    g[c] = A + (s - x);\n                                }\n                                else\n                                    A = k[c] ? k[c] : 0, x = s - A, s = n - A, a.dataSeriesIndexes.length - 1 === B && 1 >= Math.abs(e.x1 - x) && (x = e.x1), k[c] = A + (s - x);\n                                c = t[m].color ? t[m].color : p._colorSet[m % p._colorSet.length];\n                                ea(b, x, v, s, y, c, 0, null, u, !1, !1, !1, p.fillOpacity);\n                                c = p.dataPointIds[m];\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: h,\n                                    dataPointIndex: m, x1: x, y1: v, x2: s, y2: y };\n                                c = N(c);\n                                r && ea(this._eventManager.ghostCtx, x, v, s, y, c, 0, null, !1, !1, !1, !1);\n                                (t[m].indexLabel || p.indexLabel || t[m].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedBar100\", dataPoint: t[m], dataSeries: p, point: { x: 0 <= t[m].y ? s : x, y: q }, direction: 0 > t[m].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(x, s), y1: v, x2: Math.max(x, s), y2: y }, color: c });\n                            }\n                    }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\",\n                    a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.xScaleAnimation, easingFunction: M.easing.easeOutQuart, animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 :\n                        n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n };\n            }\n        };\n        p.prototype.renderArea = function (a) {\n            var d, b;\n            function c() { A && (0 < B.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? y = v : 0 > a.axisY.viewportMaximum ? y = w.y1 : 0 < a.axisY.viewportMinimum && (y = l.y2), g.lineTo(t, y), g.lineTo(A.x, y), g.closePath(), g.globalAlpha = B.fillOpacity, g.fill(), g.globalAlpha = 1, r && (k.lineTo(t, y), k.lineTo(A.x, y), k.closePath(), k.fill()), g.beginPath(), g.moveTo(t, u), k.beginPath(), k.moveTo(t, u), A = { x: t, y: u }); }\n            var e = a.targetCanvasCtx || this.plotArea.ctx, g = r ? this._preRenderCtx : e;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var k = this._eventManager.ghostCtx, l = a.axisX.lineCoordinates, w = a.axisY.lineCoordinates, m = [], s = this.plotArea, q;\n                g.save();\n                r && k.save();\n                g.beginPath();\n                g.rect(s.x1, s.y1, s.width, s.height);\n                g.clip();\n                r && (k.beginPath(), k.rect(s.x1, s.y1, s.width, s.height), k.clip());\n                for (var n = 0; n < a.dataSeriesIndexes.length; n++) {\n                    var f = a.dataSeriesIndexes[n], B = this.data[f], p = B.dataPoints, m = B.id;\n                    this._eventManager.objectMap[m] = { objectType: \"dataSeries\",\n                        dataSeriesIndex: f };\n                    m = N(m);\n                    k.fillStyle = m;\n                    m = [];\n                    d = !0;\n                    var h = 0, t, u, x, v = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), y, A = null;\n                    if (0 < p.length) {\n                        var z = B._colorSet[h % B._colorSet.length], aa = B.lineColor = B.options.lineColor || z, T = aa;\n                        g.fillStyle = z;\n                        g.strokeStyle = aa;\n                        g.lineWidth = B.lineThickness;\n                        b = \"solid\";\n                        if (g.setLineDash) {\n                            var Y = R(B.nullDataLineDashType, B.lineThickness);\n                            b = B.lineDashType;\n                            var ca = R(b, B.lineThickness);\n                            g.setLineDash(ca);\n                        }\n                        for (var da = !0; h < p.length; h++)\n                            if (x = p[h].x.getTime ? p[h].x.getTime() :\n                                p[h].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!B.connectNullData || !da)))\n                                if (\"number\" !== typeof p[h].y)\n                                    B.connectNullData || (da || d) || c(), da = !0;\n                                else {\n                                    t = a.axisX.convertValueToPixel(x);\n                                    u = a.axisY.convertValueToPixel(p[h].y);\n                                    d || da ? (!d && B.connectNullData ? (g.setLineDash && (B.options.nullDataLineDashType || b === B.lineDashType && B.lineDashType !== B.nullDataLineDashType) && (d = t, b = u, t = q.x, u = q.y, c(), g.moveTo(q.x, q.y), t = d, u = b, A = q, b = B.nullDataLineDashType, g.setLineDash(Y)), g.lineTo(t, u), r && k.lineTo(t, u)) : (g.beginPath(), g.moveTo(t, u), r && (k.beginPath(), k.moveTo(t, u)), A = { x: t, y: u }), da = d = !1) : (g.lineTo(t, u), r && k.lineTo(t, u), 0 == h % 250 && c());\n                                    q = { x: t, y: u };\n                                    h < p.length - 1 && (T !== (p[h].lineColor || aa) || b !== (p[h].lineDashType || B.lineDashType)) && (c(), T = p[h].lineColor || aa, g.strokeStyle = T, g.setLineDash && (p[h].lineDashType ? (b = p[h].lineDashType, g.setLineDash(R(b, B.lineThickness))) : (b = B.lineDashType, g.setLineDash(ca))));\n                                    var Z = B.dataPointIds[h];\n                                    this._eventManager.objectMap[Z] = { id: Z, objectType: \"dataPoint\", dataSeriesIndex: f,\n                                        dataPointIndex: h, x1: t, y1: u };\n                                    0 !== p[h].markerSize && (0 < p[h].markerSize || 0 < B.markerSize) && (x = B.getMarkerProperties(h, t, u, g), m.push(x), Z = N(Z), r && m.push({ x: t, y: u, ctx: k, type: x.type, size: x.size, color: Z, borderColor: Z, borderThickness: x.borderThickness }));\n                                    (p[h].indexLabel || B.indexLabel || p[h].indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({ chartType: \"area\", dataPoint: p[h], dataSeries: B, point: { x: t, y: u }, direction: 0 > p[h].y === a.axisY.reversed ? 1 : -1, color: z });\n                                }\n                        c();\n                        ia.drawMarkers(m);\n                    }\n                }\n                r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(s.x1, s.y1, s.width, s.height), this._eventManager.ghostCtx.restore());\n                g.restore();\n                return { source: e, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear,\n                    animationBase: 0 };\n            }\n        };\n        p.prototype.renderSplineArea = function (a) {\n            function d() {\n                var b = v(x, 2);\n                if (0 < b.length) {\n                    if (0 < q.lineThickness) {\n                        c.beginPath();\n                        c.moveTo(b[0].x, b[0].y);\n                        b[0].newStrokeStyle && (c.strokeStyle = b[0].newStrokeStyle);\n                        b[0].newLineDashArray && c.setLineDash(b[0].newLineDashArray);\n                        for (var d = 0; d < b.length - 3; d += 3)\n                            if (c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), r && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle || b[d + 3].newLineDashArray)\n                                c.stroke(),\n                                    c.beginPath(), c.moveTo(b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle && (c.strokeStyle = b[d + 3].newStrokeStyle), b[d + 3].newLineDashArray && c.setLineDash(b[d + 3].newLineDashArray);\n                        c.stroke();\n                    }\n                    c.beginPath();\n                    c.moveTo(b[0].x, b[0].y);\n                    r && (e.beginPath(), e.moveTo(b[0].x, b[0].y));\n                    for (d = 0; d < b.length - 3; d += 3)\n                        c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), r && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y);\n                    a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ?\n                        t = p : 0 > a.axisY.viewportMaximum ? t = k.y1 : 0 < a.axisY.viewportMinimum && (t = g.y2);\n                    u = { x: b[0].x, y: b[0].y };\n                    c.lineTo(b[b.length - 1].x, t);\n                    c.lineTo(u.x, t);\n                    c.closePath();\n                    c.globalAlpha = q.fillOpacity;\n                    c.fill();\n                    c.globalAlpha = 1;\n                    r && (e.lineTo(b[b.length - 1].x, t), e.lineTo(u.x, t), e.closePath(), e.fill());\n                }\n            }\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var e = this._eventManager.ghostCtx, g = a.axisX.lineCoordinates, k = a.axisY.lineCoordinates, l = [], w = this.plotArea;\n                c.save();\n                r &&\n                    e.save();\n                c.beginPath();\n                c.rect(w.x1, w.y1, w.width, w.height);\n                c.clip();\n                r && (e.beginPath(), e.rect(w.x1, w.y1, w.width, w.height), e.clip());\n                for (var m = 0; m < a.dataSeriesIndexes.length; m++) {\n                    var s = a.dataSeriesIndexes[m], q = this.data[s], n = q.dataPoints, l = q.id;\n                    this._eventManager.objectMap[l] = { objectType: \"dataSeries\", dataSeriesIndex: s };\n                    l = N(l);\n                    e.fillStyle = l;\n                    var l = [], f = 0, B, h, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), t, u = null, x = [];\n                    if (0 < n.length) {\n                        var ma = q._colorSet[f % q._colorSet.length], y = q.lineColor = q.options.lineColor || ma, A = y;\n                        c.fillStyle = ma;\n                        c.strokeStyle = y;\n                        c.lineWidth = q.lineThickness;\n                        var z = \"solid\";\n                        if (c.setLineDash) {\n                            var aa = R(q.nullDataLineDashType, q.lineThickness), z = q.lineDashType, T = R(z, q.lineThickness);\n                            c.setLineDash(T);\n                        }\n                        for (h = !1; f < n.length; f++)\n                            if (B = n[f].x.getTime ? n[f].x.getTime() : n[f].x, !(B < a.axisX.dataInfo.viewPortMin || B > a.axisX.dataInfo.viewPortMax && (!q.connectNullData || !h)))\n                                if (\"number\" !== typeof n[f].y)\n                                    0 < f && !h && (q.connectNullData ? c.setLineDash && (0 < x.length && (q.options.nullDataLineDashType ||\n                                        !n[f - 1].lineDashType)) && (x[x.length - 1].newLineDashArray = aa, z = q.nullDataLineDashType) : (d(), x = [])), h = !0;\n                                else {\n                                    B = a.axisX.convertValueToPixel(B);\n                                    h = a.axisY.convertValueToPixel(n[f].y);\n                                    var Y = q.dataPointIds[f];\n                                    this._eventManager.objectMap[Y] = { id: Y, objectType: \"dataPoint\", dataSeriesIndex: s, dataPointIndex: f, x1: B, y1: h };\n                                    x[x.length] = { x: B, y: h };\n                                    f < n.length - 1 && (A !== (n[f].lineColor || y) || z !== (n[f].lineDashType || q.lineDashType)) && (A = n[f].lineColor || y, x[x.length - 1].newStrokeStyle = A, c.setLineDash && (n[f].lineDashType ? (z =\n                                        n[f].lineDashType, x[x.length - 1].newLineDashArray = R(z, q.lineThickness)) : (z = q.lineDashType, x[x.length - 1].newLineDashArray = T)));\n                                    if (0 !== n[f].markerSize && (0 < n[f].markerSize || 0 < q.markerSize)) {\n                                        var ca = q.getMarkerProperties(f, B, h, c);\n                                        l.push(ca);\n                                        Y = N(Y);\n                                        r && l.push({ x: B, y: h, ctx: e, type: ca.type, size: ca.size, color: Y, borderColor: Y, borderThickness: ca.borderThickness });\n                                    }\n                                    (n[f].indexLabel || q.indexLabel || n[f].indexLabelFormatter || q.indexLabelFormatter) && this._indexLabels.push({ chartType: \"splineArea\", dataPoint: n[f], dataSeries: q,\n                                        point: { x: B, y: h }, direction: 0 > n[f].y === a.axisY.reversed ? 1 : -1, color: ma });\n                                    h = !1;\n                                }\n                        d();\n                        ia.drawMarkers(l);\n                    }\n                }\n                r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(w.x1, w.y1, w.width, w.height),\n                    this._eventManager.ghostCtx.restore());\n                c.restore();\n                return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };\n            }\n        };\n        p.prototype.renderStepArea = function (a) {\n            var d, b;\n            function c() {\n                A && (0 < B.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? y = v : 0 > a.axisY.viewportMaximum ? y = w.y1 : 0 < a.axisY.viewportMinimum && (y = l.y2), g.lineTo(t, y), g.lineTo(A.x, y), g.closePath(), g.globalAlpha = B.fillOpacity, g.fill(), g.globalAlpha =\n                    1, r && (k.lineTo(t, y), k.lineTo(A.x, y), k.closePath(), k.fill()), g.beginPath(), g.moveTo(t, u), k.beginPath(), k.moveTo(t, u), A = { x: t, y: u });\n            }\n            var e = a.targetCanvasCtx || this.plotArea.ctx, g = r ? this._preRenderCtx : e;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var k = this._eventManager.ghostCtx, l = a.axisX.lineCoordinates, w = a.axisY.lineCoordinates, m = [], s = this.plotArea, q;\n                g.save();\n                r && k.save();\n                g.beginPath();\n                g.rect(s.x1, s.y1, s.width, s.height);\n                g.clip();\n                r && (k.beginPath(), k.rect(s.x1, s.y1, s.width, s.height), k.clip());\n                for (var n = 0; n < a.dataSeriesIndexes.length; n++) {\n                    var f = a.dataSeriesIndexes[n], B = this.data[f], h = B.dataPoints, m = B.id;\n                    this._eventManager.objectMap[m] = { objectType: \"dataSeries\", dataSeriesIndex: f };\n                    m = N(m);\n                    k.fillStyle = m;\n                    m = [];\n                    d = !0;\n                    var p = 0, t, u, x, v = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), y, A = null;\n                    b = !1;\n                    if (0 < h.length) {\n                        var z = B._colorSet[p % B._colorSet.length], aa = B.lineColor = B.options.lineColor || z, T = aa;\n                        g.fillStyle = z;\n                        g.strokeStyle = aa;\n                        g.lineWidth = B.lineThickness;\n                        var Y = \"solid\";\n                        if (g.setLineDash) {\n                            var ca = R(B.nullDataLineDashType, B.lineThickness), Y = B.lineDashType, da = R(Y, B.lineThickness);\n                            g.setLineDash(da);\n                        }\n                        for (; p < h.length; p++)\n                            if (x = h[p].x.getTime ? h[p].x.getTime() : h[p].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!B.connectNullData || !b))) {\n                                var Z = u;\n                                \"number\" !== typeof h[p].y ? (B.connectNullData || (b || d) || c(), b = !0) : (t = a.axisX.convertValueToPixel(x), u = a.axisY.convertValueToPixel(h[p].y), d || b ? (!d && B.connectNullData ? (g.setLineDash && (B.options.nullDataLineDashType || Y === B.lineDashType && B.lineDashType !== B.nullDataLineDashType) && (d =\n                                    t, b = u, t = q.x, u = q.y, c(), g.moveTo(q.x, q.y), t = d, u = b, A = q, Y = B.nullDataLineDashType, g.setLineDash(ca)), g.lineTo(t, Z), g.lineTo(t, u), r && (k.lineTo(t, Z), k.lineTo(t, u))) : (g.beginPath(), g.moveTo(t, u), r && (k.beginPath(), k.moveTo(t, u)), A = { x: t, y: u }), b = d = !1) : (g.lineTo(t, Z), r && k.lineTo(t, Z), g.lineTo(t, u), r && k.lineTo(t, u), 0 == p % 250 && c()), q = { x: t, y: u }, p < h.length - 1 && (T !== (h[p].lineColor || aa) || Y !== (h[p].lineDashType || B.lineDashType)) && (c(), T = h[p].lineColor || aa, g.strokeStyle = T, g.setLineDash && (h[p].lineDashType ? (Y = h[p].lineDashType,\n                                    g.setLineDash(R(Y, B.lineThickness))) : (Y = B.lineDashType, g.setLineDash(da)))), x = B.dataPointIds[p], this._eventManager.objectMap[x] = { id: x, objectType: \"dataPoint\", dataSeriesIndex: f, dataPointIndex: p, x1: t, y1: u }, 0 !== h[p].markerSize && (0 < h[p].markerSize || 0 < B.markerSize) && (Z = B.getMarkerProperties(p, t, u, g), m.push(Z), x = N(x), r && m.push({ x: t, y: u, ctx: k, type: Z.type, size: Z.size, color: x, borderColor: x, borderThickness: Z.borderThickness })), (h[p].indexLabel || B.indexLabel || h[p].indexLabelFormatter || B.indexLabelFormatter) &&\n                                    this._indexLabels.push({ chartType: \"stepArea\", dataPoint: h[p], dataSeries: B, point: { x: t, y: u }, direction: 0 > h[p].y === a.axisY.reversed ? 1 : -1, color: z }));\n                            }\n                        c();\n                        ia.drawMarkers(m);\n                    }\n                }\n                r && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(s.x1, s.y1, s.width, s.height), this._eventManager.ghostCtx.restore());\n                g.restore();\n                return { source: e, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };\n            }\n        };\n        p.prototype.renderStackedArea = function (a) {\n            function d() {\n                if (!(1 > m.length)) {\n                    for (0 < A.lineThickness && c.stroke(); 0 < m.length;) {\n                        var a = m.pop();\n                        c.lineTo(a.x, a.y);\n                        r && u.lineTo(a.x, a.y);\n                    }\n                    c.closePath();\n                    c.globalAlpha = A.fillOpacity;\n                    c.fill();\n                    c.globalAlpha = 1;\n                    c.beginPath();\n                    r && (u.closePath(),\n                        u.fill(), u.beginPath());\n                    m = [];\n                }\n            }\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var e = null, g = null, k = [], l = this.plotArea, w = [], m = [], s = [], q = [], n = 0, f, h, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), u = this._eventManager.ghostCtx, t, C, x;\n                r && u.beginPath();\n                c.save();\n                r && u.save();\n                c.beginPath();\n                c.rect(l.x1, l.y1, l.width, l.height);\n                c.clip();\n                r && (u.beginPath(), u.rect(l.x1, l.y1, l.width, l.height), u.clip());\n                for (var e = [], v = 0; v < a.dataSeriesIndexes.length; v++) {\n                    var y = a.dataSeriesIndexes[v], A = this.data[y], z = A.dataPoints;\n                    A.dataPointIndexes = [];\n                    for (n = 0; n < z.length; n++)\n                        y = z[n].x.getTime ? z[n].x.getTime() : z[n].x, A.dataPointIndexes[y] = n, e[y] || (s.push(y), e[y] = !0);\n                    s.sort(Sa);\n                }\n                for (v = 0; v < a.dataSeriesIndexes.length; v++) {\n                    y = a.dataSeriesIndexes[v];\n                    A = this.data[y];\n                    z = A.dataPoints;\n                    C = !0;\n                    m = [];\n                    n = A.id;\n                    this._eventManager.objectMap[n] = { objectType: \"dataSeries\", dataSeriesIndex: y };\n                    n = N(n);\n                    u.fillStyle = n;\n                    if (0 < s.length) {\n                        var e = A._colorSet[0], aa = A.lineColor = A.options.lineColor || e, T = aa;\n                        c.fillStyle =\n                            e;\n                        c.strokeStyle = aa;\n                        c.lineWidth = A.lineThickness;\n                        x = \"solid\";\n                        if (c.setLineDash) {\n                            var Y = R(A.nullDataLineDashType, A.lineThickness);\n                            x = A.lineDashType;\n                            var ca = R(x, A.lineThickness);\n                            c.setLineDash(ca);\n                        }\n                        for (var da = !0, n = 0; n < s.length; n++) {\n                            var g = s[n], Z = null, Z = 0 <= A.dataPointIndexes[g] ? z[A.dataPointIndexes[g]] : { x: g, y: null };\n                            if (!(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !da)))\n                                if (\"number\" !== typeof Z.y)\n                                    A.connectNullData || (da || C) || d(), da = !0;\n                                else {\n                                    f = a.axisX.convertValueToPixel(g);\n                                    var oa = w[g] ? w[g] : 0;\n                                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {\n                                        q[g] = Z.y + (q[g] ? q[g] : 0);\n                                        if (0 >= q[g] && a.axisY.logarithmic)\n                                            continue;\n                                        h = a.axisY.convertValueToPixel(q[g]);\n                                    }\n                                    else\n                                        h = a.axisY.convertValueToPixel(Z.y), h -= oa;\n                                    m.push({ x: f, y: p - oa });\n                                    w[g] = p - h;\n                                    C || da ? (!C && A.connectNullData ? (c.setLineDash && (A.options.nullDataLineDashType || x === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (C = m.pop(), x = m[m.length - 1], d(), c.moveTo(t.x, t.y), m.push(x), m.push(C), x = A.nullDataLineDashType,\n                                        c.setLineDash(Y)), c.lineTo(f, h), r && u.lineTo(f, h)) : (c.beginPath(), c.moveTo(f, h), r && (u.beginPath(), u.moveTo(f, h))), da = C = !1) : (c.lineTo(f, h), r && u.lineTo(f, h), 0 == n % 250 && (d(), c.moveTo(f, h), r && u.moveTo(f, h), m.push({ x: f, y: p - oa })));\n                                    t = { x: f, y: h };\n                                    n < z.length - 1 && (T !== (z[n].lineColor || aa) || x !== (z[n].lineDashType || A.lineDashType)) && (d(), c.beginPath(), c.moveTo(f, h), m.push({ x: f, y: p - oa }), T = z[n].lineColor || aa, c.strokeStyle = T, c.setLineDash && (z[n].lineDashType ? (x = z[n].lineDashType, c.setLineDash(R(x, A.lineThickness))) :\n                                        (x = A.lineDashType, c.setLineDash(ca))));\n                                    if (0 <= A.dataPointIndexes[g]) {\n                                        var la = A.dataPointIds[A.dataPointIndexes[g]];\n                                        this._eventManager.objectMap[la] = { id: la, objectType: \"dataPoint\", dataSeriesIndex: y, dataPointIndex: A.dataPointIndexes[g], x1: f, y1: h };\n                                    }\n                                    0 <= A.dataPointIndexes[g] && 0 !== Z.markerSize && (0 < Z.markerSize || 0 < A.markerSize) && (oa = A.getMarkerProperties(A.dataPointIndexes[g], f, h, c), k.push(oa), g = N(la), r && k.push({ x: f, y: h, ctx: u, type: oa.type, size: oa.size, color: g, borderColor: g, borderThickness: oa.borderThickness }));\n                                    (Z.indexLabel || A.indexLabel || Z.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedArea\", dataPoint: Z, dataSeries: A, point: { x: f, y: h }, direction: 0 > z[n].y === a.axisY.reversed ? 1 : -1, color: e });\n                                }\n                        }\n                        d();\n                        c.moveTo(f, h);\n                        r && u.moveTo(f, h);\n                    }\n                    delete A.dataPointIndexes;\n                }\n                ia.drawMarkers(k);\n                r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas &&\n                    c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(l.x1, l.y1, l.width, l.height), u.restore());\n                c.restore();\n                return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };\n            }\n        };\n        p.prototype.renderStackedArea100 = function (a) {\n            function d() {\n                for (0 < A.lineThickness && c.stroke(); 0 < m.length;) {\n                    var a = m.pop();\n                    c.lineTo(a.x, a.y);\n                    r && x.lineTo(a.x, a.y);\n                }\n                c.closePath();\n                c.globalAlpha = A.fillOpacity;\n                c.fill();\n                c.globalAlpha = 1;\n                c.beginPath();\n                r && (x.closePath(), x.fill(), x.beginPath());\n                m = [];\n            }\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var e = null, g = null, k = this.plotArea, l = [], w = [], m = [], s = [], q = [], n = 0, f, h, p, u, t, C = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), x = this._eventManager.ghostCtx;\n                c.save();\n                r && x.save();\n                c.beginPath();\n                c.rect(k.x1, k.y1, k.width, k.height);\n                c.clip();\n                r && (x.beginPath(),\n                    x.rect(k.x1, k.y1, k.width, k.height), x.clip());\n                for (var e = [], v = 0; v < a.dataSeriesIndexes.length; v++) {\n                    var y = a.dataSeriesIndexes[v], A = this.data[y], z = A.dataPoints;\n                    A.dataPointIndexes = [];\n                    for (n = 0; n < z.length; n++)\n                        y = z[n].x.getTime ? z[n].x.getTime() : z[n].x, A.dataPointIndexes[y] = n, e[y] || (s.push(y), e[y] = !0);\n                    s.sort(Sa);\n                }\n                for (v = 0; v < a.dataSeriesIndexes.length; v++) {\n                    y = a.dataSeriesIndexes[v];\n                    A = this.data[y];\n                    z = A.dataPoints;\n                    u = !0;\n                    e = A.id;\n                    this._eventManager.objectMap[e] = { objectType: \"dataSeries\", dataSeriesIndex: y };\n                    e = N(e);\n                    x.fillStyle =\n                        e;\n                    m = [];\n                    if (0 < s.length) {\n                        var e = A._colorSet[n % A._colorSet.length], aa = A.lineColor = A.options.lineColor || e, T = aa;\n                        c.fillStyle = e;\n                        c.strokeStyle = aa;\n                        c.lineWidth = A.lineThickness;\n                        t = \"solid\";\n                        if (c.setLineDash) {\n                            var Y = R(A.nullDataLineDashType, A.lineThickness);\n                            t = A.lineDashType;\n                            var ca = R(t, A.lineThickness);\n                            c.setLineDash(ca);\n                        }\n                        for (var da = !0, n = 0; n < s.length; n++) {\n                            var g = s[n], Z = null, Z = 0 <= A.dataPointIndexes[g] ? z[A.dataPointIndexes[g]] : { x: g, y: null };\n                            if (!(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!A.connectNullData ||\n                                !da)))\n                                if (\"number\" !== typeof Z.y)\n                                    A.connectNullData || (da || u) || d(), da = !0;\n                                else {\n                                    var oa;\n                                    oa = 0 !== a.dataPointYSums[g] ? 100 * (Z.y / a.dataPointYSums[g]) : 0;\n                                    f = a.axisX.convertValueToPixel(g);\n                                    var la = w[g] ? w[g] : 0;\n                                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {\n                                        q[g] = oa + (q[g] ? q[g] : 0);\n                                        if (0 >= q[g] && a.axisY.logarithmic)\n                                            continue;\n                                        h = a.axisY.convertValueToPixel(q[g]);\n                                    }\n                                    else\n                                        h = a.axisY.convertValueToPixel(oa), h -= la;\n                                    m.push({ x: f, y: C - la });\n                                    w[g] = C - h;\n                                    u || da ? (!u && A.connectNullData ? (c.setLineDash &&\n                                        (A.options.nullDataLineDashType || t === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (u = m.pop(), t = m[m.length - 1], d(), c.moveTo(p.x, p.y), m.push(t), m.push(u), t = A.nullDataLineDashType, c.setLineDash(Y)), c.lineTo(f, h), r && x.lineTo(f, h)) : (c.beginPath(), c.moveTo(f, h), r && (x.beginPath(), x.moveTo(f, h))), da = u = !1) : (c.lineTo(f, h), r && x.lineTo(f, h), 0 == n % 250 && (d(), c.moveTo(f, h), r && x.moveTo(f, h), m.push({ x: f, y: C - la })));\n                                    p = { x: f, y: h };\n                                    n < z.length - 1 && (T !== (z[n].lineColor || aa) || t !== (z[n].lineDashType || A.lineDashType)) &&\n                                        (d(), c.beginPath(), c.moveTo(f, h), m.push({ x: f, y: C - la }), T = z[n].lineColor || aa, c.strokeStyle = T, c.setLineDash && (z[n].lineDashType ? (t = z[n].lineDashType, c.setLineDash(R(t, A.lineThickness))) : (t = A.lineDashType, c.setLineDash(ca))));\n                                    if (0 <= A.dataPointIndexes[g]) {\n                                        var G = A.dataPointIds[A.dataPointIndexes[g]];\n                                        this._eventManager.objectMap[G] = { id: G, objectType: \"dataPoint\", dataSeriesIndex: y, dataPointIndex: A.dataPointIndexes[g], x1: f, y1: h };\n                                    }\n                                    0 <= A.dataPointIndexes[g] && 0 !== Z.markerSize && (0 < Z.markerSize || 0 < A.markerSize) && (la =\n                                        A.getMarkerProperties(n, f, h, c), l.push(la), g = N(G), r && l.push({ x: f, y: h, ctx: x, type: la.type, size: la.size, color: g, borderColor: g, borderThickness: la.borderThickness }));\n                                    (Z.indexLabel || A.indexLabel || Z.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedArea100\", dataPoint: Z, dataSeries: A, point: { x: f, y: h }, direction: 0 > z[n].y === a.axisY.reversed ? 1 : -1, color: e });\n                                }\n                        }\n                        d();\n                        c.moveTo(f, h);\n                        r && x.moveTo(f, h);\n                    }\n                    delete A.dataPointIndexes;\n                }\n                ia.drawMarkers(l);\n                r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(k.x1, k.y1, k.width, k.height), x.restore());\n                c.restore();\n                return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };\n            }\n        };\n        p.prototype.renderBubble = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = this.plotArea, e = 0, g, k;\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(c.x1, c.y1, c.width, c.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());\n                for (var l = -Infinity, w = Infinity, m = 0; m < a.dataSeriesIndexes.length; m++)\n                    for (var s = a.dataSeriesIndexes[m], q = this.data[s], n = q.dataPoints, f = 0, e = 0; e < n.length; e++)\n                        g = n[e].getTime ? g = n[e].x.getTime() : g = n[e].x, g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax || \"undefined\" === typeof n[e].z || (f = n[e].z, f > l && (l = f), f < w && (w = f));\n                for (var h = 25 * Math.PI, p = Math.max(Math.pow(0.25 * Math.min(c.height, c.width) / 2, 2) * Math.PI, h), m = 0; m < a.dataSeriesIndexes.length; m++)\n                    if (s = a.dataSeriesIndexes[m], q = this.data[s], n = q.dataPoints, 0 < n.length)\n                        for (b.strokeStyle = \"#4572A7 \", e = 0; e < n.length; e++)\n                            if (g = n[e].getTime ? g = n[e].x.getTime() :\n                                g = n[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof n[e].y) {\n                                g = a.axisX.convertValueToPixel(g);\n                                k = a.axisY.convertValueToPixel(n[e].y);\n                                var f = n[e].z, u = 2 * Math.max(Math.sqrt((l === w ? p / 2 : h + (p - h) / (l - w) * (f - w)) / Math.PI) << 0, 1), f = q.getMarkerProperties(e, b);\n                                f.size = u;\n                                b.globalAlpha = q.fillOpacity;\n                                ia.drawMarker(g, k, b, f.type, f.size, f.color, f.borderColor, f.borderThickness);\n                                b.globalAlpha = 1;\n                                var t = q.dataPointIds[e];\n                                this._eventManager.objectMap[t] = { id: t, objectType: \"dataPoint\", dataSeriesIndex: s,\n                                    dataPointIndex: e, x1: g, y1: k, size: u };\n                                u = N(t);\n                                r && ia.drawMarker(g, k, this._eventManager.ghostCtx, f.type, f.size, u, u, f.borderThickness);\n                                (n[e].indexLabel || q.indexLabel || n[e].indexLabelFormatter || q.indexLabelFormatter) && this._indexLabels.push({ chartType: \"bubble\", dataPoint: n[e], dataSeries: q, point: { x: g, y: k }, direction: 1, bounds: { x1: g - f.size / 2, y1: k - f.size / 2, x2: g + f.size / 2, y2: k + f.size / 2 }, color: null });\n                            }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas &&\n                    b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n            }\n        };\n        p.prototype.renderScatter = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = this.plotArea, e = 0, g, k;\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(c.x1, c.y1, c.width, c.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());\n                for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\n                    var w = a.dataSeriesIndexes[l], m = this.data[w], s = m.dataPoints;\n                    if (0 < s.length) {\n                        b.strokeStyle =\n                            \"#4572A7 \";\n                        Math.pow(0.3 * Math.min(c.height, c.width) / 2, 2);\n                        for (var q = 0, n = 0, e = 0; e < s.length; e++)\n                            if (g = s[e].getTime ? g = s[e].x.getTime() : g = s[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof s[e].y) {\n                                g = a.axisX.convertValueToPixel(g);\n                                k = a.axisY.convertValueToPixel(s[e].y);\n                                var f = m.getMarkerProperties(e, g, k, b);\n                                b.globalAlpha = m.fillOpacity;\n                                ia.drawMarker(f.x, f.y, f.ctx, f.type, f.size, f.color, f.borderColor, f.borderThickness);\n                                b.globalAlpha = 1;\n                                Math.sqrt((q - g) * (q - g) + (n - k) * (n - k)) < Math.min(f.size, 5) && s.length > Math.min(this.plotArea.width, this.plotArea.height) || (q = m.dataPointIds[e], this._eventManager.objectMap[q] = { id: q, objectType: \"dataPoint\", dataSeriesIndex: w, dataPointIndex: e, x1: g, y1: k }, q = N(q), r && ia.drawMarker(f.x, f.y, this._eventManager.ghostCtx, f.type, f.size, q, q, f.borderThickness), (s[e].indexLabel || m.indexLabel || s[e].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: \"scatter\", dataPoint: s[e], dataSeries: m, point: { x: g, y: k }, direction: 1, bounds: { x1: g - f.size / 2, y1: k - f.size /\n                                            2, x2: g + f.size / 2, y2: k + f.size / 2 }, color: null }), q = g, n = k);\n                            }\n                    }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n            }\n        };\n        p.prototype.renderCandlestick = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d, c = this._eventManager.ghostCtx;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var e = null, g = null, k = this.plotArea, l = 0, w, m, s, q, n, f, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ?\n                    this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, h = a.axisX.dataInfo.minDiff;\n                isFinite(h) || (h = 0.3 * Math.abs(a.axisX.range));\n                h = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * k.width * (a.axisX.logarithmic ? Math.log(h) / Math.log(a.axisX.range) : Math.abs(h) / Math.abs(a.axisX.range)) << 0;\n                this.dataPointMaxWidth && e > g && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && g < e) && (g = Math.max(this.options.dataPointWidth ?\n                    this.dataPointWidth : -Infinity, e));\n                h < e && (h = e);\n                h > g && (h = g);\n                b.save();\n                r && c.save();\n                b.beginPath();\n                b.rect(k.x1, k.y1, k.width, k.height);\n                b.clip();\n                r && (c.beginPath(), c.rect(k.x1, k.y1, k.width, k.height), c.clip());\n                for (var p = 0; p < a.dataSeriesIndexes.length; p++) {\n                    var v = a.dataSeriesIndexes[p], t = this.data[v], C = t.dataPoints;\n                    if (0 < C.length)\n                        for (var x = 5 < h && t.bevelEnabled ? !0 : !1, l = 0; l < C.length; l++)\n                            if (C[l].getTime ? f = C[l].x.getTime() : f = C[l].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && !u(C[l].y) && C[l].y.length &&\n                                \"number\" === typeof C[l].y[0] && \"number\" === typeof C[l].y[1] && \"number\" === typeof C[l].y[2] && \"number\" === typeof C[l].y[3]) {\n                                w = a.axisX.convertValueToPixel(f);\n                                m = a.axisY.convertValueToPixel(C[l].y[0]);\n                                s = a.axisY.convertValueToPixel(C[l].y[1]);\n                                q = a.axisY.convertValueToPixel(C[l].y[2]);\n                                n = a.axisY.convertValueToPixel(C[l].y[3]);\n                                var z = w - h / 2 << 0, y = z + h << 0, g = t.options.fallingColor ? t.fallingColor : t._colorSet[0], e = C[l].color ? C[l].color : t._colorSet[0], A = Math.round(Math.max(1, 0.15 * h)), D = 0 === A % 2 ? 0 : 0.5, aa = t.dataPointIds[l];\n                                this._eventManager.objectMap[aa] = { id: aa, objectType: \"dataPoint\", dataSeriesIndex: v, dataPointIndex: l, x1: z, y1: m, x2: y, y2: s, x3: w, y3: q, x4: w, y4: n, borderThickness: A, color: e };\n                                b.strokeStyle = e;\n                                b.beginPath();\n                                b.lineWidth = A;\n                                c.lineWidth = Math.max(A, 4);\n                                \"candlestick\" === t.type ? (b.moveTo(w - D, s), b.lineTo(w - D, Math.min(m, n)), b.stroke(), b.moveTo(w - D, Math.max(m, n)), b.lineTo(w - D, q), b.stroke(), ea(b, z, Math.min(m, n), y, Math.max(m, n), C[l].y[0] <= C[l].y[3] ? t.risingColor : g, A, e, x, x, !1, !1, t.fillOpacity), r && (e = N(aa), c.strokeStyle = e, c.moveTo(w -\n                                    D, s), c.lineTo(w - D, Math.min(m, n)), c.stroke(), c.moveTo(w - D, Math.max(m, n)), c.lineTo(w - D, q), c.stroke(), ea(c, z, Math.min(m, n), y, Math.max(m, n), e, 0, null, !1, !1, !1, !1))) : \"ohlc\" === t.type && (b.moveTo(w - D, s), b.lineTo(w - D, q), b.stroke(), b.beginPath(), b.moveTo(w, m), b.lineTo(z, m), b.stroke(), b.beginPath(), b.moveTo(w, n), b.lineTo(y, n), b.stroke(), r && (e = N(aa), c.strokeStyle = e, c.moveTo(w - D, s), c.lineTo(w - D, q), c.stroke(), c.beginPath(), c.moveTo(w, m), c.lineTo(z, m), c.stroke(), c.beginPath(), c.moveTo(w, n), c.lineTo(y, n), c.stroke()));\n                                (C[l].indexLabel || t.indexLabel || C[l].indexLabelFormatter || t.indexLabelFormatter) && this._indexLabels.push({ chartType: t.type, dataPoint: C[l], dataSeries: t, point: { x: z + (y - z) / 2, y: a.axisY.reversed ? q : s }, direction: 1, bounds: { x1: z, y1: Math.min(s, q), x2: y, y2: Math.max(s, q) }, color: e });\n                            }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(k.x1, k.y1, k.width, k.height), c.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n            }\n        };\n        p.prototype.renderBoxAndWhisker = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d, c = this._eventManager.ghostCtx;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var e = null, g = this.plotArea, k = 0, l, w, m, s, q, n, f, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, k = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, h = a.axisX.dataInfo.minDiff;\n                isFinite(h) || (h = 0.3 * Math.abs(a.axisX.range));\n                h = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * g.width * (a.axisX.logarithmic ? Math.log(h) / Math.log(a.axisX.range) : Math.abs(h) / Math.abs(a.axisX.range)) << 0;\n                this.dataPointMaxWidth &&\n                    e > k && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, k));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && k < e) && (k = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));\n                h < e && (h = e);\n                h > k && (h = k);\n                b.save();\n                r && c.save();\n                b.beginPath();\n                b.rect(g.x1, g.y1, g.width, g.height);\n                b.clip();\n                r && (c.beginPath(), c.rect(g.x1, g.y1, g.width, g.height), c.clip());\n                for (var p = !1, p = !!a.axisY.reversed, v = 0; v < a.dataSeriesIndexes.length; v++) {\n                    var t = a.dataSeriesIndexes[v], C = this.data[t], x = C.dataPoints;\n                    if (0 < x.length)\n                        for (var z = 5 < h && C.bevelEnabled ? !0 : !1, k = 0; k < x.length; k++)\n                            if (x[k].getTime ? f = x[k].x.getTime() : f = x[k].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && !u(x[k].y) && x[k].y.length && \"number\" === typeof x[k].y[0] && \"number\" === typeof x[k].y[1] && \"number\" === typeof x[k].y[2] && \"number\" === typeof x[k].y[3] && \"number\" === typeof x[k].y[4] && 5 === x[k].y.length) {\n                                l = a.axisX.convertValueToPixel(f);\n                                w = a.axisY.convertValueToPixel(x[k].y[0]);\n                                m = a.axisY.convertValueToPixel(x[k].y[1]);\n                                s = a.axisY.convertValueToPixel(x[k].y[2]);\n                                q = a.axisY.convertValueToPixel(x[k].y[3]);\n                                n = a.axisY.convertValueToPixel(x[k].y[4]);\n                                var y = l - h / 2 << 0, A = l + h / 2 << 0, e = x[k].color ? x[k].color : C._colorSet[0], D = Math.round(Math.max(1, 0.15 * h)), aa = 0 === D % 2 ? 0 : 0.5, T = x[k].whiskerColor ? x[k].whiskerColor : x[k].color ? C.whiskerColor ? C.whiskerColor : x[k].color : C.whiskerColor ? C.whiskerColor : e, Y = \"number\" === typeof x[k].whiskerThickness ? x[k].whiskerThickness : \"number\" === typeof C.options.whiskerThickness ? C.whiskerThickness : D, ca = x[k].whiskerDashType ? x[k].whiskerDashType : C.whiskerDashType, da = u(x[k].whiskerLength) ? u(C.options.whiskerLength) ? h : C.whiskerLength : x[k].whiskerLength, da = \"number\" === typeof da ? 0 >= da ? 0 : da >= h ? h : da : \"string\" === typeof da ? parseInt(da) * h / 100 > h ? h : parseInt(da) * h / 100 : h, Z = 1 === Math.round(Y) % 2 ? 0.5 : 0, oa = x[k].stemColor ? x[k].stemColor : x[k].color ? C.stemColor ? C.stemColor : x[k].color : C.stemColor ? C.stemColor : e, la = \"number\" === typeof x[k].stemThickness ? x[k].stemThickness : \"number\" === typeof C.options.stemThickness ? C.stemThickness : D, G = 1 === Math.round(la) % 2 ? 0.5 : 0, F = x[k].stemDashType ? x[k].stemDashType :\n                                    C.stemDashType, E = x[k].lineColor ? x[k].lineColor : x[k].color ? C.lineColor ? C.lineColor : x[k].color : C.lineColor ? C.lineColor : e, H = \"number\" === typeof x[k].lineThickness ? x[k].lineThickness : \"number\" === typeof C.options.lineThickness ? C.lineThickness : D, I = x[k].lineDashType ? x[k].lineDashType : C.lineDashType, K = 1 === Math.round(H) % 2 ? 0.5 : 0, L = C.upperBoxColor, O = C.lowerBoxColor, Q = u(C.options.fillOpacity) ? 1 : C.fillOpacity, P = C.dataPointIds[k];\n                                this._eventManager.objectMap[P] = { id: P, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: k,\n                                    x1: y, y1: w, x2: A, y2: m, x3: l, y3: s, x4: l, y4: q, y5: n, borderThickness: D, color: e, stemThickness: la, stemColor: oa, whiskerThickness: Y, whiskerLength: da, whiskerColor: T, lineThickness: H, lineColor: E };\n                                b.save();\n                                0 < la && (b.beginPath(), b.strokeStyle = oa, b.lineWidth = la, b.setLineDash && b.setLineDash(R(F, la)), b.moveTo(l - G, m), b.lineTo(l - G, w), b.stroke(), b.moveTo(l - G, q), b.lineTo(l - G, s), b.stroke());\n                                b.restore();\n                                c.lineWidth = Math.max(D, 4);\n                                b.beginPath();\n                                ea(b, y, Math.min(n, m), A, Math.max(m, n), O, 0, e, p ? z : !1, p ? !1 : z, !1, !1, Q);\n                                b.beginPath();\n                                ea(b, y, Math.min(s, n), A, Math.max(n, s), L, 0, e, p ? !1 : z, p ? z : !1, !1, !1, Q);\n                                b.beginPath();\n                                b.lineWidth = D;\n                                b.strokeStyle = e;\n                                b.rect(y - aa, Math.min(m, s) - aa, A - y + 2 * aa, Math.max(m, s) - Math.min(m, s) + 2 * aa);\n                                b.stroke();\n                                b.save();\n                                0 < H && (b.beginPath(), b.globalAlpha = 1, b.setLineDash && b.setLineDash(R(I, H)), b.strokeStyle = E, b.lineWidth = H, b.moveTo(y, n - K), b.lineTo(A, n - K), b.stroke());\n                                b.restore();\n                                b.save();\n                                0 < Y && (b.beginPath(), b.setLineDash && b.setLineDash(R(ca, Y)), b.strokeStyle = T, b.lineWidth = Y, b.moveTo(l - da / 2 << 0, q - Z), b.lineTo(l + da / 2 << 0, q - Z),\n                                    b.stroke(), b.moveTo(l - da / 2 << 0, w + Z), b.lineTo(l + da / 2 << 0, w + Z), b.stroke());\n                                b.restore();\n                                r && (e = N(P), c.strokeStyle = e, c.lineWidth = la, 0 < la && (c.moveTo(l - aa - G, m), c.lineTo(l - aa - G, Math.max(w, q)), c.stroke(), c.moveTo(l - aa - G, Math.min(w, q)), c.lineTo(l - aa - G, s), c.stroke()), ea(c, y, Math.max(m, s), A, Math.min(m, s), e, 0, null, !1, !1, !1, !1), 0 < Y && (c.beginPath(), c.lineWidth = Y, c.moveTo(l + da / 2, q - Z), c.lineTo(l - da / 2, q - Z), c.stroke(), c.moveTo(l + da / 2, w + Z), c.lineTo(l - da / 2, w + Z), c.stroke()));\n                                (x[k].indexLabel || C.indexLabel || x[k].indexLabelFormatter ||\n                                    C.indexLabelFormatter) && this._indexLabels.push({ chartType: C.type, dataPoint: x[k], dataSeries: C, point: { x: y + (A - y) / 2, y: a.axisY.reversed ? w : q }, direction: 1, bounds: { x1: y, y1: Math.min(w, q), x2: A, y2: Math.max(w, q) }, color: e });\n                            }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), c.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n            }\n        };\n        p.prototype.renderRangeColumn = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = null, e = this.plotArea, g = 0, k, l, w, g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth :\n                    1;\n                k = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;\n                var m = a.axisX.dataInfo.minDiff;\n                isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));\n                m = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n                this.dataPointMaxWidth && g > k && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, k));\n                !this.dataPointMaxWidth &&\n                    (this.dataPointMinWidth && k < g) && (k = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g));\n                m < g && (m = g);\n                m > k && (m = k);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n                for (var s = 0; s < a.dataSeriesIndexes.length; s++) {\n                    var q = a.dataSeriesIndexes[s], n = this.data[q], f = n.dataPoints;\n                    if (0 < f.length)\n                        for (var h = 5 < m && n.bevelEnabled ? !0 : !1, g = 0; g < f.length; g++)\n                            if (f[g].getTime ? w = f[g].x.getTime() : w = f[g].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && !u(f[g].y) && f[g].y.length && \"number\" === typeof f[g].y[0] && \"number\" === typeof f[g].y[1]) {\n                                c = a.axisX.convertValueToPixel(w);\n                                k = a.axisY.convertValueToPixel(f[g].y[0]);\n                                l = a.axisY.convertValueToPixel(f[g].y[1]);\n                                var p = a.axisX.reversed ? c + a.plotType.totalDataSeries * m / 2 - (a.previousDataSeriesCount + s) * m << 0 : c - a.plotType.totalDataSeries * m / 2 + (a.previousDataSeriesCount +\n                                    s) * m << 0, v = a.axisX.reversed ? p - m << 0 : p + m << 0, c = f[g].color ? f[g].color : n._colorSet[g % n._colorSet.length];\n                                if (k > l) {\n                                    var t = k;\n                                    k = l;\n                                    l = t;\n                                }\n                                t = n.dataPointIds[g];\n                                this._eventManager.objectMap[t] = { id: t, objectType: \"dataPoint\", dataSeriesIndex: q, dataPointIndex: g, x1: p, y1: k, x2: v, y2: l };\n                                ea(b, p, k, v, l, c, 0, c, h, h, !1, !1, n.fillOpacity);\n                                c = N(t);\n                                r && ea(this._eventManager.ghostCtx, p, k, v, l, c, 0, null, !1, !1, !1, !1);\n                                if (f[g].indexLabel || n.indexLabel || f[g].indexLabelFormatter || n.indexLabelFormatter)\n                                    this._indexLabels.push({ chartType: \"rangeColumn\",\n                                        dataPoint: f[g], dataSeries: n, indexKeyword: 0, point: { x: p + (v - p) / 2, y: f[g].y[1] >= f[g].y[0] ? l : k }, direction: f[g].y[1] >= f[g].y[0] ? -1 : 1, bounds: { x1: p, y1: Math.min(k, l), x2: v, y2: Math.max(k, l) }, color: c }), this._indexLabels.push({ chartType: \"rangeColumn\", dataPoint: f[g], dataSeries: n, indexKeyword: 1, point: { x: p + (v - p) / 2, y: f[g].y[1] >= f[g].y[0] ? k : l }, direction: f[g].y[1] >= f[g].y[0] ? 1 : -1, bounds: { x1: p, y1: Math.min(k, l), x2: v, y2: Math.max(k, l) }, color: c });\n                            }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation =\n                    \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n            }\n        };\n        p.prototype.renderError =\n            function (a) {\n                var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d, c = a.axisY._position ? \"left\" === a.axisY._position || \"right\" === a.axisY._position ? !1 : !0 : !1;\n                if (!(0 >= a.dataSeriesIndexes.length)) {\n                    var e = null, g = !1, k = this.plotArea, l = 0, w, m, s, q, n, f, h, p = a.axisX.dataInfo.minDiff;\n                    isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));\n                    b.save();\n                    r && this._eventManager.ghostCtx.save();\n                    b.beginPath();\n                    b.rect(k.x1, k.y1, k.width, k.height);\n                    b.clip();\n                    r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.clip());\n                    for (var v = 0, t = 0; t < this.data.length; t++)\n                        !this.data[t].type.match(/(bar|column)/ig) || !this.data[t].visible || this.data[t].type.match(/(stacked)/ig) && v || v++;\n                    for (var C = 0; C < a.dataSeriesIndexes.length; C++) {\n                        var x = a.dataSeriesIndexes[C], z = this.data[x], y = z.dataPoints, A = u(z._linkedSeries) ? !1 : z._linkedSeries.type.match(/(bar|column)/ig) && z._linkedSeries.visible ? !0 : !1, D = 0;\n                        if (A)\n                            for (e = z._linkedSeries.id, t = 0; t < e; t++)\n                                !this.data[t].type.match(/(bar|column)/ig) ||\n                                    !this.data[t].visible || this.data[t].type.match(/(stacked)/ig) && D || (this.data[t].type.match(/(range)/ig) && (g = !0), D++);\n                        e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n                        l = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? v : 1))) << 0 : 0.3 * this.width;\n                        g && (l = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth :\n                            c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? v : 1))) << 0 : 0.03 * this.width);\n                        t = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((c ? k.height : k.width) * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / (A ? v : 1)) << 0;\n                        this.dataPointMaxWidth && e > l && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, l));\n                        !this.dataPointMaxWidth && (this.dataPointMinWidth && l < e) && (l = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));\n                        t < e &&\n                            (t = e);\n                        t > l && (t = l);\n                        if (0 < y.length)\n                            for (var aa = z._colorSet, l = 0; l < y.length; l++) {\n                                var e = z.lineColor = z.options.color ? z.options.color : aa[0], T = { color: y[l].whiskerColor ? y[l].whiskerColor : y[l].color ? z.whiskerColor ? z.whiskerColor : y[l].color : z.whiskerColor ? z.whiskerColor : e, thickness: u(y[l].whiskerThickness) ? z.whiskerThickness : y[l].whiskerThickness, dashType: y[l].whiskerDashType ? y[l].whiskerDashType : z.whiskerDashType, length: u(y[l].whiskerLength) ? u(z.options.whiskerLength) ? t : z.options.whiskerLength : y[l].whiskerLength,\n                                    trimLength: u(y[l].whiskerLength) ? u(z.options.whiskerLength) ? 50 : 0 : 0 };\n                                T.length = \"number\" === typeof T.length ? 0 >= T.length ? 0 : T.length >= t ? t : T.length : \"string\" === typeof T.length ? parseInt(T.length) * t / 100 > t ? t : parseInt(T.length) * t / 100 > t : t;\n                                T.thickness = \"number\" === typeof T.thickness ? 0 > T.thickness ? 0 : Math.round(T.thickness) : 2;\n                                var Y = { color: y[l].stemColor ? y[l].stemColor : y[l].color ? z.stemColor ? z.stemColor : y[l].color : z.stemColor ? z.stemColor : e, thickness: y[l].stemThickness ? y[l].stemThickness : z.stemThickness, dashType: y[l].stemDashType ?\n                                        y[l].stemDashType : z.stemDashType };\n                                Y.thickness = \"number\" === typeof Y.thickness ? 0 > Y.thickness ? 0 : Math.round(Y.thickness) : 2;\n                                y[l].getTime ? h = y[l].x.getTime() : h = y[l].x;\n                                if (!(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && !u(y[l].y) && y[l].y.length && \"number\" === typeof y[l].y[0] && \"number\" === typeof y[l].y[1]) {\n                                    var ca = a.axisX.convertValueToPixel(h);\n                                    c ? m = ca : w = ca;\n                                    ca = a.axisY.convertValueToPixel(y[l].y[0]);\n                                    c ? s = ca : n = ca;\n                                    ca = a.axisY.convertValueToPixel(y[l].y[1]);\n                                    c ? q = ca : f = ca;\n                                    c ? (n = a.axisX.reversed ? m + (A ? v :\n                                        1) * t / 2 - (A ? D - 1 : 0) * t << 0 : m - (A ? v : 1) * t / 2 + (A ? D - 1 : 0) * t << 0, f = a.axisX.reversed ? n - t << 0 : n + t << 0) : (s = a.axisX.reversed ? w + (A ? v : 1) * t / 2 - (A ? D - 1 : 0) * t << 0 : w - (A ? v : 1) * t / 2 + (A ? D - 1 : 0) * t << 0, q = a.axisX.reversed ? s - t << 0 : s + t << 0);\n                                    !c && n > f && (ca = n, n = f, f = ca);\n                                    c && s > q && (ca = s, s = q, q = ca);\n                                    ca = z.dataPointIds[l];\n                                    this._eventManager.objectMap[ca] = { id: ca, objectType: \"dataPoint\", dataSeriesIndex: x, dataPointIndex: l, x1: Math.min(s, q), y1: Math.min(n, f), x2: Math.max(q, s), y2: Math.max(f, n), isXYSwapped: c, stemProperties: Y, whiskerProperties: T };\n                                    E(b, Math.min(s, q), Math.min(n, f), Math.max(q, s), Math.max(f, n), e, T, Y, c);\n                                    r && E(this._eventManager.ghostCtx, s, n, q, f, e, T, Y, c);\n                                    if (y[l].indexLabel || z.indexLabel || y[l].indexLabelFormatter || z.indexLabelFormatter)\n                                        this._indexLabels.push({ chartType: \"error\", dataPoint: y[l], dataSeries: z, indexKeyword: 0, point: { x: c ? y[l].y[1] >= y[l].y[0] ? s : q : s + (q - s) / 2, y: c ? n + (f - n) / 2 : y[l].y[1] >= y[l].y[0] ? f : n }, direction: y[l].y[1] >= y[l].y[0] ? -1 : 1, bounds: { x1: c ? Math.min(s, q) : s, y1: c ? n : Math.min(n, f), x2: c ? Math.max(s, q) : q, y2: c ? f : Math.max(n, f) }, color: e, axisSwapped: c }),\n                                            this._indexLabels.push({ chartType: \"error\", dataPoint: y[l], dataSeries: z, indexKeyword: 1, point: { x: c ? y[l].y[1] >= y[l].y[0] ? q : s : s + (q - s) / 2, y: c ? n + (f - n) / 2 : y[l].y[1] >= y[l].y[0] ? n : f }, direction: y[l].y[1] >= y[l].y[0] ? 1 : -1, bounds: { x1: c ? Math.min(s, q) : s, y1: c ? n : Math.min(n, f), x2: c ? Math.max(s, q) : q, y2: c ? f : Math.max(n, f) }, color: e, axisSwapped: c });\n                                }\n                            }\n                    }\n                    r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height),\n                        a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());\n                    b.restore();\n                    return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n                }\n            };\n        p.prototype.renderRangeBar = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx :\n                d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = null, e = this.plotArea, g = 0, k, l, w, m, g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n                k = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;\n                var s = a.axisX.dataInfo.minDiff;\n                isFinite(s) || (s = 0.3 * Math.abs(a.axisX.range));\n                s = this.options.dataPointWidth ? this.dataPointWidth : 0.9 *\n                    (e.height * (a.axisX.logarithmic ? Math.log(s) / Math.log(a.axisX.range) : Math.abs(s) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n                this.dataPointMaxWidth && g > k && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, k));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && k < g) && (k = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g));\n                s < g && (s = g);\n                s > k && (s = k);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(e.x1, e.y1, e.width, e.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(),\n                    this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\n                for (var q = 0; q < a.dataSeriesIndexes.length; q++) {\n                    var n = a.dataSeriesIndexes[q], f = this.data[n], h = f.dataPoints;\n                    if (0 < h.length) {\n                        var p = 5 < s && f.bevelEnabled ? !0 : !1;\n                        b.strokeStyle = \"#4572A7 \";\n                        for (g = 0; g < h.length; g++)\n                            if (h[g].getTime ? m = h[g].x.getTime() : m = h[g].x, !(m < a.axisX.dataInfo.viewPortMin || m > a.axisX.dataInfo.viewPortMax) && !u(h[g].y) && h[g].y.length && \"number\" === typeof h[g].y[0] && \"number\" === typeof h[g].y[1]) {\n                                k = a.axisY.convertValueToPixel(h[g].y[0]);\n                                l = a.axisY.convertValueToPixel(h[g].y[1]);\n                                w = a.axisX.convertValueToPixel(m);\n                                w = a.axisX.reversed ? w + a.plotType.totalDataSeries * s / 2 - (a.previousDataSeriesCount + q) * s << 0 : w - a.plotType.totalDataSeries * s / 2 + (a.previousDataSeriesCount + q) * s << 0;\n                                var v = a.axisX.reversed ? w - s << 0 : w + s << 0;\n                                k > l && (c = k, k = l, l = c);\n                                c = h[g].color ? h[g].color : f._colorSet[g % f._colorSet.length];\n                                ea(b, k, w, l, v, c, 0, null, p, !1, !1, !1, f.fillOpacity);\n                                c = f.dataPointIds[g];\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g,\n                                    x1: k, y1: w, x2: l, y2: v };\n                                c = N(c);\n                                r && ea(this._eventManager.ghostCtx, k, w, l, v, c, 0, null, !1, !1, !1, !1);\n                                if (h[g].indexLabel || f.indexLabel || h[g].indexLabelFormatter || f.indexLabelFormatter)\n                                    this._indexLabels.push({ chartType: \"rangeBar\", dataPoint: h[g], dataSeries: f, indexKeyword: 0, point: { x: h[g].y[1] >= h[g].y[0] ? k : l, y: w + (v - w) / 2 }, direction: h[g].y[1] >= h[g].y[0] ? -1 : 1, bounds: { x1: Math.min(k, l), y1: w, x2: Math.max(k, l), y2: v }, color: c }), this._indexLabels.push({ chartType: \"rangeBar\", dataPoint: h[g], dataSeries: f, indexKeyword: 1, point: { x: h[g].y[1] >=\n                                                h[g].y[0] ? l : k, y: w + (v - w) / 2 }, direction: h[g].y[1] >= h[g].y[0] ? 1 : -1, bounds: { x1: Math.min(k, l), y1: w, x2: Math.max(k, l), y2: v }, color: c });\n                            }\n                    }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n            }\n        };\n        p.prototype.renderRangeArea = function (a) {\n            function d() {\n                if (C) {\n                    var a = null;\n                    0 < s.lineThickness && c.stroke();\n                    for (var b = w.length - 1; 0 <= b; b--)\n                        a = w[b], c.lineTo(a.x, a.y), e.lineTo(a.x, a.y);\n                    c.closePath();\n                    c.globalAlpha = s.fillOpacity;\n                    c.fill();\n                    c.globalAlpha = 1;\n                    e.fill();\n                    if (0 < s.lineThickness) {\n                        c.beginPath();\n                        c.moveTo(a.x, a.y);\n                        for (b = 0; b < w.length; b++)\n                            a = w[b], c.lineTo(a.x, a.y);\n                        c.stroke();\n                    }\n                    c.beginPath();\n                    c.moveTo(h, p);\n                    e.beginPath();\n                    e.moveTo(h, p);\n                    C = { x: h, y: p };\n                    w = [];\n                    w.push({ x: h, y: u });\n                }\n            }\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var e = this._eventManager.ghostCtx, g = [], k = this.plotArea;\n                c.save();\n                r && e.save();\n                c.beginPath();\n                c.rect(k.x1, k.y1, k.width, k.height);\n                c.clip();\n                r && (e.beginPath(), e.rect(k.x1, k.y1, k.width, k.height), e.clip());\n                for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\n                    var w = [], m = a.dataSeriesIndexes[l], s = this.data[m], q = s.dataPoints, g = s.id;\n                    this._eventManager.objectMap[g] = { objectType: \"dataSeries\", dataSeriesIndex: m };\n                    g = N(g);\n                    e.fillStyle = g;\n                    var g = [], n = !0, f = 0, h, p, u, t, C = null;\n                    if (0 < q.length) {\n                        var x = s._colorSet[f % s._colorSet.length], v = s.lineColor = s.options.lineColor || x, y = v;\n                        c.fillStyle = x;\n                        c.strokeStyle = v;\n                        c.lineWidth = s.lineThickness;\n                        var A = \"solid\";\n                        if (c.setLineDash) {\n                            var z = R(s.nullDataLineDashType, s.lineThickness), A = s.lineDashType, D = R(A, s.lineThickness);\n                            c.setLineDash(D);\n                        }\n                        for (var T = !0; f <\n                            q.length; f++)\n                            if (t = q[f].x.getTime ? q[f].x.getTime() : q[f].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!s.connectNullData || !T)))\n                                if (null !== q[f].y && q[f].y.length && \"number\" === typeof q[f].y[0] && \"number\" === typeof q[f].y[1]) {\n                                    h = a.axisX.convertValueToPixel(t);\n                                    p = a.axisY.convertValueToPixel(q[f].y[0]);\n                                    u = a.axisY.convertValueToPixel(q[f].y[1]);\n                                    n || T ? (s.connectNullData && !n ? (c.setLineDash && (s.options.nullDataLineDashType || A === s.lineDashType && s.lineDashType !== s.nullDataLineDashType) && (w[w.length -\n                                        1].newLineDashArray = D, A = s.nullDataLineDashType, c.setLineDash(z)), c.lineTo(h, p), r && e.lineTo(h, p), w.push({ x: h, y: u })) : (c.beginPath(), c.moveTo(h, p), C = { x: h, y: p }, w = [], w.push({ x: h, y: u }), r && (e.beginPath(), e.moveTo(h, p))), T = n = !1) : (c.lineTo(h, p), w.push({ x: h, y: u }), r && e.lineTo(h, p), 0 == f % 250 && d());\n                                    t = s.dataPointIds[f];\n                                    this._eventManager.objectMap[t] = { id: t, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: f, x1: h, y1: p, y2: u };\n                                    f < q.length - 1 && (y !== (q[f].lineColor || v) || A !== (q[f].lineDashType || s.lineDashType)) && (d(),\n                                        y = q[f].lineColor || v, w[w.length - 1].newStrokeStyle = y, c.strokeStyle = y, c.setLineDash && (q[f].lineDashType ? (A = q[f].lineDashType, w[w.length - 1].newLineDashArray = R(A, s.lineThickness), c.setLineDash(w[w.length - 1].newLineDashArray)) : (A = s.lineDashType, w[w.length - 1].newLineDashArray = D, c.setLineDash(D))));\n                                    if (0 !== q[f].markerSize && (0 < q[f].markerSize || 0 < s.markerSize)) {\n                                        var Y = s.getMarkerProperties(f, h, u, c);\n                                        g.push(Y);\n                                        var ca = N(t);\n                                        r && g.push({ x: h, y: u, ctx: e, type: Y.type, size: Y.size, color: ca, borderColor: ca, borderThickness: Y.borderThickness });\n                                        Y = s.getMarkerProperties(f, h, p, c);\n                                        g.push(Y);\n                                        ca = N(t);\n                                        r && g.push({ x: h, y: p, ctx: e, type: Y.type, size: Y.size, color: ca, borderColor: ca, borderThickness: Y.borderThickness });\n                                    }\n                                    if (q[f].indexLabel || s.indexLabel || q[f].indexLabelFormatter || s.indexLabelFormatter)\n                                        this._indexLabels.push({ chartType: \"rangeArea\", dataPoint: q[f], dataSeries: s, indexKeyword: 0, point: { x: h, y: p }, direction: q[f].y[0] > q[f].y[1] === a.axisY.reversed ? -1 : 1, color: x }), this._indexLabels.push({ chartType: \"rangeArea\", dataPoint: q[f], dataSeries: s, indexKeyword: 1, point: { x: h,\n                                                y: u }, direction: q[f].y[0] > q[f].y[1] === a.axisY.reversed ? 1 : -1, color: x });\n                                }\n                                else\n                                    T || n || d(), T = !0;\n                        d();\n                        ia.drawMarkers(g);\n                    }\n                }\n                r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());\n                c.restore();\n                return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };\n            }\n        };\n        p.prototype.renderRangeSplineArea = function (a) {\n            function d(a, b) {\n                var d = v(u, 2);\n                if (0 < d.length) {\n                    if (0 < m.lineThickness) {\n                        c.strokeStyle = b;\n                        c.setLineDash && c.setLineDash(a);\n                        c.beginPath();\n                        c.moveTo(d[0].x, d[0].y);\n                        for (var f = 0; f < d.length - 3; f += 3) {\n                            if (d[f].newStrokeStyle || d[f].newLineDashArray)\n                                c.stroke(), c.beginPath(), c.moveTo(d[f].x, d[f].y), d[f].newStrokeStyle && (c.strokeStyle = d[f].newStrokeStyle), d[f].newLineDashArray && c.setLineDash(d[f].newLineDashArray);\n                            c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\n                        }\n                        c.stroke();\n                    }\n                    c.beginPath();\n                    c.moveTo(d[0].x, d[0].y);\n                    r && (e.beginPath(), e.moveTo(d[0].x, d[0].y));\n                    for (f = 0; f < d.length - 3; f += 3)\n                        c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y), r && e.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\n                    d = v(z, 2);\n                    c.lineTo(z[z.length - 1].x, z[z.length -\n                        1].y);\n                    for (f = d.length - 1; 2 < f; f -= 3)\n                        c.bezierCurveTo(d[f - 1].x, d[f - 1].y, d[f - 2].x, d[f - 2].y, d[f - 3].x, d[f - 3].y), r && e.bezierCurveTo(d[f - 1].x, d[f - 1].y, d[f - 2].x, d[f - 2].y, d[f - 3].x, d[f - 3].y);\n                    c.closePath();\n                    c.globalAlpha = m.fillOpacity;\n                    c.fill();\n                    r && (e.closePath(), e.fill());\n                    c.globalAlpha = 1;\n                    if (0 < m.lineThickness) {\n                        c.strokeStyle = b;\n                        c.setLineDash && c.setLineDash(a);\n                        c.beginPath();\n                        c.moveTo(d[0].x, d[0].y);\n                        for (var g = f = 0; f < d.length - 3; f += 3, g++) {\n                            if (u[g].newStrokeStyle || u[g].newLineDashArray)\n                                c.stroke(), c.beginPath(), c.moveTo(d[f].x, d[f].y), u[g].newStrokeStyle && (c.strokeStyle = u[g].newStrokeStyle), u[g].newLineDashArray && c.setLineDash(u[g].newLineDashArray);\n                            c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\n                        }\n                        c.stroke();\n                    }\n                    c.beginPath();\n                }\n            }\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = r ? this._preRenderCtx : b;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var e = this._eventManager.ghostCtx, g = [], k = this.plotArea;\n                c.save();\n                r && e.save();\n                c.beginPath();\n                c.rect(k.x1, k.y1, k.width, k.height);\n                c.clip();\n                r && (e.beginPath(), e.rect(k.x1, k.y1, k.width, k.height), e.clip());\n                for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\n                    var w = a.dataSeriesIndexes[l], m = this.data[w], h = m.dataPoints, g = m.id;\n                    this._eventManager.objectMap[g] = { objectType: \"dataSeries\", dataSeriesIndex: w };\n                    g = N(g);\n                    e.fillStyle = g;\n                    var g = [], q = 0, n, f, p, u = [], z = [];\n                    if (0 < h.length) {\n                        var t = m._colorSet[q % m._colorSet.length], C = m.lineColor = m.options.lineColor || t, x = C;\n                        c.fillStyle = t;\n                        c.lineWidth = m.lineThickness;\n                        var F = \"solid\", y;\n                        if (c.setLineDash) {\n                            var A = R(m.nullDataLineDashType, m.lineThickness), F = m.lineDashType;\n                            y = R(F, m.lineThickness);\n                        }\n                        for (f = !1; q < h.length; q++)\n                            if (n = h[q].x.getTime ? h[q].x.getTime() : h[q].x, !(n < a.axisX.dataInfo.viewPortMin || n > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !f)))\n                                if (null !== h[q].y && h[q].y.length && \"number\" === typeof h[q].y[0] && \"number\" === typeof h[q].y[1]) {\n                                    n = a.axisX.convertValueToPixel(n);\n                                    f = a.axisY.convertValueToPixel(h[q].y[0]);\n                                    p = a.axisY.convertValueToPixel(h[q].y[1]);\n                                    var E = m.dataPointIds[q];\n                                    this._eventManager.objectMap[E] = { id: E, objectType: \"dataPoint\", dataSeriesIndex: w, dataPointIndex: q,\n                                        x1: n, y1: f, y2: p };\n                                    u[u.length] = { x: n, y: f };\n                                    z[z.length] = { x: n, y: p };\n                                    q < h.length - 1 && (x !== (h[q].lineColor || C) || F !== (h[q].lineDashType || m.lineDashType)) && (x = h[q].lineColor || C, u[u.length - 1].newStrokeStyle = x, c.setLineDash && (h[q].lineDashType ? (F = h[q].lineDashType, u[u.length - 1].newLineDashArray = R(F, m.lineThickness)) : (F = m.lineDashType, u[u.length - 1].newLineDashArray = y)));\n                                    if (0 !== h[q].markerSize && (0 < h[q].markerSize || 0 < m.markerSize)) {\n                                        var aa = m.getMarkerProperties(q, n, f, c);\n                                        g.push(aa);\n                                        var T = N(E);\n                                        r && g.push({ x: n, y: f, ctx: e,\n                                            type: aa.type, size: aa.size, color: T, borderColor: T, borderThickness: aa.borderThickness });\n                                        aa = m.getMarkerProperties(q, n, p, c);\n                                        g.push(aa);\n                                        T = N(E);\n                                        r && g.push({ x: n, y: p, ctx: e, type: aa.type, size: aa.size, color: T, borderColor: T, borderThickness: aa.borderThickness });\n                                    }\n                                    if (h[q].indexLabel || m.indexLabel || h[q].indexLabelFormatter || m.indexLabelFormatter)\n                                        this._indexLabels.push({ chartType: \"rangeSplineArea\", dataPoint: h[q], dataSeries: m, indexKeyword: 0, point: { x: n, y: f }, direction: h[q].y[0] <= h[q].y[1] ? -1 : 1, color: t }), this._indexLabels.push({ chartType: \"rangeSplineArea\",\n                                            dataPoint: h[q], dataSeries: m, indexKeyword: 1, point: { x: n, y: p }, direction: h[q].y[0] <= h[q].y[1] ? 1 : -1, color: t });\n                                    f = !1;\n                                }\n                                else\n                                    0 < q && !f && (m.connectNullData ? c.setLineDash && (0 < u.length && (m.options.nullDataLineDashType || !h[q - 1].lineDashType)) && (u[u.length - 1].newLineDashArray = A, F = m.nullDataLineDashType) : (d(y, C), u = [], z = [])), f = !0;\n                        d(y, C);\n                        ia.drawMarkers(g);\n                    }\n                }\n                r && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());\n                c.restore();\n                return { source: b, dest: this.plotArea.ctx, animationCallback: M.xClipAnimation, easingFunction: M.easing.linear, animationBase: 0 };\n            }\n        };\n        p.prototype.renderWaterfall = function (a) {\n            var d = a.targetCanvasCtx || this.plotArea.ctx, b = r ? this._preRenderCtx : d;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var c = this._eventManager.ghostCtx, e = null, g = this.plotArea, k = 0, l, h, m, s, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;\n                h = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;\n                var n = a.axisX.dataInfo.minDiff;\n                isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));\n                n = this.options.dataPointWidth ? this.dataPointWidth : 0.6 * (g.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\n                this.dataPointMaxWidth && k > h && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, h));\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && h < k) && (h = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));\n                n < k && (n = k);\n                n > h && (n = h);\n                b.save();\n                r && this._eventManager.ghostCtx.save();\n                b.beginPath();\n                b.rect(g.x1, g.y1, g.width, g.height);\n                b.clip();\n                r && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip());\n                for (var f = 0; f < a.dataSeriesIndexes.length; f++) {\n                    var p = a.dataSeriesIndexes[f], u = this.data[p], v = u.dataPoints, e = u._colorSet[0];\n                    u.risingColor = u.options.risingColor ? u.options.risingColor : e;\n                    u.fallingColor = u.options.fallingColor ? u.options.fallingColor : \"#e40a0a\";\n                    var t = \"number\" === typeof u.options.lineThickness ? Math.round(u.lineThickness) : 1, C = 1 === Math.round(t) % 2 ? -0.5 : 0;\n                    if (0 < v.length)\n                        for (var x = 5 < n && u.bevelEnabled ? !0 : !1, z = !1, y = null, A = null, k = 0; k < v.length; k++)\n                            if (v[k].getTime ? s = v[k].x.getTime() : s = v[k].x, \"number\" !== typeof v[k].y) {\n                                if (0 < k && !z && u.connectNullData)\n                                    var D = u.options.nullDataLineDashType || !v[k - 1].lineDashType ? u.nullDataLineDashType : v[k - 1].lineDashType;\n                                z = !0;\n                            }\n                            else {\n                                l = a.axisX.convertValueToPixel(s);\n                                h = 0 === u.dataPointEOs[k].cumulativeSum ? q : a.axisY.convertValueToPixel(u.dataPointEOs[k].cumulativeSum);\n                                m = 0 === u.dataPointEOs[k].cumulativeSumYStartValue ? q : a.axisY.convertValueToPixel(u.dataPointEOs[k].cumulativeSumYStartValue);\n                                l = a.axisX.reversed ? l + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + f) * n << 0 : l - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + f) * n << 0;\n                                var F = a.axisX.reversed ? l - n << 0 : l + n << 0;\n                                h > m && (e = h, h = m, m = e);\n                                a.axisY.reversed && (e = h, h = m, m = e);\n                                e = u.dataPointIds[k];\n                                this._eventManager.objectMap[e] = { id: e, objectType: \"dataPoint\", dataSeriesIndex: p, dataPointIndex: k, x1: l, y1: h, x2: F, y2: m };\n                                var T = v[k].color ? v[k].color : 0 < v[k].y ? u.risingColor : u.fallingColor;\n                                ea(b, l, h, F, m, T, 0, T, x, x, !1, !1, u.fillOpacity);\n                                e = N(e);\n                                r && ea(this._eventManager.ghostCtx, l, h, F, m, e, 0, null, !1, !1, !1, !1);\n                                var Y, T = l;\n                                Y = \"undefined\" !== typeof v[k].isIntermediateSum && !0 === v[k].isIntermediateSum || \"undefined\" !== typeof v[k].isCumulativeSum && !0 === v[k].isCumulativeSum ? 0 < v[k].y ? h : m : 0 < v[k].y ? m : h;\n                                0 < k && y && (!z || u.connectNullData) && (z && b.setLineDash && b.setLineDash(R(D, t)), b.beginPath(), b.moveTo(y, A - C), b.lineTo(T, Y - C), 0 < t && b.stroke(), r &&\n                                    (c.beginPath(), c.moveTo(y, A - C), c.lineTo(T, Y - C), 0 < t && c.stroke()));\n                                z = !1;\n                                y = F;\n                                A = 0 < v[k].y ? h : m;\n                                T = v[k].lineDashType ? v[k].lineDashType : u.options.lineDashType ? u.options.lineDashType : \"shortDash\";\n                                b.strokeStyle = v[k].lineColor ? v[k].lineColor : u.options.lineColor ? u.options.lineColor : \"#9e9e9e\";\n                                b.lineWidth = t;\n                                b.setLineDash && (T = R(T, t), b.setLineDash(T));\n                                (v[k].indexLabel || u.indexLabel || v[k].indexLabelFormatter || u.indexLabelFormatter) && this._indexLabels.push({ chartType: \"waterfall\", dataPoint: v[k], dataSeries: u, point: { x: l +\n                                            (F - l) / 2, y: 0 <= v[k].y ? h : m }, direction: 0 > v[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: l, y1: Math.min(h, m), x2: F, y2: Math.max(h, m) }, color: e });\n                            }\n                }\n                r && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height),\n                    b.clearRect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.restore());\n                b.restore();\n                return { source: d, dest: this.plotArea.ctx, animationCallback: M.fadeInAnimation, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n            }\n        };\n        var ja = function (a, d, b, c, e, g, k, l, h) {\n            if (!(0 > b)) {\n                \"undefined\" === typeof l && (l = 1);\n                if (!r) {\n                    var m = Number((k % (2 * Math.PI)).toFixed(8));\n                    Number((g % (2 * Math.PI)).toFixed(8)) === m && (k -= 1E-4);\n                }\n                a.save();\n                a.globalAlpha = l;\n                \"pie\" === e ? (a.beginPath(), a.moveTo(d.x, d.y), a.arc(d.x, d.y, b, g, k, !1), a.fillStyle = c, a.strokeStyle =\n                    \"white\", a.lineWidth = 2, a.closePath(), a.fill()) : \"doughnut\" === e && (a.beginPath(), a.arc(d.x, d.y, b, g, k, !1), 0 <= h && a.arc(d.x, d.y, h * b, k, g, !0), a.closePath(), a.fillStyle = c, a.strokeStyle = \"white\", a.lineWidth = 2, a.fill());\n                a.globalAlpha = 1;\n                a.restore();\n            }\n        };\n        p.prototype.renderPie = function (a) {\n            function d() {\n                if (m && s) {\n                    for (var a = 0, b = 0, c = 0, e = 0, d = 0; d < s.length; d++) {\n                        var g = s[d], l = m.dataPointIds[d];\n                        f[d].id = l;\n                        f[d].objectType = \"dataPoint\";\n                        f[d].dataPointIndex = d;\n                        f[d].dataSeriesIndex = 0;\n                        var k = f[d], q = { percent: null, total: null }, p = null, q = h.getPercentAndTotal(m, g);\n                        if (m.indexLabelFormatter || g.indexLabelFormatter)\n                            p = { chart: h.options, dataSeries: m, dataPoint: g, total: q.total, percent: q.percent };\n                        q = g.indexLabelFormatter ? g.indexLabelFormatter(p) : g.indexLabel ? h.replaceKeywordsWithValue(g.indexLabel, g, m, d) : m.indexLabelFormatter ? m.indexLabelFormatter(p) : m.indexLabel ? h.replaceKeywordsWithValue(m.indexLabel, g, m, d) : g.label ? g.label : \"\";\n                        h._eventManager.objectMap[l] = k;\n                        k.center = { x: x.x, y: x.y };\n                        k.y = g.y;\n                        k.radius = A;\n                        k.percentInnerRadius = F;\n                        k.indexLabelText = q;\n                        k.indexLabelPlacement = m.indexLabelPlacement;\n                        k.indexLabelLineColor = g.indexLabelLineColor ? g.indexLabelLineColor : m.options.indexLabelLineColor ? m.options.indexLabelLineColor : g.color ? g.color : m._colorSet[d % m._colorSet.length];\n                        k.indexLabelLineThickness = u(g.indexLabelLineThickness) ? m.indexLabelLineThickness : g.indexLabelLineThickness;\n                        k.indexLabelLineDashType = g.indexLabelLineDashType ? g.indexLabelLineDashType : m.indexLabelLineDashType;\n                        k.indexLabelFontColor = g.indexLabelFontColor ? g.indexLabelFontColor : m.indexLabelFontColor;\n                        k.indexLabelFontStyle = g.indexLabelFontStyle ?\n                            g.indexLabelFontStyle : m.indexLabelFontStyle;\n                        k.indexLabelFontWeight = g.indexLabelFontWeight ? g.indexLabelFontWeight : m.indexLabelFontWeight;\n                        k.indexLabelFontSize = u(g.indexLabelFontSize) ? m.indexLabelFontSize : g.indexLabelFontSize;\n                        k.indexLabelFontFamily = g.indexLabelFontFamily ? g.indexLabelFontFamily : m.indexLabelFontFamily;\n                        k.indexLabelBackgroundColor = g.indexLabelBackgroundColor ? g.indexLabelBackgroundColor : m.options.indexLabelBackgroundColor ? m.options.indexLabelBackgroundColor : m.indexLabelBackgroundColor;\n                        k.indexLabelMaxWidth =\n                            g.indexLabelMaxWidth ? g.indexLabelMaxWidth : m.indexLabelMaxWidth ? m.indexLabelMaxWidth : 0.33 * n.width;\n                        k.indexLabelWrap = \"undefined\" !== typeof g.indexLabelWrap ? g.indexLabelWrap : m.indexLabelWrap;\n                        k.startAngle = 0 === d ? m.startAngle ? m.startAngle / 180 * Math.PI : 0 : f[d - 1].endAngle;\n                        k.startAngle = (k.startAngle + 2 * Math.PI) % (2 * Math.PI);\n                        k.endAngle = k.startAngle + 2 * Math.PI / z * Math.abs(g.y);\n                        g = (k.endAngle + k.startAngle) / 2;\n                        g = (g + 2 * Math.PI) % (2 * Math.PI);\n                        k.midAngle = g;\n                        if (k.midAngle > Math.PI / 2 - t && k.midAngle < Math.PI / 2 + t) {\n                            if (0 === a || f[c].midAngle >\n                                k.midAngle)\n                                c = d;\n                            a++;\n                        }\n                        else if (k.midAngle > 3 * Math.PI / 2 - t && k.midAngle < 3 * Math.PI / 2 + t) {\n                            if (0 === b || f[e].midAngle > k.midAngle)\n                                e = d;\n                            b++;\n                        }\n                        k.hemisphere = g > Math.PI / 2 && g <= 3 * Math.PI / 2 ? \"left\" : \"right\";\n                        k.indexLabelTextBlock = new ka(h.plotArea.ctx, { fontSize: k.indexLabelFontSize, fontFamily: k.indexLabelFontFamily, fontColor: k.indexLabelFontColor, fontStyle: k.indexLabelFontStyle, fontWeight: k.indexLabelFontWeight, horizontalAlign: \"left\", backgroundColor: k.indexLabelBackgroundColor, maxWidth: k.indexLabelMaxWidth, maxHeight: k.indexLabelWrap ?\n                                5 * k.indexLabelFontSize : 1.5 * k.indexLabelFontSize, text: k.indexLabelText, padding: 0, textBaseline: \"top\" });\n                        k.indexLabelTextBlock.measureText();\n                    }\n                    l = g = 0;\n                    q = !1;\n                    for (d = 0; d < s.length; d++)\n                        k = f[(c + d) % s.length], 1 < a && (k.midAngle > Math.PI / 2 - t && k.midAngle < Math.PI / 2 + t) && (g <= a / 2 && !q ? (k.hemisphere = \"right\", g++) : (k.hemisphere = \"left\", q = !0));\n                    q = !1;\n                    for (d = 0; d < s.length; d++)\n                        k = f[(e + d) % s.length], 1 < b && (k.midAngle > 3 * Math.PI / 2 - t && k.midAngle < 3 * Math.PI / 2 + t) && (l <= b / 2 && !q ? (k.hemisphere = \"left\", l++) : (k.hemisphere = \"right\", q = !0));\n                }\n            }\n            function b(a) {\n                var b = h.plotArea.ctx;\n                b.clearRect(n.x1, n.y1, n.width, n.height);\n                b.fillStyle = h.backgroundColor;\n                b.fillRect(n.x1, n.y1, n.width, n.height);\n                for (b = 0; b < s.length; b++) {\n                    var c = f[b].startAngle, e = f[b].endAngle;\n                    if (e > c) {\n                        var d = 0.07 * A * Math.cos(f[b].midAngle), g = 0.07 * A * Math.sin(f[b].midAngle), k = !1;\n                        if (s[b].exploded) {\n                            if (1E-9 < Math.abs(f[b].center.x - (x.x + d)) || 1E-9 < Math.abs(f[b].center.y - (x.y + g)))\n                                f[b].center.x = x.x + d * a, f[b].center.y = x.y + g * a, k = !0;\n                        }\n                        else if (0 < Math.abs(f[b].center.x - x.x) || 0 < Math.abs(f[b].center.y - x.y))\n                            f[b].center.x = x.x +\n                                d * (1 - a), f[b].center.y = x.y + g * (1 - a), k = !0;\n                        k && (d = {}, d.dataSeries = m, d.dataPoint = m.dataPoints[b], d.index = b, h.toolTip.highlightObjects([d]));\n                        ja(h.plotArea.ctx, f[b].center, f[b].radius, s[b].color ? s[b].color : m._colorSet[b % m._colorSet.length], m.type, c, e, m.fillOpacity, f[b].percentInnerRadius);\n                    }\n                }\n                a = h.plotArea.ctx;\n                a.save();\n                a.fillStyle = \"black\";\n                a.strokeStyle = \"grey\";\n                a.textBaseline = \"middle\";\n                a.lineJoin = \"round\";\n                for (b = b = 0; b < s.length; b++)\n                    c = f[b], c.indexLabelText && (c.indexLabelTextBlock.y -= c.indexLabelTextBlock.height / 2, e =\n                        0, e = \"left\" === c.hemisphere ? \"inside\" !== m.indexLabelPlacement ? -(c.indexLabelTextBlock.width + q) : -c.indexLabelTextBlock.width / 2 : \"inside\" !== m.indexLabelPlacement ? q : -c.indexLabelTextBlock.width / 2, c.indexLabelTextBlock.x += e, c.indexLabelTextBlock.render(!0), c.indexLabelTextBlock.x -= e, c.indexLabelTextBlock.y += c.indexLabelTextBlock.height / 2, \"inside\" !== c.indexLabelPlacement && 0 < c.indexLabelLineThickness && (e = c.center.x + A * Math.cos(c.midAngle), d = c.center.y + A * Math.sin(c.midAngle), a.strokeStyle = c.indexLabelLineColor,\n                        a.lineWidth = c.indexLabelLineThickness, a.setLineDash && a.setLineDash(R(c.indexLabelLineDashType, c.indexLabelLineThickness)), a.beginPath(), a.moveTo(e, d), a.lineTo(c.indexLabelTextBlock.x, c.indexLabelTextBlock.y), a.lineTo(c.indexLabelTextBlock.x + (\"left\" === c.hemisphere ? -q : q), c.indexLabelTextBlock.y), a.stroke()), a.lineJoin = \"miter\");\n                a.save();\n            }\n            function c(a, b) {\n                var c = 0, c = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2, e = a.indexLabelTextBlock.y + a.indexLabelTextBlock.height / 2, d = b.indexLabelTextBlock.y - b.indexLabelTextBlock.height /\n                    2, f = b.indexLabelTextBlock.y + b.indexLabelTextBlock.height / 2;\n                return c = b.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? d - e : c - f;\n            }\n            function e(a) { for (var b = null, e = 1; e < s.length; e++)\n                if (b = (a + e + f.length) % f.length, f[b].hemisphere !== f[a].hemisphere) {\n                    b = null;\n                    break;\n                }\n                else if (f[b].indexLabelText && b !== a && (0 > c(f[b], f[a]) || (\"right\" === f[a].hemisphere ? f[b].indexLabelTextBlock.y >= f[a].indexLabelTextBlock.y : f[b].indexLabelTextBlock.y <= f[a].indexLabelTextBlock.y)))\n                    break;\n                else\n                    b = null; return b; }\n            function g(a, b, d) {\n                d = (d || 0) + 1;\n                if (1E3 <\n                    d)\n                    return 0;\n                b = b || 0;\n                var k = 0, m = x.y - 1 * r, l = x.y + 1 * r;\n                if (0 <= a && a < s.length) {\n                    var n = f[a];\n                    if (0 > b && n.indexLabelTextBlock.y < m || 0 < b && n.indexLabelTextBlock.y > l)\n                        return 0;\n                    var h = 0, q = 0, q = h = h = 0;\n                    0 > b ? n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2 > m && n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2 + b < m && (b = -(m - (n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2 + b))) : n.indexLabelTextBlock.y + n.indexLabelTextBlock.height / 2 < m && n.indexLabelTextBlock.y + n.indexLabelTextBlock.height / 2 + b > l && (b = n.indexLabelTextBlock.y +\n                        n.indexLabelTextBlock.height / 2 + b - l);\n                    b = n.indexLabelTextBlock.y + b;\n                    m = 0;\n                    m = \"right\" === n.hemisphere ? x.x + Math.sqrt(Math.pow(r, 2) - Math.pow(b - x.y, 2)) : x.x - Math.sqrt(Math.pow(r, 2) - Math.pow(b - x.y, 2));\n                    q = x.x + A * Math.cos(n.midAngle);\n                    h = x.y + A * Math.sin(n.midAngle);\n                    h = Math.sqrt(Math.pow(m - q, 2) + Math.pow(b - h, 2));\n                    q = Math.acos(A / r);\n                    h = Math.acos((r * r + A * A - h * h) / (2 * A * r));\n                    b = h < q ? b - n.indexLabelTextBlock.y : 0;\n                    m = null;\n                    for (l = 1; l < s.length; l++)\n                        if (m = (a - l + f.length) % f.length, f[m].hemisphere !== f[a].hemisphere) {\n                            m = null;\n                            break;\n                        }\n                        else if (f[m].indexLabelText &&\n                            f[m].hemisphere === f[a].hemisphere && m !== a && (0 > c(f[m], f[a]) || (\"right\" === f[a].hemisphere ? f[m].indexLabelTextBlock.y <= f[a].indexLabelTextBlock.y : f[m].indexLabelTextBlock.y >= f[a].indexLabelTextBlock.y)))\n                            break;\n                        else\n                            m = null;\n                    q = m;\n                    h = e(a);\n                    l = m = 0;\n                    0 > b ? (l = \"right\" === n.hemisphere ? q : h, k = b, null !== l && (q = -b, b = n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2 - (f[l].indexLabelTextBlock.y + f[l].indexLabelTextBlock.height / 2), b - q < p && (m = -q, l = g(l, m, d + 1), +l.toFixed(C) > +m.toFixed(C) && (k = b > p ? -(b - p) : -(q - (l - m)))))) : 0 < b && (l = \"right\" ===\n                        n.hemisphere ? h : q, k = b, null !== l && (q = b, b = f[l].indexLabelTextBlock.y - f[l].indexLabelTextBlock.height / 2 - (n.indexLabelTextBlock.y + n.indexLabelTextBlock.height / 2), b - q < p && (m = q, l = g(l, m, d + 1), +l.toFixed(C) < +m.toFixed(C) && (k = b > p ? b - p : q - (m - l)))));\n                    k && (d = n.indexLabelTextBlock.y + k, b = 0, b = \"right\" === n.hemisphere ? x.x + Math.sqrt(Math.pow(r, 2) - Math.pow(d - x.y, 2)) : x.x - Math.sqrt(Math.pow(r, 2) - Math.pow(d - x.y, 2)), n.midAngle > Math.PI / 2 - t && n.midAngle < Math.PI / 2 + t ? (m = (a - 1 + f.length) % f.length, m = f[m], a = f[(a + 1 + f.length) % f.length], \"left\" ===\n                        n.hemisphere && \"right\" === m.hemisphere && b > m.indexLabelTextBlock.x ? b = m.indexLabelTextBlock.x - 15 : \"right\" === n.hemisphere && (\"left\" === a.hemisphere && b < a.indexLabelTextBlock.x) && (b = a.indexLabelTextBlock.x + 15)) : n.midAngle > 3 * Math.PI / 2 - t && n.midAngle < 3 * Math.PI / 2 + t && (m = (a - 1 + f.length) % f.length, m = f[m], a = f[(a + 1 + f.length) % f.length], \"right\" === n.hemisphere && \"left\" === m.hemisphere && b < m.indexLabelTextBlock.x ? b = m.indexLabelTextBlock.x + 15 : \"left\" === n.hemisphere && (\"right\" === a.hemisphere && b > a.indexLabelTextBlock.x) && (b = a.indexLabelTextBlock.x -\n                        15)), n.indexLabelTextBlock.y = d, n.indexLabelTextBlock.x = b, n.indexLabelAngle = Math.atan2(n.indexLabelTextBlock.y - x.y, n.indexLabelTextBlock.x - x.x));\n                }\n                return k;\n            }\n            function k() {\n                var a = h.plotArea.ctx;\n                a.fillStyle = \"grey\";\n                a.strokeStyle = \"grey\";\n                a.font = \"16px Arial\";\n                a.textBaseline = \"middle\";\n                for (var b = a = 0, d = 0, k = !0, b = 0; 10 > b && (1 > b || 0 < d); b++) {\n                    if (m.radius || !m.radius && \"undefined\" !== typeof m.innerRadius && null !== m.innerRadius && A - d <= D)\n                        k = !1;\n                    k && (A -= d);\n                    d = 0;\n                    if (\"inside\" !== m.indexLabelPlacement) {\n                        r = A * v;\n                        for (a = 0; a < s.length; a++) {\n                            var l = f[a];\n                            l.indexLabelTextBlock.x = x.x + r * Math.cos(l.midAngle);\n                            l.indexLabelTextBlock.y = x.y + r * Math.sin(l.midAngle);\n                            l.indexLabelAngle = l.midAngle;\n                            l.radius = A;\n                            l.percentInnerRadius = F;\n                        }\n                        for (var t, u, a = 0; a < s.length; a++) {\n                            var l = f[a], y = e(a);\n                            if (null !== y) {\n                                t = f[a];\n                                u = f[y];\n                                var z = 0, z = c(t, u) - p;\n                                if (0 > z) {\n                                    for (var E = u = 0, H = 0; H < s.length; H++)\n                                        H !== a && f[H].hemisphere === l.hemisphere && (f[H].indexLabelTextBlock.y < l.indexLabelTextBlock.y ? u++ : E++);\n                                    u = z / (u + E || 1) * E;\n                                    var E = -1 * (z - u), I = H = 0;\n                                    \"right\" === l.hemisphere ? (H = g(a, u), E = -1 * (z - H), I = g(y, E), +I.toFixed(C) <\n                                        +E.toFixed(C) && +H.toFixed(C) <= +u.toFixed(C) && g(a, -(E - I))) : (H = g(y, u), E = -1 * (z - H), I = g(a, E), +I.toFixed(C) < +E.toFixed(C) && +H.toFixed(C) <= +u.toFixed(C) && g(y, -(E - I)));\n                                }\n                            }\n                        }\n                    }\n                    else\n                        for (a = 0; a < s.length; a++)\n                            l = f[a], r = \"pie\" === m.type ? 0.7 * A : 0.8 * A, y = x.x + r * Math.cos(l.midAngle), u = x.y + r * Math.sin(l.midAngle), l.indexLabelTextBlock.x = y, l.indexLabelTextBlock.y = u;\n                    for (a = 0; a < s.length; a++)\n                        if (l = f[a], y = l.indexLabelTextBlock.measureText(), 0 !== y.height && 0 !== y.width)\n                            y = y = 0, \"right\" === l.hemisphere ? (y = n.x2 - (l.indexLabelTextBlock.x + l.indexLabelTextBlock.width +\n                                q), y *= -1) : y = n.x1 - (l.indexLabelTextBlock.x - l.indexLabelTextBlock.width - q), 0 < y && (!k && l.indexLabelText && (u = \"right\" === l.hemisphere ? n.x2 - l.indexLabelTextBlock.x : l.indexLabelTextBlock.x - n.x1, 0.3 * l.indexLabelTextBlock.maxWidth > u ? l.indexLabelText = \"\" : l.indexLabelTextBlock.maxWidth = 0.85 * u, 0.3 * l.indexLabelTextBlock.maxWidth < u && (l.indexLabelTextBlock.x -= \"right\" === l.hemisphere ? 2 : -2)), Math.abs(l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - x.y) < A || Math.abs(l.indexLabelTextBlock.y + l.indexLabelTextBlock.height /\n                                2 - x.y) < A) && (y /= Math.abs(Math.cos(l.indexLabelAngle)), 9 < y && (y *= 0.3), y > d && (d = y)), y = y = 0, 0 < l.indexLabelAngle && l.indexLabelAngle < Math.PI ? (y = n.y2 - (l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 + 5), y *= -1) : y = n.y1 - (l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - 5), 0 < y && (!k && l.indexLabelText && (u = 0 < l.indexLabelAngle && l.indexLabelAngle < Math.PI ? -1 : 1, 0 === g(a, y * u) && g(a, 2 * u)), Math.abs(l.indexLabelTextBlock.x - x.x) < A && (y /= Math.abs(Math.sin(l.indexLabelAngle)), 9 < y && (y *= 0.3), y > d && (d = y)));\n                    var K = function (a, b, c) { for (var e = [], d = 0; e.push(f[b]), b !== c; b = (b + 1 + s.length) % s.length)\n                        ; e.sort(function (a, b) { return a.y - b.y; }); for (b = 0; b < e.length; b++)\n                        if (c = e[b], d < 0.7 * a)\n                            d += c.indexLabelTextBlock.height, c.indexLabelTextBlock.text = \"\", c.indexLabelText = \"\", c.indexLabelTextBlock.measureText();\n                        else\n                            break; };\n                    (function () {\n                        for (var a = -1, b = -1, d = 0, g = !1, l = 0; l < s.length; l++)\n                            if (g = !1, t = f[l], t.indexLabelText) {\n                                var k = e(l);\n                                if (null !== k) {\n                                    var m = f[k];\n                                    z = 0;\n                                    z = c(t, m);\n                                    var n;\n                                    if (n = 0 > z) {\n                                        n = t.indexLabelTextBlock.x;\n                                        var h = t.indexLabelTextBlock.y - t.indexLabelTextBlock.height /\n                                            2, w = t.indexLabelTextBlock.y + t.indexLabelTextBlock.height / 2, p = m.indexLabelTextBlock.y - m.indexLabelTextBlock.height / 2, u = m.indexLabelTextBlock.x + m.indexLabelTextBlock.width, r = m.indexLabelTextBlock.y + m.indexLabelTextBlock.height / 2;\n                                        n = t.indexLabelTextBlock.x + t.indexLabelTextBlock.width < m.indexLabelTextBlock.x - q || n > u + q || h > r + q || w < p - q ? !1 : !0;\n                                    }\n                                    n ? (0 > a && (a = l), k !== a && (b = k, d += -z), 0 === l % Math.max(s.length / 10, 3) && (g = !0)) : g = !0;\n                                    g && (0 < d && 0 <= a && 0 <= b) && (K(d, a, b), b = a = -1, d = 0);\n                                }\n                            }\n                        0 < d && K(d, a, b);\n                    })();\n                }\n            }\n            function l() {\n                h.plotArea.layoutManager.reset();\n                h.title && (h.title.dockInsidePlotArea || \"center\" === h.title.horizontalAlign && \"center\" === h.title.verticalAlign) && h.title.render();\n                if (h.subtitles)\n                    for (var a = 0; a < h.subtitles.length; a++) {\n                        var b = h.subtitles[a];\n                        (b.dockInsidePlotArea || \"center\" === b.horizontalAlign && \"center\" === b.verticalAlign) && b.render();\n                    }\n                h.legend && (h.legend.dockInsidePlotArea || \"center\" === h.legend.horizontalAlign && \"center\" === h.legend.verticalAlign) && (h.legend.setLayout(), h.legend.render());\n            }\n            var h = this;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                var m = this.data[a.dataSeriesIndexes[0]], s = m.dataPoints, q = 10, n = this.plotArea, f = m.dataPointEOs, p = 2, r, v = 1.3, t = 20 / 180 * Math.PI, C = 6, x = { x: (n.x2 + n.x1) / 2, y: (n.y2 + n.y1) / 2 }, z = 0;\n                a = !1;\n                for (var y = 0; y < s.length; y++)\n                    z += Math.abs(s[y].y), !a && (\"undefined\" !== typeof s[y].indexLabel && null !== s[y].indexLabel && 0 < s[y].indexLabel.toString().length) && (a = !0), !a && (\"undefined\" !== typeof s[y].label && null !== s[y].label && 0 < s[y].label.toString().length) && (a = !0);\n                if (0 !== z) {\n                    a = a || \"undefined\" !== typeof m.indexLabel && null !== m.indexLabel && 0 < m.indexLabel.toString().length;\n                    var A = \"inside\" !== m.indexLabelPlacement && a ? 0.75 * Math.min(n.width, n.height) / 2 : 0.92 * Math.min(n.width, n.height) / 2;\n                    m.radius && (A = I(m.radius, A));\n                    var D = \"undefined\" !== typeof m.innerRadius && null !== m.innerRadius ? I(m.innerRadius, A) : 0.7 * A;\n                    m.radius = A;\n                    \"doughnut\" === m.type && (m.innerRadius = D);\n                    var F = Math.min(D / A, (A - 1) / A);\n                    this.pieDoughnutClickHandler = function (a) {\n                        h.isAnimating || !u(a.dataSeries.explodeOnClick) && !a.dataSeries.explodeOnClick || (a = a.dataPoint, a.exploded = a.exploded ? !1 : !0, 1 < this.dataPoints.length && h._animator.animate(0, 500, function (a) { b(a); l(); }));\n                    };\n                    d();\n                    k();\n                    k();\n                    k();\n                    k();\n                    this.disableToolTip = !0;\n                    this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (a) {\n                        var b = h.plotArea.ctx;\n                        b.clearRect(n.x1, n.y1, n.width, n.height);\n                        b.fillStyle = h.backgroundColor;\n                        b.fillRect(n.x1, n.y1, n.width, n.height);\n                        a = f[0].startAngle + 2 * Math.PI * a;\n                        for (b = 0; b < s.length; b++) {\n                            var c = 0 === b ? f[b].startAngle : e, e = c + (f[b].endAngle - f[b].startAngle), d = !1;\n                            e > a && (e = a, d = !0);\n                            var g = s[b].color ? s[b].color : m._colorSet[b % m._colorSet.length];\n                            e > c && ja(h.plotArea.ctx, f[b].center, f[b].radius, g, m.type, c, e, m.fillOpacity, f[b].percentInnerRadius);\n                            if (d)\n                                break;\n                        }\n                        l();\n                    }, function () { h.disableToolTip = !1; h._animator.animate(0, h.animatedRender ? 500 : 0, function (a) { b(a); l(); }); });\n                }\n            }\n        };\n        var ra = function (a, d, b, c) {\n            \"undefined\" === typeof b && (b = 1);\n            0 >= Math.round(d.y4 - d.y1) || (a.save(), a.globalAlpha = b, a.beginPath(), a.moveTo(Math.round(d.x1), Math.round(d.y1)), a.lineTo(Math.round(d.x2), Math.round(d.y2)), a.lineTo(Math.round(d.x3), Math.round(d.y3)), a.lineTo(Math.round(d.x4), Math.round(d.y4)), \"undefined\" !==\n                d.x5 && (a.lineTo(Math.round(d.x5), Math.round(d.y5)), a.lineTo(Math.round(d.x6), Math.round(d.y6))), a.closePath(), a.fillStyle = c ? c : d.color, a.fill(), a.globalAplha = 1, a.restore());\n        };\n        p.prototype.renderFunnel = function (a) {\n            function d() { for (var a = 0, b = [], c = 0; c < C.length; c++) {\n                if (\"undefined\" === typeof C[c].y)\n                    return -1;\n                C[c].y = \"number\" === typeof C[c].y ? C[c].y : 0;\n                a += Math.abs(C[c].y);\n            } if (0 === a)\n                return -1; for (c = b[0] = 0; c < C.length; c++)\n                b.push(Math.abs(C[c].y) * F / a); return b; }\n            function b() {\n                var a = $, b = V, c = K, e = ea, d, f;\n                d = O;\n                f = Z - N;\n                e = Math.abs((f -\n                    d) * (b - a + (e - c)) / 2);\n                c = ea - K;\n                d = f - d;\n                f = c * (f - Z);\n                f = Math.abs(f);\n                f = e + f;\n                for (var e = [], g = 0, l = 0; l < C.length; l++) {\n                    if (\"undefined\" === typeof C[l].y)\n                        return -1;\n                    C[l].y = \"number\" === typeof C[l].y ? C[l].y : 0;\n                    g += Math.abs(C[l].y);\n                }\n                if (0 === g)\n                    return -1;\n                for (var m = e[0] = 0, k = 0, n, h, b = b - a, m = !1, l = 0; l < C.length; l++)\n                    a = Math.abs(C[l].y) * f / g, m ? n = 0 == Number(c.toFixed(3)) ? 0 : a / c : (h = ba * ba * b * b - 4 * Math.abs(ba) * a, 0 > h ? (h = c, m = (b + h) * (d - k) / 2, a -= m, n = d - k, k += d - k, n += 0 == h ? 0 : a / h, k += a / h, m = !0) : (n = (Math.abs(ba) * b - Math.sqrt(h)) / 2, h = b - 2 * n / Math.abs(ba), k += n, k > d && (k -= n,\n                        h = c, m = (b + h) * (d - k) / 2, a -= m, n = d - k, k += d - k, n += a / h, k += a / h, m = !0), b = h)), e.push(n);\n                return e;\n            }\n            function c() {\n                if (t && C) {\n                    for (var a, b, c, e, d, g, l, k, m, n, h, q, s, w, p = [], B = [], x = { percent: null, total: null }, v = null, y = 0; y < C.length; y++)\n                        w = P[y], w = \"undefined\" !== typeof w.x5 ? (w.y2 + w.y4) / 2 : (w.y2 + w.y3) / 2, w = f(w).x2 + 1, p[y] = L - w - S;\n                    w = 0.5 * S;\n                    for (var y = 0, A = C.length - 1; y < C.length || 0 <= A; y++, A--) {\n                        b = t.reversed ? C[A] : C[y];\n                        a = b.color ? b.color : t.reversed ? t._colorSet[(C.length - 1 - y) % t._colorSet.length] : t._colorSet[y % t._colorSet.length];\n                        c = b.indexLabelPlacement ||\n                            t.indexLabelPlacement || \"outside\";\n                        e = b.indexLabelBackgroundColor || t.indexLabelBackgroundColor || (r ? \"transparent\" : null);\n                        d = b.indexLabelFontColor || t.indexLabelFontColor || \"#979797\";\n                        g = u(b.indexLabelFontSize) ? t.indexLabelFontSize : b.indexLabelFontSize;\n                        l = b.indexLabelFontStyle || t.indexLabelFontStyle || \"normal\";\n                        k = b.indexLabelFontFamily || t.indexLabelFontFamily || \"arial\";\n                        m = b.indexLabelFontWeight || t.indexLabelFontWeight || \"normal\";\n                        a = b.indexLabelLineColor || t.options.indexLabelLineColor || a;\n                        n = \"number\" === typeof b.indexLabelLineThickness ?\n                            b.indexLabelLineThickness : \"number\" === typeof t.indexLabelLineThickness ? t.indexLabelLineThickness : 2;\n                        h = b.indexLabelLineDashType || t.indexLabelLineDashType || \"solid\";\n                        q = \"undefined\" !== typeof b.indexLabelWrap ? b.indexLabelWrap : \"undefined\" !== typeof t.indexLabelWrap ? t.indexLabelWrap : !0;\n                        s = t.dataPointIds[y];\n                        z._eventManager.objectMap[s] = { id: s, objectType: \"dataPoint\", dataPointIndex: y, dataSeriesIndex: 0, funnelSection: P[t.reversed ? C.length - 1 - y : y] };\n                        \"inside\" === t.indexLabelPlacement && (p[y] = y !== fa ? t.reversed ? P[y].x2 - P[y].x1 :\n                            P[y].x3 - P[y].x4 : P[y].x3 - P[y].x6, 20 > p[y] && (p[y] = y !== fa ? t.reversed ? P[y].x3 - P[y].x4 : P[y].x2 - P[y].x1 : P[y].x2 - P[y].x1, p[y] /= 2));\n                        s = b.indexLabelMaxWidth ? b.indexLabelMaxWidth : t.options.indexLabelMaxWidth ? t.indexLabelMaxWidth : p[y];\n                        if (s > p[y] || 0 > s)\n                            s = p[y];\n                        B[y] = \"inside\" === t.indexLabelPlacement ? P[y].height : !1;\n                        x = z.getPercentAndTotal(t, b);\n                        if (t.indexLabelFormatter || b.indexLabelFormatter)\n                            v = { chart: z.options, dataSeries: t, dataPoint: b, total: x.total, percent: x.percent };\n                        b = b.indexLabelFormatter ? b.indexLabelFormatter(v) : b.indexLabel ?\n                            z.replaceKeywordsWithValue(b.indexLabel, b, t, y) : t.indexLabelFormatter ? t.indexLabelFormatter(v) : t.indexLabel ? z.replaceKeywordsWithValue(t.indexLabel, b, t, y) : b.label ? b.label : \"\";\n                        0 >= n && (n = 0);\n                        1E3 > s && 1E3 - s < w && (s += 1E3 - s);\n                        Q.roundRect || Ea(Q);\n                        c = new ka(Q, { fontSize: g, fontFamily: k, fontColor: d, fontStyle: l, fontWeight: m, horizontalAlign: c, backgroundColor: e, maxWidth: s, maxHeight: !1 === B[y] ? q ? 4.28571429 * g : 1.5 * g : B[y], text: b, padding: ga });\n                        c.measureText();\n                        J.push({ textBlock: c, id: t.reversed ? A : y, isDirty: !1, lineColor: a, lineThickness: n,\n                            lineDashType: h, height: c.height < c.maxHeight ? c.height : c.maxHeight, width: c.width < c.maxWidth ? c.width : c.maxWidth });\n                    }\n                }\n            }\n            function e() {\n                var a, b, c, e, d, f = [];\n                d = !1;\n                c = 0;\n                for (var g, l = L - V - S / 2, l = t.options.indexLabelMaxWidth ? t.indexLabelMaxWidth > l ? l : t.indexLabelMaxWidth : l, k = J.length - 1; 0 <= k; k--) {\n                    g = C[J[k].id];\n                    c = J[k];\n                    e = c.textBlock;\n                    b = (a = n(k) < P.length ? J[n(k)] : null) ? a.textBlock : null;\n                    c = c.height;\n                    a && e.y + c + ga > b.y && (d = !0);\n                    c = g.indexLabelMaxWidth || l;\n                    if (c > l || 0 > c)\n                        c = l;\n                    f.push(c);\n                }\n                if (d)\n                    for (k = J.length - 1; 0 <= k; k--)\n                        a = P[k], J[k].textBlock.maxWidth =\n                            f[f.length - (k + 1)], J[k].textBlock.measureText(), J[k].textBlock.x = L - l, c = J[k].textBlock.height < J[k].textBlock.maxHeight ? J[k].textBlock.height : J[k].textBlock.maxHeight, d = J[k].textBlock.width < J[k].textBlock.maxWidth ? J[k].textBlock.width : J[k].textBlock.maxWidth, J[k].height = c, J[k].width = d, c = \"undefined\" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, J[k].textBlock.y = c - J[k].height / 2, t.reversed ? (J[k].textBlock.y + J[k].height > pa + D && (J[k].textBlock.y = pa + D - J[k].height), J[k].textBlock.y < wa - D && (J[k].textBlock.y = wa - D)) :\n                            (J[k].textBlock.y < pa - D && (J[k].textBlock.y = pa - D), J[k].textBlock.y + J[k].height > wa + D && (J[k].textBlock.y = wa + D - J[k].height));\n            }\n            function g() {\n                var a, b, c, e;\n                if (\"inside\" !== t.indexLabelPlacement)\n                    for (var d = 0; d < P.length; d++)\n                        0 == J[d].textBlock.text.length ? J[d].isDirty = !0 : (a = P[d], c = \"undefined\" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, b = t.reversed ? \"undefined\" !== typeof a.x5 ? c > Da ? f(c).x2 + 1 : (a.x2 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1 : \"undefined\" !== typeof a.x5 ? c < Da ? f(c).x2 + 1 : (a.x4 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1, J[d].textBlock.x = b + S, J[d].textBlock.y =\n                            c - J[d].height / 2, t.reversed ? (J[d].textBlock.y + J[d].height > pa + D && (J[d].textBlock.y = pa + D - J[d].height), J[d].textBlock.y < wa - D && (J[d].textBlock.y = wa - D)) : (J[d].textBlock.y < pa - D && (J[d].textBlock.y = pa - D), J[d].textBlock.y + J[d].height > wa + D && (J[d].textBlock.y = wa + D - J[d].height)));\n                else\n                    for (d = 0; d < P.length; d++)\n                        0 == J[d].textBlock.text.length ? J[d].isDirty = !0 : (a = P[d], b = a.height, c = J[d].height, e = J[d].width, b >= c ? (b = d != fa ? (a.x4 + a.x3) / 2 - e / 2 : (a.x5 + a.x4) / 2 - e / 2, c = d != fa ? (a.y1 + a.y3) / 2 - c / 2 : (a.y1 + a.y4) / 2 - c / 2, J[d].textBlock.x = b,\n                            J[d].textBlock.y = c) : J[d].isDirty = !0);\n            }\n            function k() {\n                function a(b, c) { var d; if (0 > b || b >= J.length)\n                    return 0; var e, f = J[b].textBlock; if (0 > c) {\n                    c *= -1;\n                    e = q(b);\n                    d = l(e, b);\n                    if (d >= c)\n                        return f.y -= c, c;\n                    if (0 == b)\n                        return 0 < d && (f.y -= d), d;\n                    d += a(e, -(c - d));\n                    0 < d && (f.y -= d);\n                    return d;\n                } e = n(b); d = l(b, e); if (d >= c)\n                    return f.y += c, c; if (b == P.length - 1)\n                    return 0 < d && (f.y += d), d; d += a(e, c - d); 0 < d && (f.y += d); return d; }\n                function b() {\n                    var a, d, e, f, g = 0, k;\n                    f = (Z - O + 2 * D) / h;\n                    k = h;\n                    for (var l, m = 1; m < k; m++) {\n                        e = m * f;\n                        for (var s = J.length - 1; 0 <= s; s--)\n                            !J[s].isDirty && (J[s].textBlock.y <\n                                e && J[s].textBlock.y + J[s].height > e) && (l = n(s), !(l >= J.length - 1) && J[s].textBlock.y + J[s].height + ga > J[l].textBlock.y && (J[s].textBlock.y = J[s].textBlock.y + J[s].height - e > e - J[s].textBlock.y ? e + 1 : e - J[s].height - 1));\n                    }\n                    for (l = P.length - 1; 0 < l; l--)\n                        if (!J[l].isDirty) {\n                            e = q(l);\n                            if (0 > e && (e = 0, J[e].isDirty))\n                                break;\n                            if (J[l].textBlock.y < J[e].textBlock.y + J[e].height) {\n                                d = d || l;\n                                f = l;\n                                for (k = 0; J[f].textBlock.y < J[e].textBlock.y + J[e].height + ga;) {\n                                    a = a || J[f].textBlock.y + J[f].height;\n                                    k += J[f].height;\n                                    k += ga;\n                                    f = e;\n                                    if (0 >= f) {\n                                        f = 0;\n                                        k += J[f].height;\n                                        break;\n                                    }\n                                    e = q(f);\n                                    if (0 > e) {\n                                        f = 0;\n                                        k += J[f].height;\n                                        break;\n                                    }\n                                }\n                                if (f != l) {\n                                    g = J[f].textBlock.y;\n                                    a -= g;\n                                    a = k - a;\n                                    g = c(a, d, f);\n                                    break;\n                                }\n                            }\n                        }\n                    return g;\n                }\n                function c(a, b, d) { var e = [], f = 0, g = 0; for (a = Math.abs(a); d <= b; d++)\n                    e.push(P[d]); e.sort(function (a, b) { return a.height - b.height; }); for (d = 0; d < e.length; d++)\n                    if (b = e[d], f < a)\n                        g++, f += J[b.id].height + ga, J[b.id].textBlock.text = \"\", J[b.id].indexLabelText = \"\", J[b.id].isDirty = !0, J[b.id].textBlock.measureText();\n                    else\n                        break; return g; }\n                for (var d, e, f, g, k, m, h = 1, s = 0; s < 2 * h; s++) {\n                    for (var w = J.length - 1; 0 <= w && !(0 <= q(w) && q(w), f = J[w], g = f.textBlock,\n                        m = (k = n(w) < P.length ? J[n(w)] : null) ? k.textBlock : null, d = +f.height.toFixed(6), e = +g.y.toFixed(6), !f.isDirty && (k && e + d + ga > +m.y.toFixed(6)) && (d = g.y + d + ga - m.y, e = a(w, -d), e < d && (0 < e && (d -= e), e = a(n(w), d), e != d))); w--)\n                        ;\n                    b();\n                }\n            }\n            function l(a, b) { return (b < P.length ? J[b].textBlock.y : t.reversed ? pa + D : wa + D) - (0 > a ? t.reversed ? wa - D : pa - D : J[a].textBlock.y + J[a].height + ga); }\n            function h(a, b, c) {\n                var d, e, f, k = [], l = D, n = [];\n                -1 !== b && (0 <= W.indexOf(b) ? (e = W.indexOf(b), W.splice(e, 1)) : (W.push(b), W = W.sort(function (a, b) { return a - b; })));\n                if (0 === W.length)\n                    k =\n                        ia;\n                else {\n                    e = D * (1 != W.length || 0 != W[0] && W[0] != P.length - 1 ? 2 : 1) / m();\n                    for (var q = 0; q < P.length; q++) {\n                        if (1 == W.length && 0 == W[0]) {\n                            if (0 === q) {\n                                k.push(ia[q]);\n                                d = l;\n                                continue;\n                            }\n                        }\n                        else\n                            0 === q && (d = -1 * l);\n                        k.push(ia[q] + d);\n                        if (0 <= W.indexOf(q) || q < P.length && 0 <= W.indexOf(q + 1))\n                            d += e;\n                    }\n                }\n                f = function () { for (var a = [], b = 0; b < P.length; b++)\n                    a.push(k[b] - P[b].y1); return a; }();\n                var w = { startTime: (new Date).getTime(), duration: c || 500, easingFunction: function (a, b, c, d) { return M.easing.easeOutQuart(a, b, c, d); }, changeSection: function (a) {\n                        for (var b, c, d = 0; d < P.length; d++)\n                            b =\n                                f[d], c = P[d], b *= a, \"undefined\" === typeof n[d] && (n[d] = 0), 0 > n && (n *= -1), c.y1 += b - n[d], c.y2 += b - n[d], c.y3 += b - n[d], c.y4 += b - n[d], c.y5 && (c.y5 += b - n[d], c.y6 += b - n[d]), n[d] = b;\n                    } };\n                a._animator.animate(0, c, function (c) {\n                    var d = a.plotArea.ctx || a.ctx;\n                    ja = !0;\n                    d.clearRect(x.x1, x.y1, x.x2 - x.x1, x.y2 - x.y1);\n                    d.fillStyle = a.backgroundColor;\n                    d.fillRect(x.x1, x.y1, x.width, x.height);\n                    w.changeSection(c, b);\n                    var e = {};\n                    e.dataSeries = t;\n                    e.dataPoint = t.reversed ? t.dataPoints[C.length - 1 - b] : t.dataPoints[b];\n                    e.index = t.reversed ? C.length - 1 - b : b;\n                    a.toolTip.highlightObjects([e]);\n                    for (e = 0; e < P.length; e++)\n                        ra(d, P[e], t.fillOpacity);\n                    v(d);\n                    H && (\"inside\" !== t.indexLabelPlacement ? s(d) : g(), p(d));\n                    1 <= c && (ja = !1);\n                }, null, M.easing.easeOutQuart);\n            }\n            function m() { for (var a = 0, b = 0; b < P.length - 1; b++)\n                (0 <= W.indexOf(b) || 0 <= W.indexOf(b + 1)) && a++; return a; }\n            function s(a) {\n                for (var b, c, d, e, g = 0; g < P.length; g++)\n                    e = 1 === J[g].lineThickness % 2 ? 0.5 : 0, c = ((P[g].y2 + P[g].y4) / 2 << 0) + e, b = f(c).x2 - 1, d = J[g].textBlock.x, e = (J[g].textBlock.y + J[g].height / 2 << 0) + e, J[g].isDirty || 0 == J[g].lineThickness || (a.strokeStyle = J[g].lineColor, a.lineWidth =\n                        J[g].lineThickness, a.setLineDash && a.setLineDash(R(J[g].lineDashType, J[g].lineThickness)), a.beginPath(), a.moveTo(b, c), a.lineTo(d, e), a.stroke());\n            }\n            function q(a) { for (a -= 1; -1 <= a && -1 != a && J[a].isDirty; a--)\n                ; return a; }\n            function n(a) { for (a += 1; a <= P.length && a != P.length && J[a].isDirty; a++)\n                ; return a; }\n            function f(a) {\n                for (var b, c = 0; c < C.length; c++)\n                    if (P[c].y1 < a && P[c].y4 > a) {\n                        b = P[c];\n                        break;\n                    }\n                return b ? (a = b.y6 ? a > b.y6 ? b.x3 + (b.x4 - b.x3) / (b.y4 - b.y3) * (a - b.y3) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2),\n                    { x1: a, x2: a }) : -1;\n            }\n            function p(a) { for (var b = 0; b < P.length; b++)\n                J[b].isDirty || (a && (J[b].textBlock.ctx = a), J[b].textBlock.render(!0)); }\n            function v(a) {\n                z.plotArea.layoutManager.reset();\n                a.roundRect || Ea(a);\n                z.title && (z.title.dockInsidePlotArea || \"center\" === z.title.horizontalAlign && \"center\" === z.title.verticalAlign) && (z.title.ctx = a, z.title.render());\n                if (z.subtitles)\n                    for (var b = 0; b < z.subtitles.length; b++) {\n                        var c = z.subtitles[b];\n                        if (c.dockInsidePlotArea || \"center\" === c.horizontalAlign && \"center\" === c.verticalAlign)\n                            z.subtitles.ctx =\n                                a, c.render();\n                    }\n                z.legend && (z.legend.dockInsidePlotArea || \"center\" === z.legend.horizontalAlign && \"center\" === z.legend.verticalAlign) && (z.legend.ctx = a, z.legend.setLayout(), z.legend.render());\n                U.fNg && U.fNg(z);\n            }\n            var z = this;\n            if (!(0 >= a.dataSeriesIndexes.length)) {\n                for (var t = this.data[a.dataSeriesIndexes[0]], C = t.dataPoints, x = this.plotArea, D = 0.025 * x.width, y = 0.01 * x.width, A = 0, F = x.height - 2 * D, E = Math.min(x.width - 2 * y, 2.8 * x.height), H = !1, I = 0; I < C.length; I++)\n                    if (!H && (\"undefined\" !== typeof C[I].indexLabel && null !== C[I].indexLabel &&\n                        0 < C[I].indexLabel.toString().length) && (H = !0), !H && (\"undefined\" !== typeof C[I].label && null !== C[I].label && 0 < C[I].label.toString().length) && (H = !0), !H && \"function\" === typeof t.indexLabelFormatter || \"function\" === typeof C[I].indexLabelFormatter)\n                        H = !0;\n                H = H || \"undefined\" !== typeof t.indexLabel && null !== t.indexLabel && 0 < t.indexLabel.toString().length;\n                \"inside\" !== t.indexLabelPlacement && H || (y = (x.width - 0.75 * E) / 2);\n                var I = x.x1 + y, L = x.x2 - y, O = x.y1 + D, Z = x.y2 - D, Q = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;\n                if (0 != t.length && (t.dataPoints &&\n                    t.visible) && 0 !== C.length) {\n                    var N, G;\n                    a = 75 * E / 100;\n                    var S = 30 * (L - a) / 100;\n                    \"funnel\" === t.type ? (N = u(t.options.neckHeight) ? 0.35 * F : t.neckHeight, G = u(t.options.neckWidth) ? 0.25 * a : t.neckWidth, \"string\" === typeof N && N.match(/%$/) ? (N = parseInt(N), N = N * F / 100) : N = parseInt(N), \"string\" === typeof G && G.match(/%$/) ? (G = parseInt(G), G = G * a / 100) : G = parseInt(G), N > F ? N = F : 0 >= N && (N = 0), G > a ? G = a - 0.5 : 0 >= G && (G = 0)) : \"pyramid\" === t.type && (G = N = 0, t.reversed = t.reversed ? !1 : !0);\n                    var y = I + a / 2, $ = I, V = I + a, pa = t.reversed ? Z : O, K = y - G / 2, ea = y + G / 2, Da = t.reversed ? O + N : Z -\n                        N, wa = t.reversed ? O : Z;\n                    a = [];\n                    var y = [], P = [], E = [], X = O, fa, ba = (Da - pa) / (K - $), ha = -ba, I = \"area\" === (t.valueRepresents ? t.valueRepresents : \"height\") ? b() : d();\n                    if (-1 !== I) {\n                        if (t.reversed)\n                            for (E.push(X), G = I.length - 1; 0 < G; G--)\n                                X += I[G], E.push(X);\n                        else\n                            for (G = 0; G < I.length; G++)\n                                X += I[G], E.push(X);\n                        if (t.reversed)\n                            for (G = 0; G < I.length; G++)\n                                E[G] < Da ? (a.push(K), y.push(ea), fa = G) : (a.push((E[G] - pa + ba * $) / ba), y.push((E[G] - pa + ha * V) / ha));\n                        else\n                            for (G = 0; G < I.length; G++)\n                                E[G] < Da ? (a.push((E[G] - pa + ba * $) / ba), y.push((E[G] - pa + ha * V) / ha), fa = G) : (a.push(K), y.push(ea));\n                        for (G = 0; G < I.length - 1; G++)\n                            X = t.reversed ? C[C.length - 1 - G].color ? C[C.length - 1 - G].color : t._colorSet[(C.length - 1 - G) % t._colorSet.length] : C[G].color ? C[G].color : t._colorSet[G % t._colorSet.length], G === fa ? P.push({ x1: a[G], y1: E[G], x2: y[G], y2: E[G], x3: ea, y3: Da, x4: y[G + 1], y4: E[G + 1], x5: a[G + 1], y5: E[G + 1], x6: K, y6: Da, id: G, height: E[G + 1] - E[G], color: X }) : P.push({ x1: a[G], y1: E[G], x2: y[G], y2: E[G], x3: y[G + 1], y3: E[G + 1], x4: a[G + 1], y4: E[G + 1], id: G, height: E[G + 1] - E[G], color: X });\n                        var ga = 2, J = [], ja = !1, W = [], ia = [], I = !1;\n                        a = a = 0;\n                        Fa(W);\n                        for (G = 0; G <\n                            C.length; G++)\n                            C[G].exploded && (I = !0, t.reversed ? W.push(C.length - 1 - G) : W.push(G));\n                        Q.clearRect(x.x1, x.y1, x.width, x.height);\n                        Q.fillStyle = z.backgroundColor;\n                        Q.fillRect(x.x1, x.y1, x.width, x.height);\n                        if (H && t.visible && (c(), g(), e(), \"inside\" !== t.indexLabelPlacement)) {\n                            k();\n                            for (G = 0; G < C.length; G++)\n                                J[G].isDirty || (a = J[G].textBlock.x + J[G].width, a = (L - a) / 2, 0 == G && (A = a), A > a && (A = a));\n                            for (G = 0; G < P.length; G++)\n                                P[G].x1 += A, P[G].x2 += A, P[G].x3 += A, P[G].x4 += A, P[G].x5 && (P[G].x5 += A, P[G].x6 += A), J[G].textBlock.x += A;\n                        }\n                        for (G = 0; G < P.length; G++)\n                            A =\n                                P[G], ra(Q, A, t.fillOpacity), ia.push(A.y1);\n                        v(Q);\n                        H && t.visible && (\"inside\" === t.indexLabelPlacement || z.animationEnabled || s(Q), z.animationEnabled || p());\n                        if (!H)\n                            for (G = 0; G < C.length; G++)\n                                A = t.dataPointIds[G], a = { id: A, objectType: \"dataPoint\", dataPointIndex: G, dataSeriesIndex: 0, funnelSection: P[t.reversed ? C.length - 1 - G : G] }, z._eventManager.objectMap[A] = a;\n                        !z.animationEnabled && I ? h(z, -1, 0) : z.animationEnabled && !z.animatedRender && h(z, -1, 0);\n                        this.funnelPyramidClickHandler = function (a) {\n                            var b = -1;\n                            if (!ja && !z.isAnimating && (u(a.dataSeries.explodeOnClick) ||\n                                a.dataSeries.explodeOnClick) && (b = t.reversed ? C.length - 1 - a.dataPointIndex : a.dataPointIndex, 0 <= b)) {\n                                a = b;\n                                if (\"funnel\" === t.type || \"pyramid\" === t.type)\n                                    t.reversed ? C[C.length - 1 - a].exploded = C[C.length - 1 - a].exploded ? !1 : !0 : C[a].exploded = C[a].exploded ? !1 : !0;\n                                h(z, b, 500);\n                            }\n                        };\n                        return { source: Q, dest: this.plotArea.ctx, animationCallback: function (a, b) { M.fadeInAnimation(a, b); 1 <= a && (h(z, -1, 500), v(z.plotArea.ctx || z.ctx)); }, easingFunction: M.easing.easeInQuad, animationBase: 0 };\n                    }\n                }\n            }\n        };\n        p.prototype.requestAnimFrame = function () {\n            return window.requestAnimationFrame ||\n                window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) { window.setTimeout(a, 1E3 / 60); };\n        }();\n        p.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;\n        p.prototype.set = function (a, d, b) {\n            b = \"undefined\" === typeof b ? !0 : b;\n            \"options\" === a ? (this.options = d,\n                b && this.render()) : p.base.set.call(this, a, d, b);\n        };\n        p.prototype.exportChart = function (a) { a = \"undefined\" === typeof a ? {} : a; var d = a.format ? a.format : \"png\", b = a.fileName ? a.fileName : this.exportFileName; if (a.toDataURL)\n            return this.canvas.toDataURL(\"image/\" + d); Ta(this.canvas, d, b); };\n        p.prototype.print = function () {\n            var a = this.exportChart({ toDataURL: !0 }), d = document.createElement(\"iframe\");\n            d.setAttribute(\"class\", \"canvasjs-chart-print-frame\");\n            d.setAttribute(\"style\", \"position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;\");\n            d.style.height = this.height + \"px\";\n            this._canvasJSContainer.appendChild(d);\n            var b = this, c = d.contentWindow || d.contentDocument.document || d.contentDocument;\n            c.document.open();\n            c.document.write('<!DOCTYPE HTML>\\n<html><body style=\"margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;\"><img src=\"' + a + '\"/><body/></html>');\n            c.document.close();\n            setTimeout(function () { c.focus(); c.print(); setTimeout(function () { b._canvasJSContainer.removeChild(d); }, 1E3); }, 500);\n        };\n        p.prototype.getPercentAndTotal = function (a, d) {\n            var b = null, c = null, e = null;\n            if (0 <= a.type.indexOf(\"stacked\"))\n                c = 0, b = d.x.getTime ? d.x.getTime() : d.x, b in a.plotUnit.yTotals && (c = a.plotUnit.yTotals[b], e = isNaN(d.y) ? 0 : 100 * (d.y / c));\n            else if (\"pie\" === a.type || \"doughnut\" === a.type || \"funnel\" === a.type || \"pyramid\" === a.type) {\n                for (b = c = 0; b < a.dataPoints.length; b++)\n                    isNaN(a.dataPoints[b].y) || (c += a.dataPoints[b].y);\n                e = isNaN(d.y) ? 0 : 100 * (d.y / c);\n            }\n            return { percent: e, total: c };\n        };\n        p.prototype.replaceKeywordsWithValue = function (a, d, b, c, e) {\n            var g = this;\n            e = \"undefined\" === typeof e ? 0 : e;\n            if ((0 <= b.type.indexOf(\"stacked\") ||\n                \"pie\" === b.type || \"doughnut\" === b.type || \"funnel\" === b.type || \"pyramid\" === b.type) && (0 <= a.indexOf(\"#percent\") || 0 <= a.indexOf(\"#total\"))) {\n                var k = \"#percent\", l = \"#total\", h = this.getPercentAndTotal(b, d), l = isNaN(h.total) ? l : h.total, k = isNaN(h.percent) ? k : h.percent;\n                do {\n                    h = \"\";\n                    if (b.percentFormatString)\n                        h = b.percentFormatString;\n                    else {\n                        var h = \"#,##0.\", m = Math.max(Math.ceil(Math.log(1 / Math.abs(k)) / Math.LN10), 2);\n                        if (isNaN(m) || !isFinite(m))\n                            m = 2;\n                        for (var s = 0; s < m; s++)\n                            h += \"#\";\n                        b.percentFormatString = h;\n                    }\n                    a = a.replace(\"#percent\", ba(k, h, g._cultureInfo));\n                    a = a.replace(\"#total\", ba(l, b.yValueFormatString ? b.yValueFormatString : \"#,##0.########\", g._cultureInfo));\n                } while (0 <= a.indexOf(\"#percent\") || 0 <= a.indexOf(\"#total\"));\n            }\n            return a.replace(/\\{.*?\\}|\"[^\"]*\"|'[^']*'/g, function (a) {\n                if ('\"' === a[0] && '\"' === a[a.length - 1] || \"'\" === a[0] && \"'\" === a[a.length - 1])\n                    return a.slice(1, a.length - 1);\n                a = Ia(a.slice(1, a.length - 1));\n                a = a.replace(\"#index\", e);\n                var k = null;\n                try {\n                    var f = a.match(/(.*?)\\s*\\[\\s*(.*?)\\s*\\]/);\n                    f && 0 < f.length && (k = Ia(f[2]), a = Ia(f[1]));\n                }\n                catch (l) { }\n                f = null;\n                if (\"color\" === a)\n                    return \"waterfall\" ===\n                        b.type ? d.color ? d.color : 0 < d.y ? b.risingColor : b.fallingColor : \"error\" === b.type ? b.color ? b.color : b._colorSet[k % b._colorSet.length] : d.color ? d.color : b.color ? b.color : b._colorSet[c % b._colorSet.length];\n                if (d.hasOwnProperty(a))\n                    f = d;\n                else if (b.hasOwnProperty(a))\n                    f = b;\n                else\n                    return \"\";\n                f = f[a];\n                null !== k && (f = f[k]);\n                if (\"x\" === a)\n                    if (\"dateTime\" === b.axisX.valueType || \"dateTime\" === b.xValueType || d.x && d.x.getTime) {\n                        if (g.plotInfo.plotTypes[0].plotUnits[0].axisX && !g.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic)\n                            return Ca(f, d.xValueFormatString ?\n                                d.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = g.axisX && g.axisX.autoValueFormatString ? g.axisX.autoValueFormatString : \"DD MMM YY\", g._cultureInfo);\n                    }\n                    else\n                        return ba(f, d.xValueFormatString ? d.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = \"#,##0.########\", g._cultureInfo);\n                else\n                    return \"y\" === a ? ba(f, d.yValueFormatString ? d.yValueFormatString : b.yValueFormatString ? b.yValueFormatString : b.yValueFormatString = \"#,##0.########\", g._cultureInfo) : \"z\" ===\n                        a ? ba(f, d.zValueFormatString ? d.zValueFormatString : b.zValueFormatString ? b.zValueFormatString : b.zValueFormatString = \"#,##0.########\", g._cultureInfo) : f;\n            });\n        };\n        qa(H, V);\n        H.prototype.setLayout = function () {\n            var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, d = a.layoutManager.getFreeSpace(), b = null, c = 0, e = 0, g = 0, k = 0, l = this.markerMargin = this.chart.options.legend && !u(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;\n            this.height = 0;\n            var h = [], m = [];\n            \"top\" === this.verticalAlign ||\n                \"bottom\" === this.verticalAlign ? (this.orientation = \"horizontal\", b = this.verticalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : d.width, k = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * d.height) : \"center\" === this.verticalAlign && (this.orientation = \"vertical\", b = this.horizontalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * d.width, k = this.maxHeight = null !== this.maxHeight ? this.maxHeight : d.height);\n            this.errorMarkerColor = [];\n            for (var s = 0; s < this.dataSeries.length; s++) {\n                var q = this.dataSeries[s];\n                if (q.dataPoints && q.dataPoints.length)\n                    if (\"pie\" !== q.type && \"doughnut\" !== q.type && \"funnel\" !== q.type && \"pyramid\" !== q.type) {\n                        var n = q.legendMarkerType = q.legendMarkerType ? q.legendMarkerType : \"line\" !== q.type && \"stepLine\" !== q.type && \"spline\" !== q.type && \"scatter\" !== q.type && \"bubble\" !== q.type || !q.markerType ? \"error\" === q.type && q._linkedSeries ? q._linkedSeries.legendMarkerType ? q._linkedSeries.legendMarkerType : F.getDefaultLegendMarker(q._linkedSeries.type) : F.getDefaultLegendMarker(q.type) : q.markerType, f = q.legendText ? q.legendText :\n                            this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: q, dataPoint: null }) : q.name, p = q.legendMarkerColor = q.legendMarkerColor ? q.legendMarkerColor : q.markerColor ? q.markerColor : \"error\" === q.type ? u(q.whiskerColor) ? q._colorSet[0] : q.whiskerColor : q._colorSet[0], r = q.markerSize || \"line\" !== q.type && \"stepLine\" !== q.type && \"spline\" !== q.type ? 0.75 * this.lineHeight : 0, v = q.legendMarkerBorderColor ? q.legendMarkerBorderColor : q.markerBorderColor, t = q.legendMarkerBorderThickness ? q.legendMarkerBorderThickness :\n                            q.markerBorderThickness ? Math.max(1, Math.round(0.2 * r)) : 0;\n                        \"error\" === q.type && this.errorMarkerColor.push(p);\n                        f = this.chart.replaceKeywordsWithValue(f, q.dataPoints[0], q, s);\n                        n = { markerType: n, markerColor: p, text: f, textBlock: null, chartType: q.type, markerSize: r, lineColor: q._colorSet[0], dataSeriesIndex: q.index, dataPointIndex: null, markerBorderColor: v, markerBorderThickness: t };\n                        h.push(n);\n                    }\n                    else\n                        for (var z = 0; z < q.dataPoints.length; z++) {\n                            var x = q.dataPoints[z], n = x.legendMarkerType ? x.legendMarkerType : q.legendMarkerType ? q.legendMarkerType :\n                                F.getDefaultLegendMarker(q.type), f = x.legendText ? x.legendText : q.legendText ? q.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: q, dataPoint: x }) : x.name ? x.name : \"DataPoint: \" + (z + 1), p = x.legendMarkerColor ? x.legendMarkerColor : q.legendMarkerColor ? q.legendMarkerColor : x.color ? x.color : q.color ? q.color : q._colorSet[z % q._colorSet.length], r = 0.75 * this.lineHeight, v = x.legendMarkerBorderColor ? x.legendMarkerBorderColor : q.legendMarkerBorderColor ? q.legendMarkerBorderColor :\n                                x.markerBorderColor ? x.markerBorderColor : q.markerBorderColor, t = x.legendMarkerBorderThickness ? x.legendMarkerBorderThickness : q.legendMarkerBorderThickness ? q.legendMarkerBorderThickness : x.markerBorderThickness || q.markerBorderThickness ? Math.max(1, Math.round(0.2 * r)) : 0, f = this.chart.replaceKeywordsWithValue(f, x, q, z), n = { markerType: n, markerColor: p, text: f, textBlock: null, chartType: q.type, markerSize: r, dataSeriesIndex: s, dataPointIndex: z, markerBorderColor: v, markerBorderThickness: t };\n                            (x.showInLegend || q.showInLegend &&\n                                !1 !== x.showInLegend) && h.push(n);\n                        }\n            }\n            !0 === this.reversed && h.reverse();\n            if (0 < h.length) {\n                q = null;\n                p = f = x = z = 0;\n                x = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, g) : this.itemMaxWidth = Math.min(this.itemWidth, g) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, g) : this.itemMaxWidth = g;\n                r = 0 === r ? 0.75 * this.lineHeight : r;\n                x -= r + l;\n                for (s = 0; s < h.length; s++) {\n                    n = h[s];\n                    v = x;\n                    if (\"line\" === n.chartType || \"spline\" === n.chartType || \"stepLine\" === n.chartType)\n                        v -= 2 * 0.1 * this.lineHeight;\n                    if (!(0 >= k || \"undefined\" ===\n                        typeof k || 0 >= v || \"undefined\" === typeof v)) {\n                        if (\"horizontal\" === this.orientation) {\n                            n.textBlock = new ka(this.ctx, { x: 0, y: 0, maxWidth: v, maxHeight: this.itemWrap ? k : this.lineHeight, angle: 0, text: n.text, horizontalAlign: \"left\", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: \"middle\" });\n                            n.textBlock.measureText();\n                            null !== this.itemWidth && (n.textBlock.width = this.itemWidth - (r + l + (\"line\" === n.chartType || \"spline\" === n.chartType || \"stepLine\" ===\n                                n.chartType ? 2 * 0.1 * this.lineHeight : 0)));\n                            if (!q || q.width + Math.round(n.textBlock.width + r + l + (0 === q.width ? 0 : this.horizontalSpacing) + (\"line\" === n.chartType || \"spline\" === n.chartType || \"stepLine\" === n.chartType ? 2 * 0.1 * this.lineHeight : 0)) > g)\n                                q = { items: [], width: 0 }, m.push(q), this.height += f, f = 0;\n                            f = Math.max(f, n.textBlock.height);\n                        }\n                        else\n                            n.textBlock = new ka(this.ctx, { x: 0, y: 0, maxWidth: x, maxHeight: !0 === this.itemWrap ? k : 1.5 * this.fontSize, angle: 0, text: n.text, horizontalAlign: \"left\", fontSize: this.fontSize, fontFamily: this.fontFamily,\n                                fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: \"middle\" }), n.textBlock.measureText(), null !== this.itemWidth && (n.textBlock.width = this.itemWidth - (r + l + (\"line\" === n.chartType || \"spline\" === n.chartType || \"stepLine\" === n.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < k - this.lineHeight ? (q = { items: [], width: 0 }, m.push(q)) : (q = m[z], z = (z + 1) % m.length), this.height += n.textBlock.height;\n                        n.textBlock.x = q.width;\n                        n.textBlock.y = 0;\n                        q.width += Math.round(n.textBlock.width + r + l + (0 === q.width ?\n                            0 : this.horizontalSpacing) + (\"line\" === n.chartType || \"spline\" === n.chartType || \"stepLine\" === n.chartType ? 2 * 0.1 * this.lineHeight : 0));\n                        q.items.push(n);\n                        this.width = Math.max(q.width, this.width);\n                        p = n.textBlock.width + (r + l + (\"line\" === n.chartType || \"spline\" === n.chartType || \"stepLine\" === n.chartType ? 2 * 0.1 * this.lineHeight : 0));\n                    }\n                }\n                this.itemWidth = p;\n                this.height = !1 === this.itemWrap ? m.length * this.lineHeight : this.height + f;\n                this.height = Math.min(k, this.height);\n                this.width = Math.min(g, this.width);\n            }\n            \"top\" === this.verticalAlign ? (e = \"left\" === this.horizontalAlign ?\n                d.x1 : \"right\" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y1) : \"center\" === this.verticalAlign ? (e = \"left\" === this.horizontalAlign ? d.x1 : \"right\" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y1 + d.height / 2 - this.height / 2) : \"bottom\" === this.verticalAlign && (e = \"left\" === this.horizontalAlign ? d.x1 : \"right\" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y2 - this.height);\n            this.items = h;\n            for (s = 0; s < this.items.length; s++)\n                n = h[s], n.id = ++this.chart._eventManager.lastObjectId,\n                    this.chart._eventManager.objectMap[n.id] = { id: n.id, objectType: \"legendItem\", legendItemIndex: s, dataSeriesIndex: n.dataSeriesIndex, dataPointIndex: n.dataPointIndex };\n            this.markerSize = r;\n            this.rows = m;\n            0 < h.length && a.layoutManager.registerSpace(b, { width: this.width + 2 + 2, height: this.height + 5 + 5 });\n            this.bounds = { x1: e, y1: c, x2: e + this.width, y2: c + this.height };\n        };\n        H.prototype.render = function () {\n            var a = this.bounds.x1, d = this.bounds.y1, b = this.markerMargin, c = this.maxWidth, e = this.maxHeight, g = this.markerSize, k = this.rows;\n            (0 < this.borderThickness &&\n                this.borderColor || this.backgroundColor) && this.ctx.roundRect(a, d, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);\n            for (var l = 0, h = 0; h < k.length; h++) {\n                for (var m = k[h], s = 0, q = 0; q < m.items.length; q++) {\n                    var n = m.items[q], f = n.textBlock.x + a + (0 === q ? 0.2 * g : this.horizontalSpacing), p = d + l, u = f;\n                    this.chart.data[n.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);\n                    this.ctx.save();\n                    this.ctx.beginPath();\n                    this.ctx.rect(a, d, c, Math.max(e - e % this.lineHeight, 0));\n                    this.ctx.clip();\n                    if (\"line\" === n.chartType || \"stepLine\" === n.chartType || \"spline\" === n.chartType)\n                        this.ctx.strokeStyle = n.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(f - 0.1 * this.lineHeight, p + this.lineHeight / 2), this.ctx.lineTo(f + 0.85 * this.lineHeight, p + this.lineHeight / 2), this.ctx.stroke(), u -= 0.1 * this.lineHeight;\n                    if (\"error\" === n.chartType) {\n                        this.ctx.strokeStyle = this.errorMarkerColor[0];\n                        this.ctx.lineWidth = g / 8;\n                        this.ctx.beginPath();\n                        var r = f - 0.08 * this.lineHeight + 0.1 * this.lineHeight, t = p + 0.15 * this.lineHeight, v = 0.7 * this.lineHeight, x = v + 0.02 * this.lineHeight;\n                        this.ctx.moveTo(r, t);\n                        this.ctx.lineTo(r + v, t);\n                        this.ctx.stroke();\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(r + v / 2, t);\n                        this.ctx.lineTo(r + v / 2, t + x);\n                        this.ctx.stroke();\n                        this.ctx.beginPath();\n                        this.ctx.moveTo(r, t + x);\n                        this.ctx.lineTo(r + v, t + x);\n                        this.ctx.stroke();\n                        this.errorMarkerColor.shift();\n                    }\n                    ia.drawMarker(f + g / 2, p + this.lineHeight / 2, this.ctx, n.markerType, \"error\" === n.chartType || \"line\" === n.chartType || \"spline\" === n.chartType ? n.markerSize / 2 : n.markerSize, n.markerColor, n.markerBorderColor, n.markerBorderThickness);\n                    n.textBlock.x = f + b + g;\n                    if (\"line\" === n.chartType || \"stepLine\" === n.chartType || \"spline\" === n.chartType)\n                        n.textBlock.x += 0.1 * this.lineHeight;\n                    n.textBlock.y = Math.round(p + this.lineHeight / 2);\n                    n.textBlock.render(!0);\n                    this.ctx.restore();\n                    s = 0 < q ? Math.max(s, n.textBlock.height) : n.textBlock.height;\n                    this.chart.data[n.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);\n                    f = N(n.id);\n                    this.ghostCtx.fillStyle = f;\n                    this.ghostCtx.beginPath();\n                    this.ghostCtx.fillRect(u, n.textBlock.y - this.lineHeight /\n                        2, n.textBlock.x + n.textBlock.width - u, n.textBlock.height);\n                    n.x1 = this.chart._eventManager.objectMap[n.id].x1 = u;\n                    n.y1 = this.chart._eventManager.objectMap[n.id].y1 = n.textBlock.y - this.lineHeight / 2;\n                    n.x2 = this.chart._eventManager.objectMap[n.id].x2 = n.textBlock.x + n.textBlock.width;\n                    n.y2 = this.chart._eventManager.objectMap[n.id].y2 = n.textBlock.y + n.textBlock.height - this.lineHeight / 2;\n                }\n                l += s;\n            }\n        };\n        qa(F, V);\n        F.prototype.getDefaultAxisPlacement = function () {\n            var a = this.type;\n            if (\"column\" === a || \"line\" === a || \"stepLine\" === a || \"spline\" ===\n                a || \"area\" === a || \"stepArea\" === a || \"splineArea\" === a || \"stackedColumn\" === a || \"stackedLine\" === a || \"bubble\" === a || \"scatter\" === a || \"stackedArea\" === a || \"stackedColumn100\" === a || \"stackedLine100\" === a || \"stackedArea100\" === a || \"candlestick\" === a || \"ohlc\" === a || \"rangeColumn\" === a || \"rangeArea\" === a || \"rangeSplineArea\" === a || \"boxAndWhisker\" === a || \"waterfall\" === a)\n                return \"normal\";\n            if (\"bar\" === a || \"stackedBar\" === a || \"stackedBar100\" === a || \"rangeBar\" === a)\n                return \"xySwapped\";\n            if (\"pie\" === a || \"doughnut\" === a || \"funnel\" === a || \"pyramid\" === a)\n                return \"none\";\n            \"error\" !== a && window.console.log(\"Unknown Chart Type: \" + a);\n            return null;\n        };\n        F.getDefaultLegendMarker = function (a) {\n            if (\"column\" === a || \"stackedColumn\" === a || \"stackedLine\" === a || \"bar\" === a || \"stackedBar\" === a || \"stackedBar100\" === a || \"bubble\" === a || \"scatter\" === a || \"stackedColumn100\" === a || \"stackedLine100\" === a || \"stepArea\" === a || \"candlestick\" === a || \"ohlc\" === a || \"rangeColumn\" === a || \"rangeBar\" === a || \"rangeArea\" === a || \"rangeSplineArea\" === a || \"boxAndWhisker\" === a || \"waterfall\" === a)\n                return \"square\";\n            if (\"line\" === a || \"stepLine\" === a || \"spline\" ===\n                a || \"pie\" === a || \"doughnut\" === a)\n                return \"circle\";\n            if (\"area\" === a || \"splineArea\" === a || \"stackedArea\" === a || \"stackedArea100\" === a || \"funnel\" === a || \"pyramid\" === a)\n                return \"triangle\";\n            if (\"error\" === a)\n                return \"none\";\n            window.console.log(\"Unknown Chart Type: \" + a);\n            return null;\n        };\n        F.prototype.getDataPointAtX = function (a, d) {\n            if (!this.dataPoints || 0 === this.dataPoints.length)\n                return null;\n            var b = { dataPoint: null, distance: Infinity, index: NaN }, c = null, e = 0, g = 0, k = 1, l = Infinity, h = 0, m = 0, s = 0;\n            \"none\" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ?\n                (s = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), s = 1 < s ? Math.min(Math.max((this.dataPoints.length - 1) / s * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (s = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, s = 0 < s ? Math.min(Math.max((this.dataPoints.length - 1) / s * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));\n            for (;;) {\n                g = 0 < k ? s + e : s - e;\n                if (0 <= g && g < this.dataPoints.length) {\n                    var c = this.dataPoints[g], q = this.axisX.logarithmic ? c.x > a ? c.x / a : a / c.x :\n                        Math.abs(c.x - a);\n                    q < b.distance && (b.dataPoint = c, b.distance = q, b.index = g);\n                    c = q;\n                    c <= l ? l = c : 0 < k ? h++ : m++;\n                    if (1E3 < h && 1E3 < m)\n                        break;\n                }\n                else if (0 > s - e && s + e >= this.dataPoints.length)\n                    break;\n                -1 === k ? (e++, k = 1) : k = -1;\n            }\n            return d || b.dataPoint.x !== a ? d && null !== b.dataPoint ? b : null : b;\n        };\n        F.prototype.getDataPointAtXY = function (a, d, b) {\n            if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || d < this.chart.plotArea.y1 || d > this.chart.plotArea.y2)\n                return null;\n            b = b || !1;\n            var c = [], e = 0, g = 0, k = 1, l = !1, h = Infinity, m = 0, s = 0, q = 0;\n            if (\"none\" !== this.chart.plotInfo.axisPlacement)\n                if (q = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: a, y: d }), this.axisX.logarithmic)\n                    var n = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), q = 1 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * Math.log(q / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;\n                else\n                    n = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, q = 0 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * (q - this.dataPoints[0].x) >>\n                        0, 0), this.dataPoints.length) : 0;\n            for (;;) {\n                g = 0 < k ? q + e : q - e;\n                if (0 <= g && g < this.dataPoints.length) {\n                    var n = this.chart._eventManager.objectMap[this.dataPointIds[g]], f = this.dataPoints[g], p = null;\n                    if (n) {\n                        switch (this.type) {\n                            case \"column\":\n                            case \"stackedColumn\":\n                            case \"stackedColumn100\":\n                            case \"bar\":\n                            case \"stackedBar\":\n                            case \"stackedBar100\":\n                            case \"rangeColumn\":\n                            case \"rangeBar\":\n                            case \"waterfall\":\n                            case \"error\":\n                                a >= n.x1 && (a <= n.x2 && d >= n.y1 && d <= n.y2) && (c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 -\n                                        a), Math.abs(n.x2 - a), Math.abs(n.y1 - d), Math.abs(n.y2 - d)) }), l = !0);\n                                break;\n                            case \"line\":\n                            case \"stepLine\":\n                            case \"spline\":\n                            case \"area\":\n                            case \"stepArea\":\n                            case \"stackedArea\":\n                            case \"stackedArea100\":\n                            case \"splineArea\":\n                            case \"scatter\":\n                                var u = na(\"markerSize\", f, this) || 4, r = b ? 20 : u, p = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - d, 2));\n                                p <= r && c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: p });\n                                n = Math.abs(n.x1 - a);\n                                n <= h ? h = n : 0 < k ? m++ : s++;\n                                p <= u / 2 && (l = !0);\n                                break;\n                            case \"rangeArea\":\n                            case \"rangeSplineArea\":\n                                u = na(\"markerSize\", f, this) ||\n                                    4;\n                                r = b ? 20 : u;\n                                p = Math.min(Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - d, 2)), Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y2 - d, 2)));\n                                p <= r && c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: p });\n                                n = Math.abs(n.x1 - a);\n                                n <= h ? h = n : 0 < k ? m++ : s++;\n                                p <= u / 2 && (l = !0);\n                                break;\n                            case \"bubble\":\n                                u = n.size;\n                                p = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - d, 2));\n                                p <= u / 2 && (c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: p }), l = !0);\n                                break;\n                            case \"pie\":\n                            case \"doughnut\":\n                                u = n.center;\n                                r = \"doughnut\" === this.type ? n.percentInnerRadius * n.radius :\n                                    0;\n                                p = Math.sqrt(Math.pow(u.x - a, 2) + Math.pow(u.y - d, 2));\n                                p < n.radius && p > r && (p = Math.atan2(d - u.y, a - u.x), 0 > p && (p += 2 * Math.PI), p = Number(((180 * (p / Math.PI) % 360 + 360) % 360).toFixed(12)), u = Number(((180 * (n.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), r = Number(((180 * (n.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === r && 1 < n.endAngle && (r = 360), u >= r && 0 !== f.y && (r += 360, p < u && (p += 360)), p > u && p < r && (c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: 0 }), l = !0));\n                                break;\n                            case \"funnel\":\n                            case \"pyramid\":\n                                p = n.funnelSection;\n                                d > p.y1 && d < p.y4 && (p.y6 ? d > p.y6 ? (g = p.x6 + (p.x5 - p.x6) / (p.y5 - p.y6) * (d - p.y6), p = p.x3 + (p.x4 - p.x3) / (p.y4 - p.y3) * (d - p.y3)) : (g = p.x1 + (p.x6 - p.x1) / (p.y6 - p.y1) * (d - p.y1), p = p.x2 + (p.x3 - p.x2) / (p.y3 - p.y2) * (d - p.y2)) : (g = p.x1 + (p.x4 - p.x1) / (p.y4 - p.y1) * (d - p.y1), p = p.x2 + (p.x3 - p.x2) / (p.y3 - p.y2) * (d - p.y2)), a > g && a < p && (c.push({ dataPoint: f, dataPointIndex: n.dataPointIndex, dataSeries: this, distance: 0 }), l = !0));\n                                break;\n                            case \"boxAndWhisker\":\n                                if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && d >= n.y4 - n.borderThickness / 2 && d <= n.y1 + n.borderThickness /\n                                    2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && d >= n.y1 && d <= n.y4)\n                                    c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - d), Math.abs(n.y3 - d)) }), l = !0;\n                                break;\n                            case \"candlestick\":\n                                if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && d >= n.y2 - n.borderThickness / 2 && d <= n.y3 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && d >= n.y1 && d <= n.y4)\n                                    c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - d), Math.abs(n.y3 - d)) }), l = !0;\n                                break;\n                            case \"ohlc\": if (Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && d >= n.y2 && d <= n.y3 || a >= n.x1 && a <= (n.x2 + n.x1) / 2 && d >= n.y1 - n.borderThickness / 2 && d <= n.y1 + n.borderThickness / 2 || a >= (n.x1 + n.x2) / 2 && a <= n.x2 && d >= n.y4 - n.borderThickness / 2 && d <= n.y4 + n.borderThickness / 2)\n                                c.push({ dataPoint: f, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - d), Math.abs(n.y3 - d)) }), l = !0;\n                        }\n                        if (l || 1E3 < m && 1E3 < s)\n                            break;\n                    }\n                }\n                else if (0 > q - e && q + e >=\n                    this.dataPoints.length)\n                    break;\n                -1 === k ? (e++, k = 1) : k = -1;\n            }\n            a = null;\n            for (d = 0; d < c.length; d++)\n                a ? c[d].distance <= a.distance && (a = c[d]) : a = c[d];\n            return a;\n        };\n        F.prototype.getMarkerProperties = function (a, d, b, c) {\n            var e = this.dataPoints;\n            return { x: d, y: b, ctx: c, type: e[a].markerType ? e[a].markerType : this.markerType, size: e[a].markerSize ? e[a].markerSize : this.markerSize, color: e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor : e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], borderColor: e[a].markerBorderColor ?\n                    e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, borderThickness: e[a].markerBorderThickness ? e[a].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null };\n        };\n        qa(z, V);\n        z.prototype.createExtraLabelsForLog = function (a) {\n            a = (a || 0) + 1;\n            if (!(5 < a)) {\n                var d = this.logLabelValues[0] || this.intervalStartPosition;\n                if (Math.log(this.range) / Math.log(d / this.viewportMinimum) < this.noTicks - 1) {\n                    for (var b = z.getNiceNumber((d - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), c = Math.ceil(this.viewportMinimum / b) * b; c < d; c += b)\n                        c < this.viewportMinimum || this.logLabelValues.push(c);\n                    this.logLabelValues.sort(Sa);\n                    this.createExtraLabelsForLog(a);\n                }\n            }\n        };\n        z.prototype.createLabels = function () {\n            var a, d, b = 0, c = 0, e, g = 0, k = 0, c = 0, c = this.interval, l = 0, h, m = 0.6 * this.chart.height, p;\n            a = !1;\n            var q = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], n = q.length ? u(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;\n            if (\"axisX\" !== this.type || \"dateTime\" !== this.valueType || this.logarithmic) {\n                e =\n                    this.viewportMaximum;\n                if (this.labels) {\n                    a = Math.ceil(c);\n                    for (var c = Math.ceil(this.intervalStartPosition), f = !1, b = c; b < this.viewportMaximum; b += a)\n                        if (this.labels[b])\n                            f = !0;\n                        else {\n                            f = !1;\n                            break;\n                        }\n                    f && (this.interval = a, this.intervalStartPosition = c);\n                }\n                if (this.logarithmic && !this.equidistantInterval)\n                    for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), c = 0, f = n; c < this.logLabelValues.length; c++)\n                        if (b = this.logLabelValues[c], b < this.viewportMinimum)\n                            c++;\n                        else {\n                            for (; f < q.length && b > q[f].endValue; f++)\n                                ;\n                            a = f < q.length &&\n                                b >= q[f].startValue && b <= q[f].endValue;\n                            p = b;\n                            a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: p, label: this.labels[p] ? this.labels[p] : null }) : \"axisX\" === this.type && this.labels[p] ? this.labels[p] : ba(p, this.valueFormatString, this.chart._cultureInfo), a = new ka(this.ctx, { x: 0, y: 0, maxWidth: g, maxHeight: k, angle: this.labelAngle, text: this.prefix + a + this.suffix, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius,\n                                horizontalAlign: \"left\", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\", borderThickness: 0 }), this._labels.push({ position: p, textBlock: a, effectiveHeight: null }));\n                        }\n                f = n;\n                for (b = this.intervalStartPosition; b <= e; b = parseFloat(1E-12 > this.interval ? this.logarithmic && this.equidistantInterval ? b * Math.pow(this.logarithmBase, this.interval) : b + this.interval : (this.logarithmic && this.equidistantInterval ?\n                    b * Math.pow(this.logarithmBase, this.interval) : b + this.interval).toFixed(12))) {\n                    for (; f < q.length && b > q[f].endValue; f++)\n                        ;\n                    a = f < q.length && b >= q[f].startValue && b <= q[f].endValue;\n                    p = b;\n                    a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: p, label: this.labels[p] ? this.labels[p] : null }) : \"axisX\" === this.type && this.labels[p] ? this.labels[p] : ba(p, this.valueFormatString, this.chart._cultureInfo), a = new ka(this.ctx, { x: 0, y: 0, maxWidth: g, maxHeight: k, angle: this.labelAngle, text: this.prefix + a + this.suffix,\n                        horizontalAlign: \"left\", backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" }), this._labels.push({ position: p, textBlock: a, effectiveHeight: null }));\n                }\n            }\n            else\n                for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), e = Ya(new Date(this.viewportMaximum), this.interval, this.intervalType), f = n, b = this.intervalStartPosition; b < e; Ya(b, c, this.intervalType)) {\n                    for (a = b.getTime(); f < q.length && a > q[f].endValue; f++)\n                        ;\n                    p = a;\n                    a = f < q.length && a >= q[f].startValue && a <= q[f].endValue;\n                    a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: new Date(p), label: this.labels[p] ? this.labels[p] : null }) : \"axisX\" === this.type && this.labels[p] ? this.labels[p] : Ca(p, this.valueFormatString, this.chart._cultureInfo),\n                        a = new ka(this.ctx, { x: 0, y: 0, maxWidth: g, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxHeight: k, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: \"left\", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" }), this._labels.push({ position: p, textBlock: a, effectiveHeight: null,\n                        breaksLabelType: void 0 }));\n                }\n            if (\"bottom\" === this._position || \"top\" === this._position)\n                l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * S[this.intervalType +\n                    \"Duration\"] * this.interval, g = \"undefined\" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (k = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize);\n            else if (\"left\" === this._position || \"right\" === this._position)\n                l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length -\n                    2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * S[this.intervalType + \"Duration\"] * this.interval, this.chart.panEnabled || (g = \"undefined\" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), k = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;\n            for (c = 0; c < this._labels.length; c++) {\n                a = this._labels[c].textBlock;\n                a.maxWidth = g;\n                a.maxHeight = k;\n                var B = a.measureText();\n                h = B.height;\n            }\n            e = [];\n            n = q = 0;\n            if (this.labelAutoFit || this.options.labelAutoFit)\n                if (u(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), \"bottom\" === this._position || \"top\" === this._position)\n                    if (g = 0.9 * l >> 0, n = 0, !this.chart.panEnabled && 1 <= this._labels.length) {\n                        this.sessionVariables.labelFontSize =\n                            this.labelFontSize;\n                        this.sessionVariables.labelMaxWidth = g;\n                        this.sessionVariables.labelMaxHeight = k;\n                        this.sessionVariables.labelAngle = this.labelAngle;\n                        this.sessionVariables.labelWrap = this.labelWrap;\n                        for (b = 0; b < this._labels.length; b++)\n                            if (!this._labels[b].breaksLabelType) {\n                                a = this._labels[b].textBlock;\n                                for (var v, f = a.text.split(\" \"), c = 0; c < f.length; c++)\n                                    p = f[c], this.ctx.font = a.fontStyle + \" \" + a.fontWeight + \" \" + a.fontSize + \"px \" + a.fontFamily, p = this.ctx.measureText(p), p.width > n && (v = b, n = p.width);\n                            }\n                        b = 0;\n                        for (b = this.intervalStartPosition <\n                            this.viewportMinimum ? 1 : 0; b < this._labels.length; b++)\n                            if (!this._labels[b].breaksLabelType) {\n                                a = this._labels[b].textBlock;\n                                B = a.measureText();\n                                for (f = b + 1; f < this._labels.length; f++)\n                                    if (!this._labels[f].breaksLabelType) {\n                                        d = this._labels[f].textBlock;\n                                        d = d.measureText();\n                                        break;\n                                    }\n                                e.push(a.height);\n                                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);\n                                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n                                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\n                                c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (k - a.fontSize / 2) *\n                                    Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n                                if (u(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle)\n                                    if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? k : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), p = (m - (h + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !u(this.options.labelWrap))\n                                        this.labelWrap ? u(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth =\n                                            Math.min(Math.max(g, n), p), this.sessionVariables.labelWrap = this.labelWrap, B.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle) : u(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelMaxWidth =\n                                            g, B.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = p)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelWrap = this.labelWrap);\n                                    else {\n                                        if (u(this.options.labelWrap))\n                                            if (!u(this.options.labelMaxWidth))\n                                                this.options.labelMaxWidth < g ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth,\n                                                    this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = k);\n                                            else if (!u(d))\n                                                if (c = B.width + d.width >> 0, f = this.labelFontSize, n < g)\n                                                    c - 2 * g > q && (q = c - 2 * g, c >= 2 * g && c < 2.2 * g ? (this.sessionVariables.labelMaxWidth = g, u(this.options.labelFontSize) && 12 < f && (f = Math.floor(12 / 13 * f), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelAngle =\n                                                        this.labelAngle) : c >= 2.2 * g && c < 2.8 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = p, this.sessionVariables.labelFontSize = f) : c >= 2.8 * g && c < 3.2 * g ? (this.sessionVariables.labelMaxWidth = Math.max(g, n), this.sessionVariables.labelWrap = !0, u(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelAngle =\n                                                        this.labelAngle) : c >= 3.2 * g && c < 3.6 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = p, this.sessionVariables.labelFontSize = this.labelFontSize) : c > 3.6 * g && c < 5 * g ? (u(this.options.labelFontSize) && 12 < f && (f = Math.floor(12 / 13 * f), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = p) :\n                                                        c > 5 * g && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelFontSize = f, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelAngle = this.labelAngle));\n                                                else if (v === b && (0 === v && n + this._labels[v + 1].textBlock.measureText().width - 2 * g > q || v === this._labels.length - 1 && n + this._labels[v - 1].textBlock.measureText().width - 2 * g > q || 0 < v && v < this._labels.length - 1 && n + this._labels[v + 1].textBlock.measureText().width - 2 * g > q && n + this._labels[v - 1].textBlock.measureText().width -\n                                                    2 * g > q))\n                                                    q = 0 === v ? n + this._labels[v + 1].textBlock.measureText().width - 2 * g : n + this._labels[v - 1].textBlock.measureText().width - 2 * g, this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = p;\n                                                else if (0 === q)\n                                                    for (this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? f : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, c = 0; c < this._labels.length; c++)\n                                                        a =\n                                                            this._labels[c].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), p), B = a.measureText(), c < this._labels.length - 1 && (f = c + 1, d = this._labels[f].textBlock, d.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), p), d = d.measureText(), B.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25));\n                                    }\n                                else\n                                    (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? k : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) /\n                                        Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), p = 0 != this.labelAngle ? (m - (h + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : g, this.sessionVariables.labelMaxHeight = k = this.labelWrap ? (m - p * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, u(this.options.labelWrap)) ? u(this.options.labelWrap) && (this.labelWrap && !u(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap =\n                                        this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : p, this.sessionVariables.labelMaxHeight = k) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = p, this.sessionVariables.labelMaxHeight = c < 0.9 * l ? 0.9 * l : c, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : p) :\n                                        (u(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : p, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = k);\n                            }\n                        for (c = 0; c < this._labels.length; c++)\n                            a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight =\n                                this.sessionVariables.labelMaxHeight, a.measureText();\n                    }\n                    else\n                        for (b = 0; b < this._labels.length; b++)\n                            a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = u(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = u(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = u(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = u(this.options.labelWrap) ?\n                                this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n                else if (\"left\" === this._position || \"right\" === this._position)\n                    if (g = u(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, k = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {\n                        this.sessionVariables.labelFontSize = this.labelFontSize;\n                        this.sessionVariables.labelMaxWidth =\n                            g;\n                        this.sessionVariables.labelMaxHeight = k;\n                        this.sessionVariables.labelAngle = u(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;\n                        this.sessionVariables.labelWrap = this.labelWrap;\n                        for (b = 0; b < this._labels.length; b++)\n                            if (!this._labels[b].breaksLabelType) {\n                                a = this._labels[b].textBlock;\n                                B = a.measureText();\n                                for (f = b + 1; f < this._labels.length; f++)\n                                    if (!this._labels[f].breaksLabelType) {\n                                        d = this._labels[f].textBlock;\n                                        d = d.measureText();\n                                        break;\n                                    }\n                                e.push(a.height);\n                                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);\n                                c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (k - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n                                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n                                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\n                                u(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? u(this.options.labelWrap) ? u(this.options.labelWrap) && (u(this.options.labelMaxWidth) ? u(d) || (l = B.height + d.height >> 0, l - 2 * k > n && (n = l - 2 * k, l >= 2 * k && l < 2.4 * k ? (u(this.options.labelFontSize) && 12 < this.labelFontSize &&\n                                    (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : l >= 2.4 * k && l < 2.8 * k ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : l >= 2.8 * k && l < 3.2 * k ? (this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelWrap = !0, u(this.options.labelFontSize) && 12 <\n                                    this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = u(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l >= 3.2 * k && l < 3.6 * k ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : l > 3.6 * k && l < 10 * k ? (u(this.options.labelFontSize) &&\n                                    12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelAngle = u(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l > 10 * k && l < 50 * k && (u(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize),\n                                    a.measureText()), this.sessionVariables.labelFontSize = u(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelAngle = u(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = k, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth =\n                                    this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = k) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? g : Math.min((c - k * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), k), u(this.options.labelWrap)) ?\n                                    u(this.options.labelWrap) && (this.labelWrap && !u(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth > this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? k : c, u(this.options.labelMaxWidth) &&\n                                        (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? k : c, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = g) : (this.sessionVariables.labelMaxHeight = k, u(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap);\n                            }\n                        for (c = 0; c < this._labels.length; c++)\n                            a =\n                                this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n                    }\n                    else\n                        for (b = 0; b < this._labels.length; b++)\n                            a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = u(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth,\n                                a.fontSize = this.labelFontSize = u(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = u(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = u(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\n            for (b = 0; b < this.stripLines.length; b++) {\n                var g = this.stripLines[b], z;\n                if (\"outside\" === g.labelPlacement) {\n                    k = this.sessionVariables.labelMaxWidth;\n                    if (\"bottom\" === this._position || \"top\" === this._position)\n                        z = u(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;\n                    if (\"left\" === this._position || \"right\" === this._position)\n                        z = u(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;\n                    u(g.labelBackgroundColor) && (g.labelBackgroundColor = \"#EEEEEE\");\n                }\n                else\n                    k = \"bottom\" === this._position || \"top\" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >>\n                        0, z = u(g.options.labelWrap) || g.labelWrap ? \"bottom\" === this._position || \"top\" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, u(g.labelBackgroundColor) && (u(g.startValue) && 0 !== g.startValue ? g.labelBackgroundColor = r ? \"transparent\" : null : g.labelBackgroundColor = \"#EEEEEE\");\n                a = new ka(this.ctx, { x: 0, y: 0, backgroundColor: g.labelBackgroundColor, borderColor: g.labelBorderColor, borderThickness: g.labelBorderThickness, cornerRadius: g.labelCornerRadius, maxWidth: g.options.labelMaxWidth ?\n                        g.options.labelMaxWidth : k, maxHeight: z, angle: this.labelAngle, text: g.labelFormatter ? g.labelFormatter({ chart: this.chart, axis: this, stripLine: g }) : g.label, horizontalAlign: \"left\", fontSize: \"outside\" === g.labelPlacement ? g.options.labelFontSize ? g.labelFontSize : this.labelFontSize : g.labelFontSize, fontFamily: \"outside\" === g.labelPlacement ? g.options.labelFontFamily ? g.labelFontFamily : this.labelFontFamily : g.labelFontFamily, fontWeight: \"outside\" === g.labelPlacement ? g.options.labelFontWeight ? g.labelFontWeight : this.labelFontWeight :\n                        g.labelFontWeight, fontColor: g.labelFontColor || g.color, fontStyle: \"outside\" === g.labelPlacement ? g.options.labelFontStyle ? g.labelFontStyle : this.fontWeight : g.labelFontStyle, textBaseline: \"middle\" });\n                this._stripLineLabels.push({ position: g.value, textBlock: a, effectiveHeight: null, stripLine: g });\n            }\n        };\n        z.prototype.createLabelsAndCalculateWidth = function () {\n            var a = 0, d = 0;\n            this._labels = [];\n            this._stripLineLabels = [];\n            var b = this.chart.isNavigator ? 0 : 5;\n            if (\"left\" === this._position || \"right\" === this._position) {\n                this.createLabels();\n                for (d =\n                    0; d < this._labels.length; d++) {\n                    var c = this._labels[d].textBlock, e = c.measureText(), g = 0, g = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\n                    a < g && (a = g);\n                    this._labels[d].effectiveWidth = g;\n                }\n                for (d = 0; d < this._stripLineLabels.length; d++)\n                    \"outside\" === this._stripLineLabels[d].stripLine.labelPlacement && (this._stripLineLabels[d].stripLine.value >= this.viewportMinimum && this._stripLineLabels[d].stripLine.value <= this.viewportMaximum) &&\n                        (c = this._stripLineLabels[d].textBlock, e = c.measureText(), g = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a < g && (a = g), this._stripLineLabels[d].effectiveWidth = g);\n            }\n            d = this.title ? this._titleTextBlock.measureText().height + 2 : 0;\n            return c = \"inside\" === this.labelPlacement ? c = d + b : d + a + this.tickLength + b;\n        };\n        z.prototype.createLabelsAndCalculateHeight = function () {\n            var a = 0;\n            this._labels = [];\n            this._stripLineLabels = [];\n            var d, b = 0, c = this.chart.isNavigator ? 0 : 5;\n            this.createLabels();\n            if (\"bottom\" === this._position || \"top\" === this._position) {\n                for (b = 0; b < this._labels.length; b++) {\n                    d = this._labels[b].textBlock;\n                    var e = d.measureText(), g = 0, g = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - d.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n                    a < g && (a = g);\n                    this._labels[b].effectiveHeight = g;\n                }\n                for (b = 0; b < this._stripLineLabels.length; b++)\n                    \"outside\" === this._stripLineLabels[b].stripLine.labelPlacement &&\n                        (this._stripLineLabels[b].stripLine.value >= this.viewportMinimum && this._stripLineLabels[b].stripLine.value <= this.viewportMaximum) && (d = this._stripLineLabels[b].textBlock, e = d.measureText(), g = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - d.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a < g && (a = g), this._stripLineLabels[b].effectiveHeight = g);\n            }\n            d = this.title ? this._titleTextBlock.measureText().height + 2 : 0;\n            return b = \"inside\" === this.labelPlacement ? b =\n                d + c : d + a + this.tickLength + c;\n        };\n        z.setLayout = function (a, d, b, c, e, g) {\n            var k, l, h, m, p = a[0] ? a[0].chart : d[0].chart, q = p.isNavigator ? 0 : 10, n = p._axes;\n            if (a && 0 < a.length)\n                for (var f = 0; f < a.length; f++)\n                    a[f] && a[f].calculateAxisParameters();\n            if (d && 0 < d.length)\n                for (f = 0; f < d.length; f++)\n                    d[f].calculateAxisParameters();\n            if (b && 0 < b.length)\n                for (f = 0; f < b.length; f++)\n                    b[f].calculateAxisParameters();\n            if (c && 0 < c.length)\n                for (f = 0; f < c.length; f++)\n                    c[f].calculateAxisParameters();\n            for (f = 0; f < n.length; f++)\n                if (n[f] && n[f].scaleBreaks && n[f].scaleBreaks._appliedBreaks.length)\n                    for (var r = n[f].scaleBreaks._appliedBreaks, v = 0; v < r.length && !(r[v].startValue > n[f].viewportMaximum); v++)\n                        r[v].endValue < n[f].viewportMinimum || (u(n[f].scaleBreaks.firstBreakIndex) && (n[f].scaleBreaks.firstBreakIndex = v), r[v].startValue >= n[f].viewPortMinimum && (n[f].scaleBreaks.lastBreakIndex = v));\n            for (var z = v = 0, t = 0, C = 0, x = 0, D = 0, y = 0, A, E, F = l = 0, H, I, L, r = H = I = L = !1, f = 0; f < n.length; f++)\n                n[f] && n[f].title && (n[f]._titleTextBlock = new ka(n[f].ctx, { text: n[f].title, horizontalAlign: \"center\", fontSize: n[f].titleFontSize, fontFamily: n[f].titleFontFamily,\n                    fontWeight: n[f].titleFontWeight, fontColor: n[f].titleFontColor, fontStyle: n[f].titleFontStyle, borderColor: n[f].titleBorderColor, borderThickness: n[f].titleBorderThickness, backgroundColor: n[f].titleBackgroundColor, cornerRadius: n[f].titleCornerRadius, textBaseline: \"top\" }));\n            for (f = 0; f < n.length; f++)\n                if (n[f].title)\n                    switch (n[f]._position) {\n                        case \"left\":\n                            n[f]._titleTextBlock.maxWidth = n[f].titleMaxWidth || g.height;\n                            n[f]._titleTextBlock.maxHeight = n[f].titleWrap ? 0.8 * g.width : 1.5 * n[f].titleFontSize;\n                            n[f]._titleTextBlock.angle =\n                                -90;\n                            break;\n                        case \"right\":\n                            n[f]._titleTextBlock.maxWidth = n[f].titleMaxWidth || g.height;\n                            n[f]._titleTextBlock.maxHeight = n[f].titleWrap ? 0.8 * g.width : 1.5 * n[f].titleFontSize;\n                            n[f]._titleTextBlock.angle = 90;\n                            break;\n                        default: n[f]._titleTextBlock.maxWidth = n[f].titleMaxWidth || g.width, n[f]._titleTextBlock.maxHeight = n[f].titleWrap ? 0.8 * g.height : 1.5 * n[f].titleFontSize, n[f]._titleTextBlock.angle = 0;\n                    }\n            if (\"normal\" === e) {\n                for (var C = [], x = [], D = [], y = [], M = [], N = [], O = [], Q = []; 4 > v;) {\n                    var G = 0, R = 0, S = 0, U = 0, W = e = 0, K = 0, $ = 0, V = 0, X = 0, P = 0, ba = 0;\n                    if (b &&\n                        0 < b.length)\n                        for (D = [], f = P = 0; f < b.length; f++)\n                            D.push(Math.ceil(b[f] ? b[f].createLabelsAndCalculateWidth() : 0)), P += D[f], K += b[f] && !p.isNavigator ? b[f].margin : 0;\n                    else\n                        D.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));\n                    O.push(D);\n                    if (c && 0 < c.length)\n                        for (y = [], f = ba = 0; f < c.length; f++)\n                            y.push(Math.ceil(c[f] ? c[f].createLabelsAndCalculateWidth() : 0)), ba += y[f], $ += c[f] ? c[f].margin : 0;\n                    else\n                        y.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0));\n                    Q.push(y);\n                    k = Math.round(g.x1 + P + K);\n                    h = Math.round(g.x2 - ba - $ > p.width -\n                        q ? p.width - q : g.x2 - ba - $);\n                    if (a && 0 < a.length)\n                        for (C = [], f = V = 0; f < a.length; f++)\n                            a[f] && (a[f].lineCoordinates = {}), a[f].lineCoordinates.width = Math.abs(h - k), a[f].title && (a[f]._titleTextBlock.maxWidth = 0 < a[f].titleMaxWidth && a[f].titleMaxWidth < a[f].lineCoordinates.width ? a[f].titleMaxWidth : a[f].lineCoordinates.width), C.push(Math.ceil(a[f] ? a[f].createLabelsAndCalculateHeight() : 0)), V += C[f], e += a[f] && !p.isNavigator ? a[f].margin : 0;\n                    else\n                        C.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));\n                    M.push(C);\n                    if (d && 0 < d.length)\n                        for (x =\n                            [], f = X = 0; f < d.length; f++)\n                            d[f] && (d[f].lineCoordinates = {}), d[f].lineCoordinates.width = Math.abs(h - k), d[f].title && (d[f]._titleTextBlock.maxWidth = 0 < d[f].titleMaxWidth && d[f].titleMaxWidth < d[f].lineCoordinates.width ? d[f].titleMaxWidth : d[f].lineCoordinates.width), x.push(Math.ceil(d[f] ? d[f].createLabelsAndCalculateHeight() : 0)), X += x[f], W += d[f] && !p.isNavigator ? d[f].margin : 0;\n                    else\n                        x.push(Math.ceil(d[0] ? d[0].createLabelsAndCalculateHeight() : 0));\n                    N.push(x);\n                    if (a && 0 < a.length)\n                        for (f = 0; f < a.length; f++)\n                            a[f] && (a[f].lineCoordinates.x1 =\n                                k, h = Math.round(g.x2 - ba - $ > p.width - q ? p.width - q : g.x2 - ba - $), a[f]._labels && 1 < a[f]._labels.length && (l = m = 0, m = a[f]._labels[1], l = \"dateTime\" === a[f].valueType ? a[f]._labels[a[f]._labels.length - 2] : a[f]._labels[a[f]._labels.length - 1], z = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), t = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI /\n                                180 * Math.abs(l.textBlock.angle))), !a[f] || (!a[f].labelAutoFit || u(A) || u(E) || p.isNavigator) || (l = 0, 0 < a[f].labelAngle ? E + t > h && (l += 0 < a[f].labelAngle ? E + t - h - ba : 0) : 0 > a[f].labelAngle ? A - z < k && A - z < a[f].viewportMinimum && (F = k - (K + a[f].tickLength + D + A - z + a[f].labelFontSize / 2)) : 0 === a[f].labelAngle && (E + t > h && (l = E + t / 2 - h - ba), A - z < k && A - z < a[f].viewportMinimum && (F = k - K - a[f].tickLength - D - A + z / 2)), a[f].viewportMaximum === a[f].maximum && a[f].viewportMinimum === a[f].minimum && 0 < a[f].labelAngle && 0 < l ? h -= l : a[f].viewportMaximum === a[f].maximum &&\n                                a[f].viewportMinimum === a[f].minimum && 0 > a[f].labelAngle && 0 < F ? k += F : a[f].viewportMaximum === a[f].maximum && a[f].viewportMinimum === a[f].minimum && 0 === a[f].labelAngle && (0 < F && (k += F), 0 < l && (h -= l))), p.panEnabled ? V = p.sessionVariables.axisX.height : p.sessionVariables.axisX.height = V, l = Math.round(g.y2 - V - e + G), m = Math.round(g.y2), a[f].lineCoordinates.x2 = h, a[f].lineCoordinates.width = h - k, a[f].lineCoordinates.y1 = l, a[f].lineCoordinates.y2 = l, a[f].bounds = { x1: k, y1: l, x2: h, y2: m - (V + e - C[f] - G), width: h - k, height: m - l }), G += C[f] + a[f].margin;\n                    if (d && 0 < d.length)\n                        for (f = 0; f < d.length; f++)\n                            d[f].lineCoordinates.x1 = Math.round(g.x1 + P + K), d[f].lineCoordinates.x2 = Math.round(g.x2 - ba - $ > p.width - q ? p.width - q : g.x2 - ba - $), d[f].lineCoordinates.width = Math.abs(h - k), d[f]._labels && 1 < d[f]._labels.length && (m = d[f]._labels[1], l = \"dateTime\" === d[f].valueType ? d[f]._labels[d[f]._labels.length - 2] : d[f]._labels[d[f]._labels.length - 1], z = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)),\n                                t = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), p.panEnabled ? X = p.sessionVariables.axisX2.height : p.sessionVariables.axisX2.height = X, l = Math.round(g.y1), m = Math.round(g.y2 + d[f].margin), d[f].lineCoordinates.y1 = l + X + W - R, d[f].lineCoordinates.y2 = l, d[f].bounds = { x1: k, y1: l + (X + W - x[f] - R), x2: h, y2: m, width: h - k, height: m - l }, R += x[f] + d[f].margin;\n                    if (b && 0 < b.length)\n                        for (f = 0; f < b.length; f++)\n                            K = p.isNavigator ? 0 :\n                                10, b[f] && (k = Math.round(a[0] ? a[0].lineCoordinates.x1 : d[0].lineCoordinates.x1), K = b[f]._labels && 0 < b[f]._labels.length ? b[f]._labels[b[f]._labels.length - 1].textBlock.height / 2 : q, l = Math.round(g.y1 + X + W < Math.max(K, q) ? Math.max(K, q) : g.y1 + X + W), h = Math.round(a[0] ? a[0].lineCoordinates.x1 : d[0].lineCoordinates.x1), K = 0 < a.length ? 0 : b[f]._labels && 0 < b[f]._labels.length ? b[f]._labels[0].textBlock.height / 2 : q, m = Math.round(g.y2 - V - e - K), b[f].lineCoordinates = { x1: h - S, y1: l, x2: h - S, y2: m, height: Math.abs(m - l) }, b[f].bounds = { x1: k - (D[f] +\n                                    S), y1: l, x2: h, y2: m, width: h - k, height: m - l }, b[f].title && (b[f]._titleTextBlock.maxWidth = 0 < b[f].titleMaxWidth && b[f].titleMaxWidth < b[f].lineCoordinates.height ? b[f].titleMaxWidth : b[f].lineCoordinates.height), S += D[f] + b[f].margin);\n                    if (c && 0 < c.length)\n                        for (f = 0; f < c.length; f++)\n                            c[f] && (k = Math.round(a[0] ? a[0].lineCoordinates.x2 : d[0].lineCoordinates.x2), h = Math.round(k), K = c[f]._labels && 0 < c[f]._labels.length ? c[f]._labels[c[f]._labels.length - 1].textBlock.height / 2 : 0, l = Math.round(g.y1 + X + W < Math.max(K, q) ? Math.max(K, q) : g.y1 +\n                                X + W), K = 0 < a.length ? 0 : c[f]._labels && 0 < c[f]._labels.length ? c[f]._labels[0].textBlock.height / 2 : 0, m = Math.round(g.y2 - (V + e + K)), c[f].lineCoordinates = { x1: k + U, y1: l, x2: k + U, y2: m, height: Math.abs(m - l) }, c[f].bounds = { x1: k, y1: l, x2: h + (y[f] + U), y2: m, width: h - k, height: m - l }, c[f].title && (c[f]._titleTextBlock.maxWidth = 0 < c[f].titleMaxWidth && c[f].titleMaxWidth < c[f].lineCoordinates.height ? c[f].titleMaxWidth : c[f].lineCoordinates.height), U += y[f] + c[f].margin);\n                    if (a && 0 < a.length)\n                        for (f = 0; f < a.length; f++)\n                            a[f] && (a[f].calculateValueToPixelConversionParameters(),\n                                a[f].calculateBreaksSizeInValues(), a[f]._labels && 1 < a[f]._labels.length && (A = (a[f].logarithmic ? Math.log(a[f]._labels[1].position / a[f].viewportMinimum) / a[f].conversionParameters.lnLogarithmBase : a[f]._labels[1].position - a[f].viewportMinimum) * Math.abs(a[f].conversionParameters.pixelPerUnit) + a[f].lineCoordinates.x1, k = a[f]._labels[a[f]._labels.length - (\"dateTime\" === a[f].valueType ? 2 : 1)].position, k = a[f].getApparentDifference(a[f].viewportMinimum, k), E = a[f].logarithmic ? (1 < k ? Math.log(k) / a[f].conversionParameters.lnLogarithmBase *\n                                Math.abs(a[f].conversionParameters.pixelPerUnit) : 0) + a[f].lineCoordinates.x1 : (0 < k ? k * Math.abs(a[f].conversionParameters.pixelPerUnit) : 0) + a[f].lineCoordinates.x1));\n                    if (d && 0 < d.length)\n                        for (f = 0; f < d.length; f++)\n                            d[f].calculateValueToPixelConversionParameters(), d[f].calculateBreaksSizeInValues(), d[f]._labels && 1 < d[f]._labels.length && (A = (d[f].logarithmic ? Math.log(d[f]._labels[1].position / d[f].viewportMinimum) / d[f].conversionParameters.lnLogarithmBase : d[f]._labels[1].position - d[f].viewportMinimum) * Math.abs(d[f].conversionParameters.pixelPerUnit) +\n                                d[f].lineCoordinates.x1, k = d[f]._labels[d[f]._labels.length - (\"dateTime\" === d[f].valueType ? 2 : 1)].position, k = d[f].getApparentDifference(d[f].viewportMinimum, k), E = d[f].logarithmic ? (1 < k ? Math.log(k) / d[f].conversionParameters.lnLogarithmBase * Math.abs(d[f].conversionParameters.pixelPerUnit) : 0) + d[f].lineCoordinates.x1 : (0 < k ? k * Math.abs(d[f].conversionParameters.pixelPerUnit) : 0) + d[f].lineCoordinates.x1);\n                    for (f = 0; f < n.length; f++)\n                        \"axisY\" === n[f].type && (n[f].calculateValueToPixelConversionParameters(), n[f].calculateBreaksSizeInValues());\n                    if (0 < v) {\n                        if (a && 0 < a.length)\n                            for (f = 0; f < a.length; f++)\n                                r = M[v - 1][f] === M[v][f] ? !0 : !1;\n                        else\n                            r = !0;\n                        if (d && 0 < d.length)\n                            for (f = 0; f < d.length; f++)\n                                H = N[v - 1][f] === N[v][f] ? !0 : !1;\n                        else\n                            H = !0;\n                        if (b && 0 < b.length)\n                            for (f = 0; f < b.length; f++)\n                                I = O[v - 1][f] === O[v][f] ? !0 : !1;\n                        else\n                            I = !0;\n                        if (c && 0 < c.length)\n                            for (f = 0; f < c.length; f++)\n                                L = Q[v - 1][f] === Q[v][f] ? !0 : !1;\n                        else\n                            L = !0;\n                    }\n                    if (r && H && I && L)\n                        break;\n                    v++;\n                }\n                if (a && 0 < a.length)\n                    for (f = 0; f < a.length; f++)\n                        a[f].calculateStripLinesThicknessInValues(), a[f].calculateBreaksInPixels();\n                if (d && 0 < d.length)\n                    for (f = 0; f < d.length; f++)\n                        d[f].calculateStripLinesThicknessInValues(),\n                            d[f].calculateBreaksInPixels();\n                if (b && 0 < b.length)\n                    for (f = 0; f < b.length; f++)\n                        b[f].calculateStripLinesThicknessInValues(), b[f].calculateBreaksInPixels();\n                if (c && 0 < c.length)\n                    for (f = 0; f < c.length; f++)\n                        c[f].calculateStripLinesThicknessInValues(), c[f].calculateBreaksInPixels();\n            }\n            else {\n                q = [];\n                A = [];\n                F = [];\n                z = [];\n                E = [];\n                t = [];\n                M = [];\n                for (N = []; 4 > v;) {\n                    V = U = R = S = $ = K = W = e = Q = O = G = X = 0;\n                    if (a && 0 < a.length)\n                        for (F = [], f = U = 0; f < a.length; f++)\n                            F.push(Math.ceil(a[f] ? a[f].createLabelsAndCalculateWidth() : 0)), U += F[f], e += a[f] && !p.isNavigator ? a[f].margin : 0;\n                    else\n                        F.push(Math.ceil(a[0] ?\n                            a[0].createLabelsAndCalculateWidth() : 0));\n                    M.push(F);\n                    if (d && 0 < d.length)\n                        for (z = [], f = V = 0; f < d.length; f++)\n                            z.push(Math.ceil(d[f] ? d[f].createLabelsAndCalculateWidth() : 0)), V += z[f], W += d[f] ? d[f].margin : 0;\n                    else\n                        z.push(Math.ceil(d[0] ? d[0].createLabelsAndCalculateWidth() : 0));\n                    N.push(z);\n                    if (b && 0 < b.length)\n                        for (f = 0; f < b.length; f++)\n                            b[f].lineCoordinates = {}, k = Math.round(g.x1 + U + e), h = Math.round(g.x2 - V - W > p.width - 10 ? p.width - 10 : g.x2 - V - W), b[f].labelAutoFit && !u(C) && (0 < !a.length && (k = 0 > b[f].labelAngle ? Math.max(k, C) : 0 === b[f].labelAngle ?\n                                Math.max(k, C / 2) : k), 0 < !d.length && (h = 0 < b[f].labelAngle ? h - x / 2 : 0 === b[f].labelAngle ? h - x / 2 : h)), b[f].lineCoordinates.x1 = k, b[f].lineCoordinates.x2 = h, b[f].lineCoordinates.width = Math.abs(h - k), b[f].title && (b[f]._titleTextBlock.maxWidth = 0 < b[f].titleMaxWidth && b[f].titleMaxWidth < b[f].lineCoordinates.width ? b[f].titleMaxWidth : b[f].lineCoordinates.width);\n                    if (c && 0 < c.length)\n                        for (f = 0; f < c.length; f++)\n                            c[f].lineCoordinates = {}, k = Math.round(g.x1 + U + e), h = Math.round(g.x2 - V - W > c[f].chart.width - 10 ? c[f].chart.width - 10 : g.x2 - V - W), c[f] &&\n                                c[f].labelAutoFit && !u(D) && (0 < !a.length && (k = 0 < c[f].labelAngle ? Math.max(k, D) : 0 === c[f].labelAngle ? Math.max(k, D / 2) : k), 0 < !d.length && (h -= y / 2)), c[f].lineCoordinates.x1 = k, c[f].lineCoordinates.x2 = h, c[f].lineCoordinates.width = Math.abs(h - k), c[f].title && (c[f]._titleTextBlock.maxWidth = 0 < c[f].titleMaxWidth && c[f].titleMaxWidth < c[f].lineCoordinates.width ? c[f].titleMaxWidth : c[f].lineCoordinates.width);\n                    if (b && 0 < b.length)\n                        for (q = [], f = S = 0; f < b.length; f++)\n                            q.push(Math.ceil(b[f] ? b[f].createLabelsAndCalculateHeight() : 0)), S +=\n                                q[f] + b[f].margin, K += b[f].margin;\n                    else\n                        q.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));\n                    E.push(q);\n                    if (c && 0 < c.length)\n                        for (A = [], f = R = 0; f < c.length; f++)\n                            A.push(Math.ceil(c[f] ? c[f].createLabelsAndCalculateHeight() : 0)), R += A[f], $ += c[f].margin;\n                    else\n                        A.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateHeight() : 0));\n                    t.push(A);\n                    if (b && 0 < b.length)\n                        for (f = 0; f < b.length; f++)\n                            0 < b[f]._labels.length && (m = b[f]._labels[0], l = b[f]._labels[b[f]._labels.length - 1], C = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) +\n                                (m.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(m.textBlock.angle)), x = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));\n                    if (c && 0 < c.length)\n                        for (f = 0; f < c.length; f++)\n                            c[f] && 0 < c[f]._labels.length && (m = c[f]._labels[0], l = c[f]._labels[c[f]._labels.length - 1], D = m.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(m.textBlock.angle)) + (m.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI /\n                                180 * Math.abs(m.textBlock.angle)), y = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));\n                    if (p.panEnabled)\n                        for (f = 0; f < b.length; f++)\n                            q[f] = p.sessionVariables.axisY.height;\n                    else\n                        for (f = 0; f < b.length; f++)\n                            p.sessionVariables.axisY.height = q[f];\n                    if (b && 0 < b.length)\n                        for (f = b.length - 1; 0 <= f; f--)\n                            l = Math.round(g.y2), m = Math.round(g.y2 > b[f].chart.height - 10 ? b[f].chart.height - 10 : g.y2), b[f].lineCoordinates.y1 = l - (q[f] + b[f].margin +\n                                X), b[f].lineCoordinates.y2 = l - (q[f] + b[f].margin + X), b[f].bounds = { x1: k, y1: l - (q[f] + X + b[f].margin), x2: h, y2: m - (X + b[f].margin), width: h - k, height: q[f] }, b[f].title && (b[f]._titleTextBlock.maxWidth = 0 < b[f].titleMaxWidth && b[f].titleMaxWidth < b[f].lineCoordinates.width ? b[f].titleMaxWidth : b[f].lineCoordinates.width), X += q[f] + b[f].margin;\n                    if (c && 0 < c.length)\n                        for (f = c.length - 1; 0 <= f; f--)\n                            c[f] && (l = Math.round(g.y1), m = Math.round(g.y1 + (A[f] + c[f].margin + G)), c[f].lineCoordinates.y1 = m, c[f].lineCoordinates.y2 = m, c[f].bounds = { x1: k, y1: l +\n                                    (c[f].margin + G), x2: h, y2: m, width: h - k, height: R }, c[f].title && (c[f]._titleTextBlock.maxWidth = 0 < c[f].titleMaxWidth && c[f].titleMaxWidth < c[f].lineCoordinates.width ? c[f].titleMaxWidth : c[f].lineCoordinates.width), G += A[f] + c[f].margin);\n                    if (a && 0 < a.length)\n                        for (f = 0; f < a.length; f++) {\n                            K = a[f]._labels && 0 < a[f]._labels.length ? a[f]._labels[0].textBlock.fontSize / 2 : 0;\n                            k = Math.round(g.x1 + e);\n                            l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1) : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1;\n                            h = Math.round(g.x1 + U + e);\n                            m = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - S > p.height - Math.max(K, 10) ? p.height - Math.max(K, 10) : g.y2 - S) : g.y2 > p.height - Math.max(K, 10) ? p.height - Math.max(K, 10) : g.y2;\n                            if (b && 0 < b.length)\n                                for (K = 0; K < b.length; K++)\n                                    b[K] && b[K].labelAutoFit && (h = 0 > b[K].labelAngle ? Math.max(h, C) : 0 === b[K].labelAngle ? Math.max(h, C / 2) : h, k = 0 > b[K].labelAngle || 0 === b[K].labelAngle ? h - U : k);\n                            if (c && 0 < c.length)\n                                for (K = 0; K < c.length; K++)\n                                    c[K] && c[K].labelAutoFit && (h = c[K].lineCoordinates.x1, k = h - U);\n                            a[f].lineCoordinates =\n                                { x1: h - O, y1: l, x2: h - O, y2: m, height: Math.abs(m - l) };\n                            a[f].bounds = { x1: h - (F[f] + O), y1: l, x2: h, y2: m, width: h - k, height: m - l };\n                            a[f].title && (a[f]._titleTextBlock.maxWidth = 0 < a[f].titleMaxWidth && a[f].titleMaxWidth < a[f].lineCoordinates.height ? a[f].titleMaxWidth : a[f].lineCoordinates.height);\n                            a[f].calculateValueToPixelConversionParameters();\n                            a[f].calculateBreaksSizeInValues();\n                            O += F[f] + a[f].margin;\n                        }\n                    if (d && 0 < d.length)\n                        for (f = 0; f < d.length; f++) {\n                            K = d[f]._labels && 0 < d[f]._labels.length ? d[f]._labels[0].textBlock.fontSize / 2 : 0;\n                            k = Math.round(g.x1 -\n                                e);\n                            l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1) : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1;\n                            h = Math.round(g.x2 - V - W);\n                            m = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - S > p.height - Math.max(K, 10) ? p.height - Math.max(K, 10) : g.y2 - S) : g.y2 > p.height - Math.max(K, 10) ? p.height - Math.max(K, 10) : g.y2;\n                            if (b && 0 < b.length)\n                                for (K = 0; K < b.length; K++)\n                                    b[K] && b[K].labelAutoFit && (h = 0 > b[K].labelAngle ? Math.max(h, C) : 0 === b[K].labelAngle ? Math.max(h, C / 2) : h, k = 0 > b[K].labelAngle || 0 ===\n                                        b[K].labelAngle ? h - V : k);\n                            if (c && 0 < c.length)\n                                for (K = 0; K < c.length; K++)\n                                    c[K] && c[K].labelAutoFit && (h = c[K].lineCoordinates.x2, k = h - V);\n                            d[f].lineCoordinates = { x1: h + Q, y1: l, x2: h + Q, y2: m, height: Math.abs(m - l) };\n                            d[f].bounds = { x1: k, y1: l, x2: h + z[f] + Q, y2: m, width: h - k, height: m - l };\n                            d[f].title && (d[f]._titleTextBlock.maxWidth = 0 < d[f].titleMaxWidth && d[f].titleMaxWidth < d[f].lineCoordinates.height ? d[f].titleMaxWidth : d[f].lineCoordinates.height);\n                            d[f].calculateValueToPixelConversionParameters();\n                            d[f].calculateBreaksSizeInValues();\n                            Q += z[f] +\n                                d[f].margin;\n                        }\n                    for (f = 0; f < n.length; f++)\n                        \"axisY\" === n[f].type && (n[f].calculateValueToPixelConversionParameters(), n[f].calculateBreaksSizeInValues());\n                    if (0 < v) {\n                        if (a && 0 < a.length)\n                            for (f = 0; f < a.length; f++)\n                                r = M[v - 1][f] === M[v][f] ? !0 : !1;\n                        else\n                            r = !0;\n                        if (d && 0 < d.length)\n                            for (f = 0; f < d.length; f++)\n                                H = N[v - 1][f] === N[v][f] ? !0 : !1;\n                        else\n                            H = !0;\n                        if (b && 0 < b.length)\n                            for (f = 0; f < b.length; f++)\n                                I = E[v - 1][f] === E[v][f] ? !0 : !1;\n                        else\n                            I = !0;\n                        if (c && 0 < c.length)\n                            for (f = 0; f < c.length; f++)\n                                L = t[v - 1][f] === t[v][f] ? !0 : !1;\n                        else\n                            L = !0;\n                    }\n                    if (r && H && I && L)\n                        break;\n                    v++;\n                }\n                if (b && 0 < b.length)\n                    for (f =\n                        0; f < b.length; f++)\n                        b[f].calculateStripLinesThicknessInValues(), b[f].calculateBreaksInPixels();\n                if (c && 0 < c.length)\n                    for (f = 0; f < c.length; f++)\n                        c[f].calculateStripLinesThicknessInValues(), c[f].calculateBreaksInPixels();\n                if (a && 0 < a.length)\n                    for (f = 0; f < a.length; f++)\n                        a[f].calculateStripLinesThicknessInValues(), a[f].calculateBreaksInPixels();\n                if (d && 0 < d.length)\n                    for (f = 0; f < d.length; f++)\n                        d[f].calculateStripLinesThicknessInValues(), d[f].calculateBreaksInPixels();\n            }\n        };\n        z.render = function (a, d, b, c, e) {\n            var g = a[0] ? a[0].chart : d[0].chart;\n            e = g.ctx;\n            var k = g._axes;\n            g.alignVerticalAxes && g.alignVerticalAxes();\n            e.save();\n            e.beginPath();\n            a[0] && e.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[0].bounds.height);\n            d[0] && e.rect(5, d[d.length - 1].bounds.y1, d[0].chart.width - 10, d[0].bounds.height);\n            e.clip();\n            if (a && 0 < a.length)\n                for (var l = 0; l < a.length; l++)\n                    a[l].renderLabelsTicksAndTitle();\n            if (d && 0 < d.length)\n                for (l = 0; l < d.length; l++)\n                    d[l].renderLabelsTicksAndTitle();\n            e.restore();\n            if (b && 0 < b.length)\n                for (l = 0; l < b.length; l++)\n                    b[l].renderLabelsTicksAndTitle();\n            if (c && 0 < c.length)\n                for (l =\n                    0; l < c.length; l++)\n                    c[l].renderLabelsTicksAndTitle();\n            g.preparePlotArea();\n            g = g.plotArea;\n            e.save();\n            e.beginPath();\n            e.rect(g.x1, g.y1, Math.abs(g.x2 - g.x1), Math.abs(g.y2 - g.y1));\n            e.clip();\n            if (a && 0 < a.length)\n                for (l = 0; l < k.length; l++)\n                    k[l].renderStripLinesOfThicknessType(\"value\");\n            if (d && 0 < d.length)\n                for (l = 0; l < d.length; l++)\n                    d[l].renderStripLinesOfThicknessType(\"value\");\n            if (b && 0 < b.length)\n                for (l = 0; l < b.length; l++)\n                    b[l].renderStripLinesOfThicknessType(\"value\");\n            if (c && 0 < c.length)\n                for (l = 0; l < c.length; l++)\n                    c[l].renderStripLinesOfThicknessType(\"value\");\n            if (a && 0 < a.length)\n                for (l = 0; l < a.length; l++)\n                    a[l].renderInterlacedColors();\n            if (d && 0 < d.length)\n                for (l = 0; l < d.length; l++)\n                    d[l].renderInterlacedColors();\n            if (b && 0 < b.length)\n                for (l = 0; l < b.length; l++)\n                    b[l].renderInterlacedColors();\n            if (c && 0 < c.length)\n                for (l = 0; l < c.length; l++)\n                    c[l].renderInterlacedColors();\n            e.restore();\n            if (a && 0 < a.length)\n                for (l = 0; l < a.length; l++)\n                    a[l].renderGrid(), r && (a[l].createMask(), a[l].renderBreaksBackground());\n            if (d && 0 < d.length)\n                for (l = 0; l < d.length; l++)\n                    d[l].renderGrid(), r && (d[l].createMask(), d[l].renderBreaksBackground());\n            if (b && 0 < b.length)\n                for (l = 0; l < b.length; l++)\n                    b[l].renderGrid(), r && (b[l].createMask(), b[l].renderBreaksBackground());\n            if (c && 0 < c.length)\n                for (l = 0; l < c.length; l++)\n                    c[l].renderGrid(), r && (c[l].createMask(), c[l].renderBreaksBackground());\n            if (a && 0 < a.length)\n                for (l = 0; l < a.length; l++)\n                    a[l].renderAxisLine();\n            if (d && 0 < d.length)\n                for (l = 0; l < d.length; l++)\n                    d[l].renderAxisLine();\n            if (b && 0 < b.length)\n                for (l = 0; l < b.length; l++)\n                    b[l].renderAxisLine();\n            if (c && 0 < c.length)\n                for (l = 0; l < c.length; l++)\n                    c[l].renderAxisLine();\n            if (a && 0 < a.length)\n                for (l = 0; l < a.length; l++)\n                    a[l].renderStripLinesOfThicknessType(\"pixel\");\n            if (d && 0 < d.length)\n                for (l = 0; l < d.length; l++)\n                    d[l].renderStripLinesOfThicknessType(\"pixel\");\n            if (b && 0 < b.length)\n                for (l = 0; l < b.length; l++)\n                    b[l].renderStripLinesOfThicknessType(\"pixel\");\n            if (c && 0 < c.length)\n                for (l = 0; l < c.length; l++)\n                    c[l].renderStripLinesOfThicknessType(\"pixel\");\n        };\n        z.prototype.calculateStripLinesThicknessInValues = function () {\n            for (var a = 0; a < this.stripLines.length; a++)\n                if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {\n                    var d = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue), b = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue), d = this.getApparentDifference(d, b);\n                    this.stripLines[a].value = this.logarithmic ? this.stripLines[a].value * Math.sqrt(Math.log(this.stripLines[a].endValue / this.stripLines[a].startValue) / Math.log(d)) : this.stripLines[a].value + (Math.abs(this.stripLines[a].endValue - this.stripLines[a].startValue) - d) / 2;\n                    this.stripLines[a].thickness = d;\n                    this.stripLines[a]._thicknessType = \"value\";\n                }\n        };\n        z.prototype.calculateBreaksSizeInValues = function () {\n            for (var a = \"left\" ===\n                this._position || \"right\" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, d = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), c = this.scaleBreaks && !u(this.scaleBreaks.options.spacing), e, g = 0; g < d.length; g++)\n                e = c || !u(d[g].options.spacing), d[g].spacing =\n                    I(d[g].spacing, a, 8, e ? 0.1 * a : 8, e ? 0 : 3) << 0, d[g].size = 0 > d[g].spacing ? 0 : Math.abs(d[g].spacing / b), this.logarithmic && (d[g].size = Math.pow(this.logarithmBase, d[g].size));\n        };\n        z.prototype.calculateBreaksInPixels = function () {\n            if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {\n                var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\n                a.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);\n                for (var d = 0; d < a.length && !(a[d].startValue > this.conversionParameters.maximum); d++)\n                    a[d].endValue <\n                        this.conversionParameters.minimum || (u(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = d), a[d].startValue >= this.conversionParameters.minimum && (a[d].startPixel = this.convertValueToPixel(a[d].startValue), this.scaleBreaks.lastBreakIndex = d), a[d].endValue <= this.conversionParameters.maximum && (a[d].endPixel = this.convertValueToPixel(a[d].endValue)));\n            }\n        };\n        z.prototype.renderLabelsTicksAndTitle = function () {\n            var a = this, d = !1, b = 0, c = 0, e = 1, g = 0;\n            0 !== this.labelAngle && 360 !== this.labelAngle && (e = 1.2);\n            if (\"undefined\" ===\n                typeof this.options.interval) {\n                if (\"bottom\" === this._position || \"top\" === this._position)\n                    if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {\n                        for (var b = [], e = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, k, l = this.viewportMaximum, h = this.lineCoordinates.width / Math.log(this.range), m = this._labels.length - 1; 0 <= m; m--) {\n                            q = this._labels[m];\n                            if (q.position < this.viewportMinimum)\n                                break;\n                            q.position > this.viewportMaximum || !(m === this._labels.length - 1 || k < Math.log(l / q.position) * h / e) || (b.push(q), l = q.position, k =\n                                q.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));\n                        }\n                        this._labels = b;\n                    }\n                    else {\n                        for (m = 0; m < this._labels.length; m++)\n                            q = this._labels[m], q.position < this.viewportMinimum || (k = q.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += k);\n                        b > this.lineCoordinates.width * e && this.labelAutoFit && (d = !0);\n                    }\n                if (\"left\" === this._position || \"right\" === this._position)\n                    if (this.logarithmic &&\n                        !this.equidistantInterval && this.labelAutoFit) {\n                        for (var b = [], p, l = this.viewportMaximum, h = this.lineCoordinates.height / Math.log(this.range), m = this._labels.length - 1; 0 <= m; m--) {\n                            q = this._labels[m];\n                            if (q.position < this.viewportMinimum)\n                                break;\n                            q.position > this.viewportMaximum || !(m === this._labels.length - 1 || p < Math.log(l / q.position) * h) || (b.push(q), l = q.position, p = q.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));\n                        }\n                        this._labels = b;\n                    }\n                    else {\n                        for (m =\n                            0; m < this._labels.length; m++)\n                            q = this._labels[m], q.position < this.viewportMinimum || (p = q.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += p);\n                        c > this.lineCoordinates.height * e && this.labelAutoFit && (d = !0);\n                    }\n            }\n            this.logarithmic && (!this.equidistantInterval && this.labelAutoFit) && this._labels.sort(function (a, b) { return a.position - b.position; });\n            var m = 0, q, n;\n            if (\"bottom\" === this._position) {\n                for (m = 0; m < this._labels.length; m++)\n                    q = this._labels[m],\n                        q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(q.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y + this.tickLength << 0), this.ctx.stroke()), 0 === q.textBlock.angle ? (n.x -= q.textBlock.width / 2, n.y = \"inside\" === this.labelPlacement ?\n                            n.y - (this.tickLength + q.textBlock.fontSize / 2) : n.y + this.tickLength + q.textBlock.fontSize / 2) : (n.x = \"inside\" === this.labelPlacement ? 0 > this.labelAngle ? n.x : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x - (0 > this.labelAngle ? q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = \"inside\" === this.labelPlacement ? 0 > this.labelAngle ? n.y - this.tickLength - 5 : n.y - this.tickLength - Math.abs(q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : n.y + this.tickLength + Math.abs(0 > this.labelAngle ? q.textBlock.width *\n                            Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), q.textBlock.x = n.x, q.textBlock.y = n.y);\n                \"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n                    for (m = 0; m < a._labels.length; m++)\n                        if (q = a._labels[m], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(q.position), a.tickThickness)) {\n                            a.ctx.lineWidth = a.tickThickness;\n                            a.ctx.strokeStyle = a.tickColor;\n                            var b = 1 === a.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;\n                            a.ctx.save();\n                            a.ctx.beginPath();\n                            a.ctx.moveTo(b, n.y << 0);\n                            a.ctx.lineTo(b, n.y - a.tickLength << 0);\n                            a.ctx.stroke();\n                            a.ctx.restore();\n                        }\n                }, this);\n                this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n            }\n            else if (\"top\" === this._position) {\n                for (m = 0; m < this._labels.length; m++)\n                    q = this._labels[m],\n                        q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(q.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y - this.tickLength << 0), this.ctx.stroke()), 0 === q.textBlock.angle ? (n.x -= q.textBlock.width / 2, n.y = \"inside\" === this.labelPlacement ?\n                            n.y + this.labelFontSize / 2 + this.tickLength + 5 : n.y - (this.tickLength + q.textBlock.height - q.textBlock.fontSize / 2)) : (n.x = \"inside\" === this.labelPlacement ? 0 < this.labelAngle ? n.x : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x + (q.textBlock.height - this.tickLength - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = \"inside\" === this.labelPlacement ? 0 < this.labelAngle ? n.y + this.tickLength + 5 : n.y - q.textBlock.width * Math.sin(Math.PI /\n                            180 * this.labelAngle) + this.tickLength + 5 : n.y - (this.tickLength + ((q.textBlock.height - q.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), q.textBlock.x = n.x, q.textBlock.y = n.y);\n                \"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n                    for (m = 0; m < a._labels.length; m++)\n                        if (q = a._labels[m], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) &&\n                            (n = a.getPixelCoordinatesOnAxis(q.position), a.tickThickness)) {\n                            a.ctx.lineWidth = a.tickThickness;\n                            a.ctx.strokeStyle = a.tickColor;\n                            var b = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;\n                            a.ctx.save();\n                            a.ctx.beginPath();\n                            a.ctx.moveTo(b, n.y << 0);\n                            a.ctx.lineTo(b, n.y + a.tickLength << 0);\n                            a.ctx.stroke();\n                            a.ctx.restore();\n                        }\n                }, this);\n                this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth =\n                    this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n            }\n            else if (\"left\" === this._position) {\n                for (m = 0; m < this._labels.length; m++)\n                    q = this._labels[m], q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(q.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x <<\n                        0, c), this.ctx.lineTo(n.x - this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ? (q.textBlock.y = n.y, q.textBlock.x = \"inside\" === this.labelPlacement ? n.x + this.tickLength + 5 : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (q.textBlock.y = \"inside\" === this.labelPlacement ? n.y : n.y - q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), q.textBlock.x = \"inside\" === this.labelPlacement ? n.x + this.tickLength + 5 : 0 < this.labelAngle ? n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) -\n                        this.tickLength - 5 : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (q.textBlock.height - q.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength));\n                \"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n                    for (m = 0; m < a._labels.length; m++)\n                        if (q = a._labels[m], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(q.position), a.tickThickness)) {\n                            a.ctx.lineWidth = a.tickThickness;\n                            a.ctx.strokeStyle = a.tickColor;\n                            var b = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0;\n                            a.ctx.save();\n                            a.ctx.beginPath();\n                            a.ctx.moveTo(n.x << 0, b);\n                            a.ctx.lineTo(n.x + a.tickLength << 0, b);\n                            a.ctx.stroke();\n                            a.ctx.restore();\n                        }\n                }, this);\n                this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n            }\n            else if (\"right\" ===\n                this._position) {\n                for (m = 0; m < this._labels.length; m++)\n                    q = this._labels[m], q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(q.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x + this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ?\n                        (q.textBlock.y = n.y, q.textBlock.x = \"inside\" === this.labelPlacement ? n.x - q.textBlock.width - this.tickLength - 5 : n.x + this.tickLength + 5) : (q.textBlock.y = \"inside\" === this.labelPlacement ? n.y - q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? n.y : n.y - (q.textBlock.height - q.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), q.textBlock.x = \"inside\" === this.labelPlacement ? n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : 0 < this.labelAngle ? n.x + (q.textBlock.height -\n                        q.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : n.x + this.tickLength + 5));\n                \"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n                    for (m = 0; m < a._labels.length; m++)\n                        if (q = a._labels[m], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(q.position), a.tickThickness)) {\n                            a.ctx.lineWidth = a.tickThickness;\n                            a.ctx.strokeStyle = a.tickColor;\n                            var b = 1 === a.ctx.lineWidth % 2 ? (n.y <<\n                                0) + 0.5 : n.y << 0;\n                            a.ctx.save();\n                            a.ctx.beginPath();\n                            a.ctx.moveTo(n.x << 0, b);\n                            a.ctx.lineTo(n.x - a.tickLength << 0, b);\n                            a.ctx.stroke();\n                            a.ctx.restore();\n                        }\n                }, this);\n                this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\n            }\n            g = 0;\n            if (\"inside\" === this.labelPlacement)\n                this.chart.addEventListener(\"dataAnimationIterationEnd\", function () { for (m = 0; m < a._labels.length; m++)\n                    q = a._labels[m], q.position < a.viewportMinimum || (q.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) || (a.ctx.save(), a.ctx.beginPath(), q.textBlock.render(!0), a.ctx.restore()); }, this);\n            else\n                for (m = 0; m < this._labels.length; m++)\n                    q = this._labels[m], q.position < this.viewportMinimum || (q.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || q.textBlock.render(!0);\n        };\n        z.prototype.renderInterlacedColors = function () {\n            var a = this.chart.plotArea.ctx, d, b, c = this.chart.plotArea, e = 0;\n            d = !0;\n            if ((\"bottom\" === this._position || \"top\" === this._position) && this.interlacedColor)\n                for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)\n                    d ? (d = this.getPixelCoordinatesOnAxis(this._labels[e].position), b = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(Math.min(b.x, d.x), c.y1, Math.abs(b.x - d.x), Math.abs(c.y1 - c.y2)), d = !1) : d = !0;\n            else if ((\"left\" === this._position || \"right\" === this._position) && this.interlacedColor)\n                for (a.fillStyle =\n                    this.interlacedColor, e = 0; e < this._labels.length; e++)\n                    d ? (b = this.getPixelCoordinatesOnAxis(this._labels[e].position), d = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(c.x1, Math.min(b.y, d.y), Math.abs(c.x1 - c.x2), Math.abs(d.y - b.y)), d = !1) : d = !0;\n            a.beginPath();\n        };\n        z.prototype.renderStripLinesOfThicknessType = function (a) {\n            if (this.stripLines && 0 < this.stripLines.length && a) {\n                for (var d = this, b, c = 0, e = 0, g = !1, k = !1, l = [], h = [], k = !1, c = 0; c < this.stripLines.length; c++) {\n                    var m = this.stripLines[c];\n                    m._thicknessType === a && (\"pixel\" === a && (m.value < this.viewportMinimum || m.value > this.viewportMaximum || u(m.value) || isNaN(this.range)) || l.push(m));\n                }\n                for (c = 0; c < this._stripLineLabels.length; c++)\n                    if (m = this.stripLines[c], b = this._stripLineLabels[c], !(b.position < this.viewportMinimum || b.position > this.viewportMaximum || isNaN(this.range))) {\n                        a = this.getPixelCoordinatesOnAxis(b.position);\n                        if (\"outside\" === b.stripLine.labelPlacement)\n                            if (m && (this.ctx.strokeStyle =\n                                m.color, \"pixel\" === m._thicknessType && (this.ctx.lineWidth = m.thickness)), \"bottom\" === this._position) {\n                                var p = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0;\n                                this.ctx.beginPath();\n                                this.ctx.moveTo(p, a.y << 0);\n                                this.ctx.lineTo(p, a.y + this.tickLength << 0);\n                                this.ctx.stroke();\n                                0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y += this.tickLength + b.textBlock.fontSize / 2) : (a.x -= 0 > this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a.y += this.tickLength + Math.abs(0 > this.labelAngle ? b.textBlock.width * Math.sin(Math.PI /\n                                    180 * this.labelAngle) - 5 : 5));\n                            }\n                            else\n                                \"top\" === this._position ? (p = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, this.ctx.beginPath(), this.ctx.moveTo(p, a.y << 0), this.ctx.lineTo(p, a.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y -= this.tickLength + b.textBlock.height) : (a.x += (b.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a.y -= this.tickLength + (b.textBlock.height *\n                                    Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : \"left\" === this._position ? (p = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, p), this.ctx.lineTo(a.x - this.tickLength << 0, p), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a.y -= b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x - b.textBlock.width *\n                                    Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : \"right\" === this._position && (p = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, p), this.ctx.lineTo(a.x + this.tickLength << 0, p), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x + this.tickLength + 5 : (a.y = 0 > this.labelAngle ? a.y : a.y - (b.textBlock.height - b.textBlock.fontSize /\n                                    2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a.x + this.tickLength + 5));\n                        else\n                            b.textBlock.angle = -90, \"bottom\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? u(m.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize /\n                                2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, u(m.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y1 + b.textBlock.width + 3 : \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - b.textBlock.width - 3 : \"center\" ===\n                                b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : \"top\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? u(m.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, u(m.startValue) ? a.x +=\n                                b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + b.textBlock.width + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y2 -\n                                b.textBlock.width - 3) : \"left\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - b.textBlock.height > this.chart.plotArea.y1 ? u(m.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : u(m.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize /\n                                2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3, a.x = \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x2 - b.textBlock.width - 3) : \"right\" === this._position && (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - +b.textBlock.height > this.chart.plotArea.y1 ?\n                                u(m.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 - 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : u(m.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3, a.x = \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.x2 - b.textBlock.width - 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x1 +\n                                3);\n                        b.textBlock.x = a.x;\n                        b.textBlock.y = a.y;\n                        h.push(b);\n                    }\n                if (!k) {\n                    k = !1;\n                    this.ctx.save();\n                    this.ctx.beginPath();\n                    this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\n                    this.ctx.clip();\n                    for (c = 0; c < l.length; c++)\n                        m = l[c], m.showOnTop ? g || (g = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\n                            this.ctx.save();\n                            this.ctx.beginPath();\n                            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\n                            this.ctx.clip();\n                            for (e = 0; e < l.length; e++)\n                                m = l[e], m.showOnTop && m.render();\n                            this.ctx.restore();\n                        }, m)) : m.render();\n                    for (c = 0; c < h.length; c++)\n                        b = h[c], b.stripLine.showOnTop ? k || (k = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () { for (e = 0; e < h.length; e++)\n                            b = h[e], \"inside\" === b.stripLine.labelPlacement && b.stripLine.showOnTop && (d.ctx.save(), d.ctx.beginPath(), d.ctx.rect(d.chart.plotArea.x1, d.chart.plotArea.y1, d.chart.plotArea.width, d.chart.plotArea.height), d.ctx.clip(), b.textBlock.render(!0), d.ctx.restore()); }, b.textBlock)) :\n                            \"inside\" === b.stripLine.labelPlacement && b.textBlock.render(!0);\n                    this.ctx.restore();\n                    k = !0;\n                }\n                if (k)\n                    for (k = !1, c = 0; c < h.length; c++)\n                        b = h[c], b.stripLine.showOnTop ? k || (k = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () { for (e = 0; e < h.length; e++)\n                            b = h[e], \"outside\" === b.stripLine.labelPlacement && b.stripLine.showOnTop && b.textBlock.render(!0); }, b.textBlock)) : \"outside\" === b.stripLine.labelPlacement && b.textBlock.render(!0);\n            }\n        };\n        z.prototype.renderBreaksBackground = function () {\n            this.chart._breaksCanvas && (this.scaleBreaks &&\n                0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas) && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore());\n        };\n        z.prototype.createMask = function () {\n            if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {\n                var a = this.scaleBreaks._appliedBreaks;\n                r ? (this.maskCanvas = ta(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext(\"2d\")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);\n                this.maskCtx.save();\n                this.maskCtx.beginPath();\n                this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\n                this.maskCtx.clip();\n                for (var d = 0; d < a.length; d++)\n                    a[d].endValue < this.viewportMinimum || (a[d].startValue > this.viewportMaximum ||\n                        isNaN(this.range)) || a[d].render(this.maskCtx);\n                this.maskCtx.restore();\n            }\n        };\n        z.prototype.renderCrosshair = function (a, d) { this.crosshair.render(a, d); };\n        z.prototype.renderGrid = function () {\n            if (this.gridThickness && 0 < this.gridThickness) {\n                var a = this.chart.ctx;\n                a.save();\n                var d, b = this.chart.plotArea;\n                a.lineWidth = this.gridThickness;\n                a.strokeStyle = this.gridColor;\n                a.setLineDash && a.setLineDash(R(this.gridDashType, this.gridThickness));\n                if (\"bottom\" === this._position || \"top\" === this._position)\n                    for (c = 0; c < this._labels.length; c++)\n                        this._labels[c].position <\n                            this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(), d = this.getPixelCoordinatesOnAxis(this._labels[c].position), d = 1 === a.lineWidth % 2 ? (d.x << 0) + 0.5 : d.x << 0, a.moveTo(d, b.y1 << 0), a.lineTo(d, b.y2 << 0), a.stroke());\n                else if (\"left\" === this._position || \"right\" === this._position)\n                    for (var c = 0; c < this._labels.length; c++)\n                        this._labels[c].position < this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(),\n                            d = this.getPixelCoordinatesOnAxis(this._labels[c].position), d = 1 === a.lineWidth % 2 ? (d.y << 0) + 0.5 : d.y << 0, a.moveTo(b.x1 << 0, d), a.lineTo(b.x2 << 0, d), a.stroke());\n                a.restore();\n            }\n        };\n        z.prototype.renderAxisLine = function () {\n            var a = this.chart.ctx, d = r ? this.chart._preRenderCtx : a, b = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)), c = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)), e, g;\n            d.save();\n            if (\"bottom\" === this._position || \"top\" === this._position) {\n                if (this.lineThickness) {\n                    this.reversed ? (e = this.lineCoordinates.x2, g = this.lineCoordinates.x1) :\n                        (e = this.lineCoordinates.x1, g = this.lineCoordinates.x2);\n                    d.lineWidth = this.lineThickness;\n                    d.strokeStyle = this.lineColor ? this.lineColor : \"black\";\n                    d.setLineDash && d.setLineDash(R(this.lineDashType, this.lineThickness));\n                    var k = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;\n                    d.beginPath();\n                    if (this.scaleBreaks && !u(this.scaleBreaks.firstBreakIndex))\n                        if (u(this.scaleBreaks.lastBreakIndex))\n                            e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c;\n                        else\n                            for (var l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++)\n                                d.moveTo(e, k), d.lineTo(this.scaleBreaks._appliedBreaks[l].startPixel + b, k), e = this.scaleBreaks._appliedBreaks[l].endPixel + c;\n                    e && (d.moveTo(e, k), d.lineTo(g, k));\n                    d.stroke();\n                }\n            }\n            else if ((\"left\" === this._position || \"right\" === this._position) && this.lineThickness) {\n                this.reversed ? (e = this.lineCoordinates.y1, g = this.lineCoordinates.y2) : (e = this.lineCoordinates.y2, g = this.lineCoordinates.y1);\n                d.lineWidth = this.lineThickness;\n                d.strokeStyle = this.lineColor;\n                d.setLineDash && d.setLineDash(R(this.lineDashType, this.lineThickness));\n                k = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;\n                d.beginPath();\n                if (this.scaleBreaks && !u(this.scaleBreaks.firstBreakIndex))\n                    if (u(this.scaleBreaks.lastBreakIndex))\n                        e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;\n                    else\n                        for (l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++)\n                            d.moveTo(k, e), d.lineTo(k, this.scaleBreaks._appliedBreaks[l].startPixel + c),\n                                e = this.scaleBreaks._appliedBreaks[l].endPixel + b;\n                e && (d.moveTo(k, e), d.lineTo(k, g));\n                d.stroke();\n            }\n            r && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), d.clearRect(0, 0, this.chart.width, this.chart.height));\n            d.restore();\n        };\n        z.prototype.getPixelCoordinatesOnAxis = function (a) {\n            var d = {};\n            if (\"bottom\" === this._position || \"top\" === this._position)\n                d.x = this.convertValueToPixel(a),\n                    d.y = this.lineCoordinates.y1;\n            if (\"left\" === this._position || \"right\" === this._position)\n                d.y = this.convertValueToPixel(a), d.x = this.lineCoordinates.x2;\n            return d;\n        };\n        z.prototype.convertPixelToValue = function (a) {\n            if (\"undefined\" === typeof a)\n                return null;\n            var d = 0, b = 0, c, d = !0, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = \"number\" === typeof a ? a : \"left\" === this._position || \"right\" === this._position ? a.y : a.x;\n            if (this.logarithmic) {\n                a = c = Math.pow(this.logarithmBase, (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);\n                if (b <= this.conversionParameters.reference === (\"left\" === this._position || \"right\" === this._position) !== this.reversed)\n                    for (b = 0; b < e.length; b++) {\n                        if (!(e[b].endValue < this.conversionParameters.minimum))\n                            if (d)\n                                if (e[b].startValue < this.conversionParameters.minimum) {\n                                    if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)) < e[b].endValue) {\n                                        a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));\n                                        break;\n                                    }\n                                    else\n                                        a *= e[b].endValue / this.conversionParameters.minimum /\n                                            Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)), c /= Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue));\n                                    d = !1;\n                                }\n                                else if (c > e[b].startValue / this.conversionParameters.minimum) {\n                                    c /= e[b].startValue / this.conversionParameters.minimum;\n                                    if (c < e[b].size) {\n                                        a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;\n                                        break;\n                                    }\n                                    else\n                                        a *= e[b].endValue / e[b].startValue /\n                                            e[b].size;\n                                    c /= e[b].size;\n                                    d = !1;\n                                }\n                                else\n                                    break;\n                            else if (c > e[b].startValue / e[b - 1].endValue) {\n                                c /= e[b].startValue / e[b - 1].endValue;\n                                if (c < e[b].size) {\n                                    a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;\n                                    break;\n                                }\n                                else\n                                    a *= e[b].endValue / e[b].startValue / e[b].size;\n                                c /= e[b].size;\n                            }\n                            else\n                                break;\n                    }\n                else\n                    for (b = e.length - 1; 0 <= b; b--)\n                        if (!(e[b].startValue > this.conversionParameters.minimum))\n                            if (d)\n                                if (e[b].endValue > this.conversionParameters.minimum) {\n                                    if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue /\n                                        e[b].startValue, Math.log(c) / Math.log(e[b].size)) > e[b].startValue) {\n                                        a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));\n                                        break;\n                                    }\n                                    else\n                                        a *= e[b].startValue / this.conversionParameters.minimum * Math.pow(e[b].size, Math.log(e[b].startValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)) * c, c *= Math.pow(e[b].size, Math.log(this.conversionParameters.minimum / e[b].startValue) / Math.log(e[b].endValue / e[b].startValue));\n                                    d = !1;\n                                }\n                                else if (c < e[b].endValue / this.conversionParameters.minimum) {\n                                    c /=\n                                        e[b].endValue / this.conversionParameters.minimum;\n                                    if (c > 1 / e[b].size) {\n                                        a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;\n                                        break;\n                                    }\n                                    else\n                                        a /= e[b].endValue / e[b].startValue / e[b].size;\n                                    c *= e[b].size;\n                                    d = !1;\n                                }\n                                else\n                                    break;\n                            else if (c < e[b].endValue / e[b + 1].startValue) {\n                                c /= e[b].endValue / e[b + 1].startValue;\n                                if (c > 1 / e[b].size) {\n                                    a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;\n                                    break;\n                                }\n                                else\n                                    a /= e[b].endValue / e[b].startValue / e[b].size;\n                                c *= e[b].size;\n                            }\n                            else\n                                break;\n                d = a * this.viewportMinimum;\n            }\n            else {\n                a = c = (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;\n                if (b <= this.conversionParameters.reference === (\"left\" === this._position || \"right\" === this._position) !== this.reversed)\n                    for (b = 0; b < e.length; b++) {\n                        if (!(e[b].endValue < this.conversionParameters.minimum))\n                            if (d)\n                                if (e[b].startValue < this.conversionParameters.minimum) {\n                                    if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size < e[b].endValue) {\n                                        a = 0 >= e[b].size ? 0 : c * (e[b].endValue -\n                                            e[b].startValue) / e[b].size;\n                                        break;\n                                    }\n                                    else\n                                        a += e[b].endValue - this.conversionParameters.minimum - e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue), c -= e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue);\n                                    d = !1;\n                                }\n                                else if (c > e[b].startValue - this.conversionParameters.minimum) {\n                                    c -= e[b].startValue - this.conversionParameters.minimum;\n                                    if (c < e[b].size) {\n                                        a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;\n                                        break;\n                                    }\n                                    else\n                                        a += e[b].endValue -\n                                            e[b].startValue - e[b].size;\n                                    c -= e[b].size;\n                                    d = !1;\n                                }\n                                else\n                                    break;\n                            else if (c > e[b].startValue - e[b - 1].endValue) {\n                                c -= e[b].startValue - e[b - 1].endValue;\n                                if (c < e[b].size) {\n                                    a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;\n                                    break;\n                                }\n                                else\n                                    a += e[b].endValue - e[b].startValue - e[b].size;\n                                c -= e[b].size;\n                            }\n                            else\n                                break;\n                    }\n                else\n                    for (b = e.length - 1; 0 <= b; b--)\n                        if (!(e[b].startValue > this.conversionParameters.minimum))\n                            if (d)\n                                if (e[b].endValue > this.conversionParameters.minimum)\n                                    if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue -\n                                        e[b].startValue) / e[b].size > e[b].startValue) {\n                                        a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size;\n                                        break;\n                                    }\n                                    else\n                                        a += e[b].startValue - this.conversionParameters.minimum + e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), c += e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), d = !1;\n                                else if (c < e[b].endValue - this.conversionParameters.minimum) {\n                                    c -= e[b].endValue - this.conversionParameters.minimum;\n                                    if (c > -1 * e[b].size) {\n                                        a += (e[b].endValue -\n                                            e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;\n                                        break;\n                                    }\n                                    else\n                                        a -= e[b].endValue - e[b].startValue - e[b].size;\n                                    c += e[b].size;\n                                    d = !1;\n                                }\n                                else\n                                    break;\n                            else if (c < e[b].endValue - e[b + 1].startValue) {\n                                c -= e[b].endValue - e[b + 1].startValue;\n                                if (c > -1 * e[b].size) {\n                                    a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;\n                                    break;\n                                }\n                                else\n                                    a -= e[b].endValue - e[b].startValue - e[b].size;\n                                c += e[b].size;\n                            }\n                            else\n                                break;\n                d = this.conversionParameters.minimum + a;\n            }\n            return d;\n        };\n        z.prototype.convertValueToPixel = function (a) {\n            a = this.getApparentDifference(this.conversionParameters.minimum, a, a);\n            return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : \"axisX\" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5;\n        };\n        z.prototype.getApparentDifference = function (a, d, b, c) {\n            var e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\n            if (this.logarithmic) {\n                b = u(b) ? d / a : b;\n                for (var g = 0; g < e.length && !(d < e[g].startValue); g++)\n                    a > e[g].endValue || (a <= e[g].startValue && d >= e[g].endValue ? b = b / e[g].endValue * e[g].startValue * e[g].size : a >= e[g].startValue && d >= e[g].endValue ? b = b / e[g].endValue * a * Math.pow(e[g].size, Math.log(e[g].endValue / a) / Math.log(e[g].endValue / e[g].startValue)) : a <= e[g].startValue && d <= e[g].endValue ? b = b / d * e[g].startValue * Math.pow(e[g].size, Math.log(d / e[g].startValue) / Math.log(e[g].endValue /\n                        e[g].startValue)) : !c && (a > e[g].startValue && d < e[g].endValue) && (b = a * Math.pow(e[g].size, Math.log(d / a) / Math.log(e[g].endValue / e[g].startValue))));\n            }\n            else\n                for (b = u(b) ? Math.abs(d - a) : b, g = 0; g < e.length && !(d < e[g].startValue); g++)\n                    a > e[g].endValue || (a <= e[g].startValue && d >= e[g].endValue ? b = b - e[g].endValue + e[g].startValue + e[g].size : a > e[g].startValue && d >= e[g].endValue ? b = b - e[g].endValue + a + e[g].size * (e[g].endValue - a) / (e[g].endValue - e[g].startValue) : a <= e[g].startValue && d < e[g].endValue ? b = b - d + e[g].startValue + e[g].size * (d - e[g].startValue) /\n                        (e[g].endValue - e[g].startValue) : !c && (a > e[g].startValue && d < e[g].endValue) && (b = a + e[g].size * (d - a) / (e[g].endValue - e[g].startValue)));\n            return b;\n        };\n        z.prototype.setViewPortRange = function (a, d) { this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, d); this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, d); };\n        z.prototype.getXValueAt = function (a) {\n            if (!a)\n                return null;\n            var d = null;\n            \"left\" === this._position ? d = this.convertPixelToValue(a.y) : \"bottom\" === this._position && (d = this.convertPixelToValue(a.x));\n            return d;\n        };\n        z.prototype.calculateValueToPixelConversionParameters = function (a) {\n            a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\n            var d = { pixelPerUnit: null, minimum: null, reference: null }, b = this.lineCoordinates.width, c = this.lineCoordinates.height, b = \"bottom\" === this._position || \"top\" === this._position ? b : c, c = Math.abs(this.range);\n            if (this.logarithmic)\n                for (var e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)\n                    this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <=\n                        a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) :\n                        b - Math.min(a[e].spacing, 0.1 * b) * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c / this.viewportMaximum * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)));\n            else\n                for (e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)\n                    this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + this.viewportMinimum,\n                        b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c - this.viewportMaximum + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)) :\n                        b - Math.min(a[e].spacing, 0.1 * b) * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)));\n            d.minimum = this.viewportMinimum;\n            d.maximum = this.viewportMaximum;\n            d.range = c;\n            if (\"bottom\" === this._position || \"top\" === this._position)\n                this.logarithmic ? (d.lnLogarithmBase = Math.log(this.logarithmBase), d.pixelPerUnit = (this.reversed ? -1 : 1) * b * d.lnLogarithmBase / Math.log(Math.abs(c))) : d.pixelPerUnit = (this.reversed ? -1 : 1) * b / Math.abs(c), d.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;\n            if (\"left\" ===\n                this._position || \"right\" === this._position)\n                this.logarithmic ? (d.lnLogarithmBase = Math.log(this.logarithmBase), d.pixelPerUnit = (this.reversed ? 1 : -1) * b * d.lnLogarithmBase / Math.log(Math.abs(c))) : d.pixelPerUnit = (this.reversed ? 1 : -1) * b / Math.abs(c), d.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;\n            this.conversionParameters = d;\n        };\n        z.prototype.calculateAxisParameters = function () {\n            if (this.logarithmic)\n                this.calculateLogarithmicAxisParameters();\n            else {\n                var a = this.chart.layoutManager.getFreeSpace(), d = !1, b = !1;\n                \"bottom\" === this._position || \"top\" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);\n                var a = \"axisX\" === this.type ? \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 62 : 70 : \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 50 : 40, c = 4;\n                \"axisX\" === this.type && (c = 600 > this.maxWidth ? 8 : 6);\n                var a = Math.max(c, Math.floor(this.maxWidth / a)), e, g, k, c = 0;\n                !u(this.options.viewportMinimum) && (!u(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum) &&\n                    (this.viewportMinimum = this.viewportMaximum = null);\n                if (u(this.options.viewportMinimum) && !u(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum))\n                    this.viewportMinimum = this.sessionVariables.newViewportMinimum;\n                else if (null === this.viewportMinimum || isNaN(this.viewportMinimum))\n                    this.viewportMinimum = this.minimum;\n                if (u(this.options.viewportMaximum) && !u(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum))\n                    this.viewportMaximum = this.sessionVariables.newViewportMaximum;\n                else if (null === this.viewportMaximum || isNaN(this.viewportMaximum))\n                    this.viewportMaximum = this.maximum;\n                if (this.scaleBreaks)\n                    for (c = 0; c < this.scaleBreaks._appliedBreaks.length; c++)\n                        if ((!u(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue || !u(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[c].startValue || !u(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue) &&\n                            (!u(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue || !u(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[c].endValue || !u(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue)) {\n                            this.scaleBreaks._appliedBreaks.splice(c, 1);\n                            break;\n                        }\n                if (\"axisX\" === this.type) {\n                    if (this.dataSeries && 0 < this.dataSeries.length)\n                        for (e = 0; e < this.dataSeries.length; e++)\n                            \"dateTime\" === this.dataSeries[e].xValueType &&\n                                (b = !0);\n                    e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;\n                    g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;\n                    0 === g - e && (c = \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c);\n                    Infinity !== this.dataInfo.minDiff ? k = this.dataInfo.minDiff : 1 < g - e ? k = 0.5 * Math.abs(g - e) : (k = 1, b && (d = !0));\n                }\n                else\n                    \"axisY\" === this.type && (e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, g = null !== this.viewportMaximum ? this.viewportMaximum :\n                        this.dataInfo.viewPortMax, isFinite(e) || isFinite(g) ? isFinite(e) ? isFinite(g) || (g = e) : e = g : (g = \"undefined\" === typeof this.options.interval ? -Infinity : this.options.interval, e = \"undefined\" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)), k = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < e && (e = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > g && (g = 0));\n                c = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? e : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? g : this.viewportMaximum, null, !0);\n                if (\"axisX\" === this.type && b) {\n                    this.intervalType || (c / 1 <= a ? (this.interval = 1, this.intervalType = \"millisecond\") : c / 2 <= a ? (this.interval = 2, this.intervalType = \"millisecond\") : c / 5 <= a ? (this.interval = 5, this.intervalType = \"millisecond\") : c / 10 <= a ? (this.interval = 10, this.intervalType = \"millisecond\") : c / 20 <= a ? (this.interval = 20, this.intervalType = \"millisecond\") : c / 50 <= a ? (this.interval = 50, this.intervalType = \"millisecond\") : c / 100 <= a ? (this.interval = 100, this.intervalType = \"millisecond\") : c / 200 <= a ? (this.interval = 200, this.intervalType =\n                        \"millisecond\") : c / 250 <= a ? (this.interval = 250, this.intervalType = \"millisecond\") : c / 300 <= a ? (this.interval = 300, this.intervalType = \"millisecond\") : c / 400 <= a ? (this.interval = 400, this.intervalType = \"millisecond\") : c / 500 <= a ? (this.interval = 500, this.intervalType = \"millisecond\") : c / (1 * S.secondDuration) <= a ? (this.interval = 1, this.intervalType = \"second\") : c / (2 * S.secondDuration) <= a ? (this.interval = 2, this.intervalType = \"second\") : c / (5 * S.secondDuration) <= a ? (this.interval = 5, this.intervalType = \"second\") : c / (10 * S.secondDuration) <= a ? (this.interval =\n                        10, this.intervalType = \"second\") : c / (15 * S.secondDuration) <= a ? (this.interval = 15, this.intervalType = \"second\") : c / (20 * S.secondDuration) <= a ? (this.interval = 20, this.intervalType = \"second\") : c / (30 * S.secondDuration) <= a ? (this.interval = 30, this.intervalType = \"second\") : c / (1 * S.minuteDuration) <= a ? (this.interval = 1, this.intervalType = \"minute\") : c / (2 * S.minuteDuration) <= a ? (this.interval = 2, this.intervalType = \"minute\") : c / (5 * S.minuteDuration) <= a ? (this.interval = 5, this.intervalType = \"minute\") : c / (10 * S.minuteDuration) <= a ? (this.interval =\n                        10, this.intervalType = \"minute\") : c / (15 * S.minuteDuration) <= a ? (this.interval = 15, this.intervalType = \"minute\") : c / (20 * S.minuteDuration) <= a ? (this.interval = 20, this.intervalType = \"minute\") : c / (30 * S.minuteDuration) <= a ? (this.interval = 30, this.intervalType = \"minute\") : c / (1 * S.hourDuration) <= a ? (this.interval = 1, this.intervalType = \"hour\") : c / (2 * S.hourDuration) <= a ? (this.interval = 2, this.intervalType = \"hour\") : c / (3 * S.hourDuration) <= a ? (this.interval = 3, this.intervalType = \"hour\") : c / (6 * S.hourDuration) <= a ? (this.interval = 6, this.intervalType =\n                        \"hour\") : c / (1 * S.dayDuration) <= a ? (this.interval = 1, this.intervalType = \"day\") : c / (2 * S.dayDuration) <= a ? (this.interval = 2, this.intervalType = \"day\") : c / (4 * S.dayDuration) <= a ? (this.interval = 4, this.intervalType = \"day\") : c / (1 * S.weekDuration) <= a ? (this.interval = 1, this.intervalType = \"week\") : c / (2 * S.weekDuration) <= a ? (this.interval = 2, this.intervalType = \"week\") : c / (3 * S.weekDuration) <= a ? (this.interval = 3, this.intervalType = \"week\") : c / (1 * S.monthDuration) <= a ? (this.interval = 1, this.intervalType = \"month\") : c / (2 * S.monthDuration) <= a ? (this.interval =\n                        2, this.intervalType = \"month\") : c / (3 * S.monthDuration) <= a ? (this.interval = 3, this.intervalType = \"month\") : c / (6 * S.monthDuration) <= a ? (this.interval = 6, this.intervalType = \"month\") : (this.interval = c / (1 * S.yearDuration) <= a ? 1 : c / (2 * S.yearDuration) <= a ? 2 : c / (4 * S.yearDuration) <= a ? 4 : Math.floor(z.getNiceNumber(c / (a - 1), !0) / S.yearDuration), this.intervalType = \"year\"));\n                    if (null === this.viewportMinimum || isNaN(this.viewportMinimum))\n                        this.viewportMinimum = e - k / 2;\n                    if (null === this.viewportMaximum || isNaN(this.viewportMaximum))\n                        this.viewportMaximum =\n                            g + k / 2;\n                    d ? this.autoValueFormatString = \"MMM DD YYYY HH:mm\" : \"year\" === this.intervalType ? this.autoValueFormatString = \"YYYY\" : \"month\" === this.intervalType ? this.autoValueFormatString = \"MMM YYYY\" : \"week\" === this.intervalType ? this.autoValueFormatString = \"MMM DD YYYY\" : \"day\" === this.intervalType ? this.autoValueFormatString = \"MMM DD YYYY\" : \"hour\" === this.intervalType ? this.autoValueFormatString = \"hh:mm TT\" : \"minute\" === this.intervalType ? this.autoValueFormatString = \"hh:mm TT\" : \"second\" === this.intervalType ? this.autoValueFormatString =\n                        \"hh:mm:ss TT\" : \"millisecond\" === this.intervalType && (this.autoValueFormatString = \"fff'ms'\");\n                    this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);\n                }\n                else {\n                    this.intervalType = \"number\";\n                    c = z.getNiceNumber(c, !1);\n                    this.interval = this.options && 0 < this.options.interval ? this.options.interval : z.getNiceNumber(c / (a - 1), !0);\n                    if (null === this.viewportMinimum || isNaN(this.viewportMinimum))\n                        this.viewportMinimum = \"axisX\" === this.type ? e - k / 2 : Math.floor(e / this.interval) * this.interval;\n                    if (null === this.viewportMaximum ||\n                        isNaN(this.viewportMaximum))\n                        this.viewportMaximum = \"axisX\" === this.type ? g + k / 2 : Math.ceil(g / this.interval) * this.interval;\n                    0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && \"undefined\" === typeof this.options.interval && (this.interval = z.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));\n                }\n                if (null === this.minimum || null === this.maximum)\n                    if (\"axisX\" === this.type ? (e =\n                        null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === g - e && (c = \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c), k = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1) : \"axisY\" === this.type && (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(e) || isFinite(g) ? 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)) : (g = \"undefined\" === typeof this.options.interval ? -Infinity : this.options.interval, e = \"undefined\" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), k = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.minimum ||\n                        isNaN(this.minimum)) && 0 < e && (e = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > g && (g = 0)), Math.abs(this.getApparentDifference(e, g, null, !0)), \"axisX\" === this.type && b) {\n                        this.valueType = \"dateTime\";\n                        if (null === this.minimum || isNaN(this.minimum))\n                            this.minimum = e - k / 2;\n                        if (null === this.maximum || isNaN(this.maximum))\n                            this.maximum = g + k / 2;\n                    }\n                    else\n                        this.intervalType = this.valueType = \"number\", null === this.minimum && (this.minimum = \"axisX\" === this.type ? e - k / 2 : Math.floor(e / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = \"axisX\" === this.type ? g + k / 2 : Math.ceil(g / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 ===\n                            this.options.maximum && (this.minimum -= 10));\n                u(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));\n                u(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));\n                this.range = this.viewportMaximum - this.viewportMinimum;\n                this.intervalStartPosition = \"axisX\" === this.type && b ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) /\n                    this.interval) * this.interval;\n                this.valueFormatString || (this.valueFormatString = z.generateValueFormatString(this.range, 2));\n            }\n        };\n        z.prototype.calculateLogarithmicAxisParameters = function () {\n            var a = this.chart.layoutManager.getFreeSpace(), d = Math.log(this.logarithmBase), b;\n            \"bottom\" === this._position || \"top\" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);\n            var a = \"axisX\" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth /\n                50), 3), c, e, g, k;\n            k = 1;\n            if (null === this.viewportMinimum || isNaN(this.viewportMinimum))\n                this.viewportMinimum = this.minimum;\n            if (null === this.viewportMaximum || isNaN(this.viewportMaximum))\n                this.viewportMaximum = this.maximum;\n            if (this.scaleBreaks)\n                for (k = 0; k < this.scaleBreaks._appliedBreaks.length; k++)\n                    if ((!u(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[k].startValue || !u(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[k].startValue ||\n                        !u(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[k].startValue) && (!u(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[k].endValue || !u(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[k].endValue || !u(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[k].endValue)) {\n                        this.scaleBreaks._appliedBreaks.splice(k, 1);\n                        break;\n                    }\n            \"axisX\" === this.type ?\n                (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === e / c && (k = Math.pow(this.logarithmBase, \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval), e *= k, c /= k), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : \"axisY\" === this.type && (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin,\n                e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= c && !isFinite(e) ? (e = \"undefined\" === typeof this.options.interval ? 0 : this.options.interval, c = 1) : 0 >= c ? c = e : isFinite(e) || (e = c), 1 === c && 1 === e ? (e *= this.logarithmBase - 1 / this.logarithmBase, c = 1) : 1 === e / c ? (k = Math.min(e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), e *= k, c /= k) : c > e ? (k = Math.min(c / e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= e ? c = e / k : e = c * k) : (k = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= k), 1 !== c && (c /= k)), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < c && (c = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > e && (e = 1));\n            k = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null ===\n                this.viewportMinimum ? c : this.viewportMinimum);\n            var l = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum);\n            this.intervalType = \"number\";\n            k = Math.pow(this.logarithmBase, z.getNiceNumber(Math.abs(Math.log(k) / d), !1));\n            this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = z.getNiceExponent(Math.log(k) / d / (a - 1), !0), b = z.getNiceNumber(l / (a - 1), !0));\n            if (null === this.viewportMinimum ||\n                isNaN(this.viewportMinimum))\n                this.viewportMinimum = \"axisX\" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / d / this.interval));\n            if (null === this.viewportMaximum || isNaN(this.viewportMaximum))\n                this.viewportMaximum = \"axisX\" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / d / this.interval));\n            1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase :\n                1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && \"undefined\" === typeof this.options.interval && (this.interval = z.getNiceExponent(Math.ceil(Math.log(k) / d) / (a - 1)), b = z.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));\n            if (null === this.minimum || null === this.maximum)\n                \"axisX\" === this.type ? (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === e / c && (k = Math.pow(this.logarithmBase, \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval), e *= k, c /= k), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : \"axisY\" === this.type && (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(c) || isFinite(e) ? 1 === c && 1 === e ? (e *= this.logarithmBase, c /= this.logarithmBase) : 1 === e / c ? (k = Math.pow(this.logarithmBase, this.interval), e *= k, c /= k) : c > e ? (k =\n                    Math.min(0.01 * (c / e), 5), 1 <= e ? c = e / k : e = c * k) : (k = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= k), 1 !== c && (c /= k)) : (e = \"undefined\" === typeof this.options.interval ? 0 : this.options.interval, c = 1), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < c && (c = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) &&\n                    1 > e && (e = 1)), this.intervalType = \"number\", null === this.minimum && (this.minimum = \"axisX\" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / d / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? \"undefined\" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum =\n                    \"axisX\" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / d / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? \"undefined\" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase :\n                    1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));\n            this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);\n            this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);\n            this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum =\n                (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);\n            c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (d * this.interval) + 0.2) * this.interval);\n            this.range = this.viewportMaximum / this.viewportMinimum;\n            this.noTicks = a;\n            if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {\n                for (d = Math.floor(this.viewportMinimum /\n                    b + 0.5) * b; d < this.viewportMinimum;)\n                    d += b;\n                this.equidistantInterval = !1;\n                this.intervalStartPosition = d;\n                this.interval = b;\n            }\n            else\n                this.options.interval || (b = Math.ceil(this.interval), this.range > this.interval && (this.interval = b, c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (d * this.interval) + 0.2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = c;\n            if (!this.valueFormatString && (this.valueFormatString = \"#,##0.##\", 1 > this.viewportMinimum)) {\n                d = Math.floor(Math.abs(Math.log(this.viewportMinimum) /\n                    Math.LN10)) + 2;\n                if (isNaN(d) || !isFinite(d))\n                    d = 2;\n                if (2 < d)\n                    for (k = 0; k < d - 2; k++)\n                        this.valueFormatString += \"#\";\n            }\n        };\n        z.generateValueFormatString = function (a, d) { var b = \"#,##0.\", c = d; 1 > a && (c += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(c) || !isFinite(c)) && (c = d); for (var e = 0; e < c; e++)\n            b += \"#\"; return b; };\n        z.getNiceExponent = function (a, d) { var b = Math.floor(Math.log(a) / Math.LN10), c = a / Math.pow(10, b), c = 0 > b ? 1 >= c ? 1 : 5 >= c ? 5 : 10 : Math.max(Math.floor(c), 1); return -20 > b ? Number(c * Math.pow(10, b)) : Number((c * Math.pow(10, b)).toFixed(20)); };\n        z.getNiceNumber =\n            function (a, d) { var b = Math.floor(Math.log(a) / Math.LN10), c = a / Math.pow(10, b), c = d ? 1.5 > c ? 1 : 3 > c ? 2 : 7 > c ? 5 : 10 : 1 >= c ? 1 : 2 >= c ? 2 : 5 >= c ? 5 : 10; return -20 > b ? Number(c * Math.pow(10, b)) : Number((c * Math.pow(10, b)).toFixed(20)); };\n        z.prototype.getLabelStartPoint = function () {\n            var a = S[this.intervalType + \"Duration\"] * this.interval, a = new Date(Math.floor(this.viewportMinimum / a) * a);\n            if (\"millisecond\" !== this.intervalType)\n                if (\"second\" === this.intervalType)\n                    0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0));\n                else if (\"minute\" ===\n                    this.intervalType) {\n                    if (0 < a.getSeconds() || 0 < a.getMilliseconds())\n                        a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0);\n                }\n                else if (\"hour\" === this.intervalType) {\n                    if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())\n                        a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n                }\n                else if (\"day\" === this.intervalType) {\n                    if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())\n                        a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n                }\n                else if (\"week\" ===\n                    this.intervalType) {\n                    if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())\n                        a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n                }\n                else if (\"month\" === this.intervalType) {\n                    if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())\n                        a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\n                }\n                else\n                    \"year\" === this.intervalType && (0 < a.getMonth() || 1 <\n                        a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));\n            return a;\n        };\n        qa(Q, V);\n        qa(L, V);\n        L.prototype.createUserOptions = function (a) {\n            if (\"undefined\" !== typeof a || this.options._isPlaceholder) {\n                var d = 0;\n                this.parent.options._isPlaceholder && this.parent.createUserOptions();\n                this.options._isPlaceholder || (Fa(this.parent[this.optionsName]), d = this.parent.options[this.optionsName].indexOf(this.options));\n                this.options = \"undefined\" === typeof a ? {} : a;\n                this.parent.options[this.optionsName][d] = this.options;\n            }\n        };\n        L.prototype.render = function (a) {\n            if (0 !== this.spacing || 0 !== this.options.lineThickness && (\"undefined\" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {\n                var d = this.ctx, b = this.ctx.globalAlpha;\n                this.ctx = a || this.ctx;\n                this.ctx.save();\n                this.ctx.beginPath();\n                this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\n                this.ctx.clip();\n                var c = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), e = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);\n                this.ctx.strokeStyle = this.lineColor;\n                this.ctx.fillStyle = this.color;\n                this.ctx.beginPath();\n                this.ctx.globalAlpha = 1;\n                N(this.id);\n                var g, k, l, h, m, p;\n                a = Math.max(this.spacing, 3);\n                var q = Math.max(0, this.lineThickness);\n                this.ctx.lineWidth = q;\n                this.ctx.setLineDash && this.ctx.setLineDash(R(this.lineDashType, q));\n                if (\"bottom\" === this.scaleBreaks.parent._position || \"top\" === this.scaleBreaks.parent._position)\n                    if (c = 1 === q % 2 ? (c.x << 0) + 0.5 : c.x << 0, k = 1 === q % 2 ? (e.x << 0) + 0.5 :\n                        e.x << 0, \"top\" === this.scaleBreaks.parent._position ? (e = this.chart.plotArea.y1, l = this.chart.plotArea.y2 + q / 2 + 0.5 << 0) : (e = this.chart.plotArea.y2, l = this.chart.plotArea.y1 - q / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c - q / 2, y1: e, x2: k + q / 2, y2: l }, this.ctx.moveTo(c, e), \"straight\" === this.type || \"top\" === this.scaleBreaks.parent._position && 0 >= a || \"bottom\" === this.scaleBreaks.parent._position && 0 <= a)\n                        this.ctx.lineTo(c, l), this.ctx.lineTo(k, l), this.ctx.lineTo(k, e);\n                    else if (\"wavy\" === this.type) {\n                        h = c;\n                        m = e;\n                        g = 0.5;\n                        p = (l - m) / a / 3;\n                        for (var n = 0; n < p; n++)\n                            this.ctx.bezierCurveTo(h +\n                                g * a, m + a, h + g * a, m + 2 * a, h, m + 3 * a), m += 3 * a, g *= -1;\n                        this.ctx.bezierCurveTo(h + g * a, m + a, h + g * a, m + 2 * a, h, m + 3 * a);\n                        h = k;\n                        g *= -1;\n                        this.ctx.lineTo(h, m);\n                        for (n = 0; n < p; n++)\n                            this.ctx.bezierCurveTo(h + g * a, m - a, h + g * a, m - 2 * a, h, m - 3 * a), m -= 3 * a, g *= -1;\n                    }\n                    else {\n                        if (\"zigzag\" === this.type) {\n                            g = -1;\n                            m = e + a;\n                            h = c + a;\n                            p = (l - m) / a / 2;\n                            for (n = 0; n < p; n++)\n                                this.ctx.lineTo(h, m), h += 2 * g * a, m += 2 * a, g *= -1;\n                            this.ctx.lineTo(h, m);\n                            h += k - c;\n                            for (n = 0; n < p + 1; n++)\n                                this.ctx.lineTo(h, m), h += 2 * g * a, m -= 2 * a, g *= -1;\n                            this.ctx.lineTo(h + g * a, m + a);\n                        }\n                    }\n                else if (\"left\" === this.scaleBreaks.parent._position || \"right\" ===\n                    this.scaleBreaks.parent._position)\n                    if (e = 1 === q % 2 ? (e.y << 0) + 0.5 : e.y << 0, l = 1 === q % 2 ? (c.y << 0) + 0.5 : c.y << 0, \"left\" === this.scaleBreaks.parent._position ? (c = this.chart.plotArea.x1, k = this.chart.plotArea.x2 + q / 2 + 0.5 << 0) : (c = this.chart.plotArea.x2, k = this.chart.plotArea.x1 - q / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c, y1: e - q / 2, x2: k, y2: l + q / 2 }, this.ctx.moveTo(c, e), \"straight\" === this.type || \"left\" === this.scaleBreaks.parent._position && 0 >= a || \"right\" === this.scaleBreaks.parent._position && 0 <= a)\n                        this.ctx.lineTo(k, e), this.ctx.lineTo(k, l),\n                            this.ctx.lineTo(c, l);\n                    else if (\"wavy\" === this.type) {\n                        h = c;\n                        m = e;\n                        g = 0.5;\n                        p = (k - h) / a / 3;\n                        for (n = 0; n < p; n++)\n                            this.ctx.bezierCurveTo(h + a, m + g * a, h + 2 * a, m + g * a, h + 3 * a, m), h += 3 * a, g *= -1;\n                        this.ctx.bezierCurveTo(h + a, m + g * a, h + 2 * a, m + g * a, h + 3 * a, m);\n                        m = l;\n                        g *= -1;\n                        this.ctx.lineTo(h, m);\n                        for (n = 0; n < p; n++)\n                            this.ctx.bezierCurveTo(h - a, m + g * a, h - 2 * a, m + g * a, h - 3 * a, m), h -= 3 * a, g *= -1;\n                    }\n                    else if (\"zigzag\" === this.type) {\n                        g = 1;\n                        m = e - a;\n                        h = c + a;\n                        p = (k - h) / a / 2;\n                        for (n = 0; n < p; n++)\n                            this.ctx.lineTo(h, m), m += 2 * g * a, h += 2 * a, g *= -1;\n                        this.ctx.lineTo(h, m);\n                        m += l - e;\n                        for (n = 0; n < p + 1; n++)\n                            this.ctx.lineTo(h, m), m += 2 * g * a, h -= 2 * a, g *= -1;\n                        this.ctx.lineTo(h + a, m + g * a);\n                    }\n                0 < q && this.ctx.stroke();\n                this.ctx.closePath();\n                this.ctx.globalAlpha = this.fillOpacity;\n                this.ctx.globalCompositeOperation = \"destination-over\";\n                this.ctx.fill();\n                this.ctx.restore();\n                this.ctx.globalAlpha = b;\n                this.ctx = d;\n            }\n        };\n        qa(X, V);\n        X.prototype.createUserOptions = function (a) {\n            if (\"undefined\" !== typeof a || this.options._isPlaceholder) {\n                var d = 0;\n                this.parent.options._isPlaceholder && this.parent.createUserOptions();\n                this.options._isPlaceholder || (Fa(this.parent.stripLines), d = this.parent.options.stripLines.indexOf(this.options));\n                this.options = \"undefined\" === typeof a ? {} : a;\n                this.parent.options.stripLines[d] = this.options;\n            }\n        };\n        X.prototype.render = function () {\n            this.ctx.save();\n            var a = this.parent.getPixelCoordinatesOnAxis(this.value), d = Math.abs(\"pixel\" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);\n            if (0 < d) {\n                var b = null === this.opacity ? 1 : this.opacity;\n                this.ctx.strokeStyle = this.color;\n                this.ctx.beginPath();\n                var c = this.ctx.globalAlpha;\n                this.ctx.globalAlpha = b;\n                N(this.id);\n                var e, g, k, l;\n                this.ctx.lineWidth =\n                    d;\n                this.ctx.setLineDash && this.ctx.setLineDash(R(this.lineDashType, d));\n                if (\"bottom\" === this.parent._position || \"top\" === this.parent._position)\n                    e = g = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, k = this.chart.plotArea.y1, l = this.chart.plotArea.y2, this.bounds = { x1: e - d / 2, y1: k, x2: g + d / 2, y2: l };\n                else if (\"left\" === this.parent._position || \"right\" === this.parent._position)\n                    k = l = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, e = this.chart.plotArea.x1, g = this.chart.plotArea.x2, this.bounds = { x1: e, y1: k - d / 2, x2: g, y2: l + d / 2 };\n                this.ctx.moveTo(e, k);\n                this.ctx.lineTo(g, l);\n                this.ctx.stroke();\n                this.ctx.globalAlpha = c;\n            }\n            this.ctx.restore();\n        };\n        qa(fa, V);\n        fa.prototype.render = function (a, d) {\n            var b, c, e, g, k = null, l = k = null, h = \"\";\n            if (!this.valueFormatString)\n                if (\"dateTime\" === this.parent.valueType)\n                    this.valueFormatString = this.parent.valueFormatString;\n                else {\n                    var m = 0, m = \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ?\n                        1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0);\n                    this.valueFormatString = z.generateValueFormatString(this.parent.range, m);\n                }\n            var l = null === this.opacity ? 1 : this.opacity, m = Math.abs(\"pixel\" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness), p = this.chart.overlaidCanvasCtx, q = p.globalAlpha;\n            p.globalAlpha = l;\n            p.beginPath();\n            p.strokeStyle = this.color;\n            p.lineWidth = m;\n            p.save();\n            this.labelFontSize =\n                u(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize;\n            if (\"left\" === this.parent._position || \"right\" === this.parent._position)\n                this.labelMaxWidth = u(this.options.labelMaxWidth) ? this.parent.bounds.x2 - this.parent.bounds.x1 : this.labelMaxWidth, this.labelMaxHeight = u(this.options.labelWrap) || this.labelWrap ? 3 * this.chart.height : 2 * this.labelFontSize;\n            else if (\"top\" === this.parent._position || \"bottom\" === this.parent._position)\n                this.labelMaxWidth = u(this.options.labelMaxWidth) ? 3 * this.chart.width : this.labelMaxWidth,\n                    this.labelMaxHeight = u(this.options.labelWrap) || this.labelWrap ? this.parent.bounds.height : 2 * this.labelFontSize;\n            0 < m && p.setLineDash && p.setLineDash(R(this.lineDashType, m));\n            l = new ka(p, { x: 0, y: 0, padding: { top: 2, right: 3, bottom: 2, left: 4 }, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxWidth: this.labelMaxWidth, maxHeight: this.labelMaxHeight, angle: this.labelAngle, text: h, horizontalAlign: \"left\", fontSize: this.labelFontSize,\n                fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" });\n            if (this.snapToDataPoint) {\n                var n = 0, k = [];\n                if (\"xySwapped\" === this.chart.plotInfo.axisPlacement) {\n                    var f = null;\n                    if (\"bottom\" === this.parent._position || \"top\" === this.parent._position)\n                        n = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: d });\n                    else if (\"left\" === this.parent._position || \"right\" === this.parent._position)\n                        n = this.parent.convertPixelToValue({ y: d });\n                    for (var r = 0; r <\n                        this.parent.dataSeries.length; r++)\n                        (f = this.parent.dataSeries[r].getDataPointAtX(n, !0)) && 0 <= f.index && (f.dataSeries = this.parent.dataSeries[r], null !== f.dataPoint.y && k.push(f));\n                    f = null;\n                    if (0 === k.length)\n                        return;\n                    k.sort(function (a, b) { return a.distance - b.distance; });\n                    f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y));\n                    r = 0;\n                    if (\"rangeBar\" === k[0].dataSeries.type || \"error\" === k[0].dataSeries.type)\n                        for (var f = Math.abs(a - this.parent.convertValueToPixel(k[r].dataPoint.y[0])), v = 0, n = 0; n < k.length; n++)\n                            if (k[n].dataPoint.y &&\n                                k[n].dataPoint.y.length)\n                                for (h = 0; h < k[n].dataPoint.y.length; h++)\n                                    v = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y[h])), v < f && (f = v, r = n);\n                            else\n                                v = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y)), v < f && (f = v, r = n);\n                    else if (\"stackedBar\" === k[0].dataSeries.type)\n                        for (var f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y)), D = v = 0, n = r = 0; n < k.length; n++)\n                            if (k[n].dataPoint.y && k[n].dataPoint.y.length)\n                                for (h = 0; h < k[n].dataPoint.y.length; h++)\n                                    v = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y[h])),\n                                        v < f && (f = v, r = n);\n                            else\n                                D += k[n].dataPoint.y, v = Math.abs(a - this.parent.convertValueToPixel(D)), v < f && (f = v, r = n);\n                    else if (\"stackedBar100\" === k[0].dataSeries.type)\n                        for (var f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y)), t = D = v = 0, n = 0; n < k.length; n++)\n                            if (k[n].dataPoint.y && k[n].dataPoint.y.length)\n                                for (h = 0; h < k[n].dataPoint.y.length; h++)\n                                    v = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y[h])), v < f && (f = v, r = n);\n                            else\n                                D += k[n].dataPoint.y, t = k[n].dataPoint.x.getTime ? k[n].dataPoint.x.getTime() : k[n].dataPoint.x,\n                                    t = 100 * (D / k[n].dataSeries.plotUnit.dataPointYSums[t]), v = Math.abs(a - this.parent.convertValueToPixel(t)), v < f && (f = v, r = n);\n                    else\n                        for (f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y)), n = r = v = 0; n < k.length; n++)\n                            if (k[n].dataPoint.y && k[n].dataPoint.y.length)\n                                for (h = 0; h < k[n].dataPoint.y.length; h++)\n                                    v = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y[h])), v < f && (f = v, r = n);\n                            else\n                                v = Math.abs(a - this.parent.convertValueToPixel(k[n].dataPoint.y)), v < f && (f = v, r = n);\n                    h = k[r];\n                    if (\"bottom\" === this.parent._position ||\n                        \"top\" === this.parent._position) {\n                        b = 0;\n                        if (\"rangeBar\" === this.parent.dataSeries[r].type || \"error\" === this.parent.dataSeries[r].type) {\n                            f = Math.abs(a - this.parent.convertValueToPixel(h.dataPoint.y[0]));\n                            for (n = v = 0; n < h.dataPoint.y.length; n++)\n                                v = Math.abs(a - this.parent.convertValueToPixel(h.dataPoint.y[n])), v < f && (f = v, b = n);\n                            k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(h.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(h.dataPoint.y[b]) << 0;\n                            l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart,\n                                axis: this.parent.options, crosshair: this.options, value: h.dataPoint.y[b] }) : u(this.options.label) ? ba(h.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label;\n                        }\n                        else if (\"stackedBar\" === this.parent.dataSeries[r].type) {\n                            f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y));\n                            D = v = 0;\n                            for (n = r; 0 <= n; n--)\n                                D += k[n].dataPoint.y, v = Math.abs(a - this.parent.convertValueToPixel(D)), v < f && (f = v, b = n);\n                            k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(D) << 0) + 0.5 : this.parent.convertValueToPixel(D) << 0;\n                            l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.y }) : u(this.options.label) ? ba(h.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;\n                        }\n                        else if (\"stackedBar100\" === this.parent.dataSeries[r].type) {\n                            f = Math.abs(a - this.parent.convertValueToPixel(k[0].dataPoint.y));\n                            t = D = v = 0;\n                            for (n = r; 0 <= n; n--)\n                                D += k[n].dataPoint.y, t = k[n].dataPoint.x.getTime ? k[n].dataPoint.x.getTime() : k[n].dataPoint.x, t = 100 * (D / k[n].dataSeries.plotUnit.dataPointYSums[t]),\n                                    v = Math.abs(a - this.parent.convertValueToPixel(t)), v < f && (f = v, b = n);\n                            k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(t) << 0) + 0.5 : this.parent.convertValueToPixel(t) << 0;\n                            l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: t }) : u(this.options.label) ? ba(t, this.valueFormatString, this.chart._cultureInfo) : this.label;\n                        }\n                        else\n                            k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(h.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(h.dataPoint.y) <<\n                                0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.y }) : u(this.options.label) ? ba(h.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;\n                        b = c = k;\n                        e = this.chart.plotArea.y1;\n                        g = this.chart.plotArea.y2;\n                        this.bounds = { x1: b - m / 2, y1: e, x2: c + m / 2, y2: g };\n                        l.x = b - l.measureText().width / 2;\n                        l.x + l.width > this.chart.bounds.x2 ? l.x = this.chart.bounds.x2 - l.width : l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);\n                        l.y = this.parent.lineCoordinates.y2 +\n                            l.fontSize / 2 + 2;\n                    }\n                    else if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n                        e = g = k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(h.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(h.dataPoint.x) << 0;\n                        b = this.chart.plotArea.x1;\n                        c = this.chart.plotArea.x2;\n                        this.bounds = { x1: b, y1: e - m / 2, x2: c, y2: g + m / 2 };\n                        t = !1;\n                        if (this.parent.labels)\n                            for (k = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += k)\n                                if (this.parent.labels[n])\n                                    t = !0;\n                                else {\n                                    t = !1;\n                                    break;\n                                }\n                        if (t) {\n                            if (\"axisX\" === this.parent.type)\n                                for (n =\n                                    this.parent.convertPixelToValue({ y: d }), f = null, r = 0; r < this.parent.dataSeries.length; r++)\n                                    (f = this.parent.dataSeries[r].getDataPointAtX(n, !0)) && 0 <= f.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.x }) : u(this.options.label) ? f.dataPoint.label : this.label);\n                        }\n                        else\n                            \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.x }) :\n                                u(this.options.label) ? Ca(h.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.x }) : u(this.options.label) ? ba(h.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);\n                        l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;\n                        l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height -\n                            l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\n                        \"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\n                    }\n                }\n                else if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\n                    n = this.parent.convertPixelToValue({ x: a });\n                    for (r = 0; r < this.parent.dataSeries.length; r++)\n                        (f = this.parent.dataSeries[r].getDataPointAtX(n, !0)) && 0 <= f.index && (f.dataSeries = this.parent.dataSeries[r],\n                            null !== f.dataPoint.y && k.push(f));\n                    if (0 === k.length)\n                        return;\n                    k.sort(function (a, b) { return a.distance - b.distance; });\n                    h = k[0];\n                    b = c = k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(h.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(h.dataPoint.x) << 0;\n                    e = this.chart.plotArea.y1;\n                    g = this.chart.plotArea.y2;\n                    this.bounds = { x1: b - m / 2, y1: e, x2: c + m / 2, y2: g };\n                    t = !1;\n                    if (this.parent.labels)\n                        for (k = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += k)\n                            if (this.parent.labels[n])\n                                t = !0;\n                            else {\n                                t = !1;\n                                break;\n                            }\n                    if (t) {\n                        if (\"axisX\" ===\n                            this.parent.type)\n                            for (n = this.parent.convertPixelToValue({ x: a }), f = null, r = 0; r < this.parent.dataSeries.length; r++)\n                                (f = this.parent.dataSeries[r].getDataPointAtX(n, !0)) && 0 <= f.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.x }) : u(this.options.label) ? f.dataPoint.label : this.label);\n                    }\n                    else\n                        \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options,\n                            value: h.dataPoint.x }) : u(this.options.label) ? Ca(h.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.x }) : u(this.options.label) ? ba(h.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);\n                    l.x = b - l.measureText().width / 2;\n                    l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);\n                    l.x < this.chart.bounds.x1 &&\n                        (l.x = this.chart.bounds.x1);\n                    \"bottom\" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);\n                }\n                else if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n                    !u(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (n = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: a }));\n                    for (r = 0; r < this.parent.dataSeries.length; r++)\n                        (f = this.parent.dataSeries[r].getDataPointAtX(n, !0)) && 0 <= f.index &&\n                            (f.dataSeries = this.parent.dataSeries[r], null !== f.dataPoint.y && k.push(f));\n                    if (0 === k.length)\n                        return;\n                    k.sort(function (a, b) { return a.distance - b.distance; });\n                    r = 0;\n                    if (\"rangeColumn\" === k[0].dataSeries.type || \"rangeArea\" === k[0].dataSeries.type || \"error\" === k[0].dataSeries.type || \"rangeSplineArea\" === k[0].dataSeries.type || \"candlestick\" === k[0].dataSeries.type || \"ohlc\" === k[0].dataSeries.type || \"boxAndWhisker\" === k[0].dataSeries.type)\n                        for (f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y[0])), n = v = 0; n < k.length; n++)\n                            if (k[n].dataPoint.y &&\n                                k[n].dataPoint.y.length)\n                                for (h = 0; h < k[n].dataPoint.y.length; h++)\n                                    v = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y[h])), v < f && (f = v, r = n);\n                            else\n                                v = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y)), v < f && (f = v, r = n);\n                    else if (\"stackedColumn\" === k[0].dataSeries.type || \"stackedArea\" === k[0].dataSeries.type)\n                        for (f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y)), n = D = v = 0; n < k.length; n++)\n                            if (k[n].dataPoint.y && k[n].dataPoint.y.length)\n                                for (h = 0; h < k[n].dataPoint.y.length; h++)\n                                    v = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y[h])),\n                                        v < f && (f = v, r = n);\n                            else\n                                D += k[n].dataPoint.y, v = Math.abs(d - this.parent.convertValueToPixel(D)), v < f && (f = v, r = n);\n                    else if (\"stackedColumn100\" === k[0].dataSeries.type || \"stackedArea100\" === k[0].dataSeries.type)\n                        for (f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y)), n = t = D = v = 0; n < k.length; n++)\n                            if (k[n].dataPoint.y && k[n].dataPoint.y.length)\n                                for (h = 0; h < k[n].dataPoint.y.length; h++)\n                                    v = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y[h])), v < f && (f = v, r = n);\n                            else\n                                D += k[n].dataPoint.y, t = k[n].dataPoint.x.getTime ?\n                                    k[n].dataPoint.x.getTime() : k[n].dataPoint.x, t = 100 * (D / k[n].dataSeries.plotUnit.dataPointYSums[t]), v = Math.abs(d - this.parent.convertValueToPixel(t)), v < f && (f = v, r = n);\n                    else\n                        for (f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y)), n = v = 0; n < k.length; n++)\n                            if (k[n].dataPoint.y && k[n].dataPoint.y.length)\n                                for (h = 0; h < k[n].dataPoint.y.length; h++)\n                                    v = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y[h])), v < f && (f = v, r = n);\n                            else\n                                v = Math.abs(d - this.parent.convertValueToPixel(k[n].dataPoint.y)), v < f && (f = v, r =\n                                    n);\n                    h = k[r];\n                    b = 0;\n                    if (\"rangeColumn\" === this.parent.dataSeries[r].type || \"rangeArea\" === this.parent.dataSeries[r].type || \"error\" === this.parent.dataSeries[r].type || \"rangeSplineArea\" === this.parent.dataSeries[r].type || \"candlestick\" === this.parent.dataSeries[r].type || \"ohlc\" === this.parent.dataSeries[r].type || \"boxAndWhisker\" === this.parent.dataSeries[r].type) {\n                        f = Math.abs(d - this.parent.convertValueToPixel(h.dataPoint.y[0]));\n                        for (n = v = 0; n < h.dataPoint.y.length; n++)\n                            v = Math.abs(d - this.parent.convertValueToPixel(h.dataPoint.y[n])),\n                                v < f && (f = v, b = n);\n                        k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(h.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(h.dataPoint.y[b]) << 0;\n                        l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.y[b] }) : u(this.options.label) ? ba(h.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label;\n                    }\n                    else if (\"stackedColumn\" === this.parent.dataSeries[r].type || \"stackedArea\" === this.parent.dataSeries[r].type) {\n                        f = Math.abs(d -\n                            this.parent.convertValueToPixel(k[0].dataPoint.y));\n                        D = v = 0;\n                        for (n = r; 0 <= n; n--)\n                            D += k[n].dataPoint.y, v = Math.abs(d - this.parent.convertValueToPixel(D)), v < f && (f = v, b = n);\n                        k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(D) << 0) + 0.5 : this.parent.convertValueToPixel(D) << 0;\n                        l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.y }) : u(this.options.label) ? ba(h.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;\n                    }\n                    else if (\"stackedColumn100\" ===\n                        this.parent.dataSeries[r].type || \"stackedArea100\" === this.parent.dataSeries[r].type) {\n                        f = Math.abs(d - this.parent.convertValueToPixel(k[0].dataPoint.y));\n                        D = v = 0;\n                        for (n = r; 0 <= n; n--)\n                            D += k[n].dataPoint.y, t = k[n].dataPoint.x.getTime ? k[n].dataPoint.x.getTime() : k[n].dataPoint.x, t = 100 * (D / k[n].dataSeries.plotUnit.dataPointYSums[t]), v = Math.abs(d - this.parent.convertValueToPixel(t)), v < f && (f = v, b = n);\n                        k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(t) << 0) + 0.5 : this.parent.convertValueToPixel(t) << 0;\n                        l.text = this.labelFormatter ?\n                            this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: t }) : u(this.options.label) ? ba(t, this.valueFormatString, this.chart._cultureInfo) : this.label;\n                    }\n                    else\n                        \"waterfall\" === this.parent.dataSeries[r].type ? (k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(h.dataSeries.dataPointEOs[h.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(h.dataSeries.dataPointEOs[h.index].cumulativeSum) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options,\n                            crosshair: this.options, value: h.dataSeries.dataPointEOs[h.index].cumulativeSum }) : u(this.options.label) ? ba(h.dataSeries.dataPointEOs[h.index].cumulativeSum, this.valueFormatString, this.chart._cultureInfo) : this.label) : (k = 1 === p.lineWidth % 2 ? (this.parent.convertValueToPixel(h.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(h.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: h.dataPoint.y }) : u(this.options.label) ? ba(h.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label);\n                    e = g = k;\n                    b = this.chart.plotArea.x1;\n                    c = this.chart.plotArea.x2;\n                    this.bounds = { x1: b, y1: e - m / 2, x2: c, y2: g + m / 2 };\n                    l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;\n                    l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\n                    \"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" ===\n                        this.parent._position && (l.x = this.parent.lineCoordinates.x2);\n                }\n                k = null;\n                (\"bottom\" === this.parent._position || \"top\" === this.parent._position) && (b >= this.parent.convertValueToPixel(this.parent.viewportMinimum) && c <= this.parent.convertValueToPixel(this.parent.viewportMaximum)) && (0 < m && (p.moveTo(b, e), p.lineTo(c, g), p.stroke()), p.restore(), !u(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0));\n                (\"left\" === this.parent._position || \"right\" === this.parent._position) && (g >= this.parent.convertValueToPixel(this.parent.viewportMaximum) &&\n                    e <= this.parent.convertValueToPixel(this.parent.viewportMinimum)) && (0 < m && (p.moveTo(b, e), p.lineTo(c, g), p.stroke()), p.restore(), !u(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0));\n            }\n            else {\n                if (\"bottom\" === this.parent._position || \"top\" === this.parent._position)\n                    b = c = k = 1 === p.lineWidth % 2 ? (a << 0) + 0.5 : a << 0, e = this.chart.plotArea.y1, g = this.chart.plotArea.y2, this.bounds = { x1: b - m / 2, y1: e, x2: c + m / 2, y2: g };\n                else if (\"left\" === this.parent._position || \"right\" === this.parent._position)\n                    e = g = k = 1 === p.lineWidth %\n                        2 ? (d << 0) + 0.5 : d << 0, b = this.chart.plotArea.x1, c = this.chart.plotArea.x2, this.bounds = { x1: b, y1: e - m / 2, x2: c, y2: g + m / 2 };\n                if (\"xySwapped\" === this.chart.plotInfo.axisPlacement)\n                    if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\n                        t = !1;\n                        if (this.parent.labels)\n                            for (k = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += k)\n                                if (this.parent.labels[n])\n                                    t = !0;\n                                else {\n                                    t = !1;\n                                    break;\n                                }\n                        if (t) {\n                            if (\"axisX\" === this.parent.type)\n                                for (n = this.parent.convertPixelToValue({ y: d }), f = null, r = 0; r < this.parent.dataSeries.length; r++)\n                                    (f =\n                                        this.parent.dataSeries[r].getDataPointAtX(n, !0)) && 0 <= f.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : u(this.options.label) ? f.dataPoint.label : this.label);\n                        }\n                        else\n                            \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(d) }) : u(this.options.label) ? Ca(this.parent.convertPixelToValue(d), this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(d) }) : u(this.options.label) ? ba(this.parent.convertPixelToValue(d), this.valueFormatString, this.chart._cultureInfo) : this.label);\n                        l.y = d + l.fontSize / 2 - l.measureText().height / 2 + 2;\n                        l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height -\n                            l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\n                        \"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x1 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\n                    }\n                    else {\n                        if (\"bottom\" === this.parent._position || \"top\" === this.parent._position)\n                            l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : u(this.options.label) ?\n                                ba(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label, l.x = b - l.measureText().width / 2, l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width), l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1), \"bottom\" === this.parent._position && (l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2), \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);\n                    }\n                else if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\n                    t =\n                        !1;\n                    h = \"\";\n                    if (this.parent.labels)\n                        for (k = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += k)\n                            if (this.parent.labels[n])\n                                t = !0;\n                            else {\n                                t = !1;\n                                break;\n                            }\n                    if (t) {\n                        if (\"axisX\" === this.parent.type)\n                            for (n = this.parent.convertPixelToValue({ x: a }), f = null, r = 0; r < this.parent.dataSeries.length; r++)\n                                (f = this.parent.dataSeries[r].getDataPointAtX(n, !0)) && 0 <= f.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) :\n                                    u(this.options.label) ? f.dataPoint.label : this.label);\n                    }\n                    else\n                        \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : u(this.options.label) ? Ca(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options,\n                            value: 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : \"\" }) : u(this.options.label) ? ba(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label);\n                    l.x = b - l.measureText().width / 2;\n                    l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);\n                    l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);\n                    \"bottom\" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height +\n                        l.fontSize / 2 + 2);\n                }\n                else if (\"left\" === this.parent._position || \"right\" === this.parent._position)\n                    l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(d) }) : u(this.options.label) ? ba(this.parent.convertPixelToValue(d), this.valueFormatString, this.chart._cultureInfo) : this.label, l.y = d + l.fontSize / 2 - l.measureText().height / 2 + 2, l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height -\n                        l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2), \"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\n                0 < m && (p.moveTo(b, e), p.lineTo(c, g), p.stroke());\n                p.restore();\n                !u(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0);\n            }\n            p.globalAlpha = q;\n        };\n        qa($, V);\n        $.prototype._initialize = function () {\n            if (this.enabled) {\n                this.container = document.createElement(\"div\");\n                this.container.setAttribute(\"class\", \"canvasjs-chart-tooltip\");\n                this.container.style.position = \"absolute\";\n                this.container.style.height = \"auto\";\n                this.container.style.boxShadow = \"1px 1px 2px 2px rgba(0,0,0,0.1)\";\n                this.container.style.zIndex = \"1000\";\n                this.container.style.pointerEvents = \"none\";\n                this.container.style.display = \"none\";\n                var a;\n                a = '<div style=\" width: auto;height: auto;min-width: 50px;';\n                a += \"line-height: auto;\";\n                a += \"margin: 0px 0px 0px 0px;\";\n                a += \"padding: 5px;\";\n                a += \"font-family: Calibri, Arial, Georgia, serif;\";\n                a += \"font-weight: normal;\";\n                a += \"font-style: \" + (r ? \"italic;\" : \"normal;\");\n                a += \"font-size: 14px;\";\n                a += \"color: #000000;\";\n                a += \"text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);\";\n                a += \"text-align: left;\";\n                a += \"border: 2px solid gray;\";\n                a += r ? \"background: rgba(255,255,255,.9);\" : \"background: rgb(255,255,255);\";\n                a += \"text-indent: 0px;\";\n                a += \"white-space: nowrap;\";\n                a += \"border-radius: 5px;\";\n                a += \"-moz-user-select:none;\";\n                a += \"-khtml-user-select: none;\";\n                a += \"-webkit-user-select: none;\";\n                a += \"-ms-user-select: none;\";\n                a += \"user-select: none;\";\n                r || (a += \"filter: alpha(opacity = 90);\", a += \"filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');\");\n                a += '} \"> Sample Tooltip</div>';\n                this.container.innerHTML = a;\n                this.contentDiv = this.container.firstChild;\n                this.container.style.borderRadius = this.contentDiv.style.borderRadius;\n                this.chart._canvasJSContainer.appendChild(this.container);\n            }\n        };\n        $.prototype.mouseMoveHandler = function (a, d) {\n            this._lastUpdated && 4 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(),\n                this.chart.resetOverlayedCanvas(), this._updateToolTip(a, d));\n        };\n        $.prototype._updateToolTip = function (a, d, b) {\n            b = \"undefined\" === typeof b ? !0 : b;\n            this.container || this._initialize();\n            this.enabled || this.hide();\n            if (!this.chart.disableToolTip) {\n                if (\"undefined\" === typeof a || \"undefined\" === typeof d) {\n                    if (isNaN(this._prevX) || isNaN(this._prevY))\n                        return;\n                    a = this._prevX;\n                    d = this._prevY;\n                }\n                else\n                    this._prevX = a, this._prevY = d;\n                var c = null, e = null, g = [], k = 0;\n                if (this.shared && this.enabled && \"none\" !== this.chart.plotInfo.axisPlacement) {\n                    if (\"xySwapped\" ===\n                        this.chart.plotInfo.axisPlacement) {\n                        var l = [];\n                        if (this.chart.axisX)\n                            for (var h = 0; h < this.chart.axisX.length; h++) {\n                                for (var k = this.chart.axisX[h].convertPixelToValue({ y: d }), m = null, c = 0; c < this.chart.axisX[h].dataSeries.length; c++)\n                                    (m = this.chart.axisX[h].dataSeries[c].getDataPointAtX(k, b)) && 0 <= m.index && (m.dataSeries = this.chart.axisX[h].dataSeries[c], null !== m.dataPoint.y && l.push(m));\n                                m = null;\n                            }\n                        if (this.chart.axisX2)\n                            for (h = 0; h < this.chart.axisX2.length; h++) {\n                                k = this.chart.axisX2[h].convertPixelToValue({ y: d });\n                                m = null;\n                                for (c =\n                                    0; c < this.chart.axisX2[h].dataSeries.length; c++)\n                                    (m = this.chart.axisX2[h].dataSeries[c].getDataPointAtX(k, b)) && 0 <= m.index && (m.dataSeries = this.chart.axisX2[h].dataSeries[c], null !== m.dataPoint.y && l.push(m));\n                                m = null;\n                            }\n                    }\n                    else {\n                        l = [];\n                        if (this.chart.axisX)\n                            for (h = 0; h < this.chart.axisX.length; h++)\n                                for (k = this.chart.axisX[h].convertPixelToValue({ x: a }), m = null, c = 0; c < this.chart.axisX[h].dataSeries.length; c++)\n                                    (m = this.chart.axisX[h].dataSeries[c].getDataPointAtX(k, b)) && 0 <= m.index && (m.dataSeries = this.chart.axisX[h].dataSeries[c],\n                                        null !== m.dataPoint.y && l.push(m));\n                        if (this.chart.axisX2)\n                            for (h = 0; h < this.chart.axisX2.length; h++)\n                                for (k = this.chart.axisX2[h].convertPixelToValue({ x: a }), m = null, c = 0; c < this.chart.axisX2[h].dataSeries.length; c++)\n                                    (m = this.chart.axisX2[h].dataSeries[c].getDataPointAtX(k, b)) && 0 <= m.index && (m.dataSeries = this.chart.axisX2[h].dataSeries[c], null !== m.dataPoint.y && l.push(m));\n                    }\n                    if (0 === l.length)\n                        return;\n                    l.sort(function (a, b) { return a.distance - b.distance; });\n                    b = l[0];\n                    for (c = 0; c < l.length; c++)\n                        l[c].dataPoint.x.valueOf() === b.dataPoint.x.valueOf() &&\n                            g.push(l[c]);\n                    l = null;\n                }\n                else {\n                    if (m = this.chart.getDataPointAtXY(a, d, b))\n                        this.currentDataPointIndex = m.dataPointIndex, this.currentSeriesIndex = m.dataSeries.index;\n                    else if (r)\n                        if (m = ab(a, d, this.chart._eventManager.ghostCtx), 0 < m && \"undefined\" !== typeof this.chart._eventManager.objectMap[m]) {\n                            m = this.chart._eventManager.objectMap[m];\n                            if (\"legendItem\" === m.objectType)\n                                return;\n                            this.currentSeriesIndex = m.dataSeriesIndex;\n                            this.currentDataPointIndex = 0 <= m.dataPointIndex ? m.dataPointIndex : -1;\n                        }\n                        else\n                            this.currentDataPointIndex = -1;\n                    else\n                        this.currentDataPointIndex =\n                            -1;\n                    if (0 <= this.currentSeriesIndex) {\n                        e = this.chart.data[this.currentSeriesIndex];\n                        m = {};\n                        if (0 <= this.currentDataPointIndex)\n                            c = e.dataPoints[this.currentDataPointIndex], m.dataSeries = e, m.dataPoint = c, m.index = this.currentDataPointIndex, m.distance = Math.abs(c.x - k), \"waterfall\" === e.type && (m.cumulativeSumYStartValue = e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, m.cumulativeSum = e.dataPointEOs[this.currentDataPointIndex].cumulativeSum);\n                        else {\n                            if (!this.enabled || \"line\" !== e.type && \"stepLine\" !== e.type &&\n                                \"spline\" !== e.type && \"area\" !== e.type && \"stepArea\" !== e.type && \"splineArea\" !== e.type && \"stackedArea\" !== e.type && \"stackedArea100\" !== e.type && \"rangeArea\" !== e.type && \"rangeSplineArea\" !== e.type && \"candlestick\" !== e.type && \"ohlc\" !== e.type && \"boxAndWhisker\" !== e.type)\n                                return;\n                            k = e.axisX.convertPixelToValue({ x: a });\n                            m = e.getDataPointAtX(k, b);\n                            u(m) || (m.dataSeries = e, this.currentDataPointIndex = m.index, c = m.dataPoint);\n                        }\n                        if (!u(m) && !u(m.dataPoint) && !u(m.dataPoint.y))\n                            if (m.dataSeries.axisY)\n                                if (0 < m.dataPoint.y.length) {\n                                    for (c = b = 0; c < m.dataPoint.y.length; c++)\n                                        m.dataPoint.y[c] <\n                                            m.dataSeries.axisY.viewportMinimum ? b-- : m.dataPoint.y[c] > m.dataSeries.axisY.viewportMaximum && b++;\n                                    b < m.dataPoint.y.length && b > -m.dataPoint.y.length && g.push(m);\n                                }\n                                else\n                                    \"column\" === e.type || \"bar\" === e.type ? 0 > m.dataPoint.y ? 0 > m.dataSeries.axisY.viewportMinimum && m.dataSeries.axisY.viewportMaximum >= m.dataPoint.y && g.push(m) : m.dataSeries.axisY.viewportMinimum <= m.dataPoint.y && 0 <= m.dataSeries.axisY.viewportMaximum && g.push(m) : \"bubble\" === e.type ? (b = this.chart._eventManager.objectMap[e.dataPointIds[m.index]].size / 2, m.dataPoint.y >=\n                                        m.dataSeries.axisY.viewportMinimum - b && m.dataPoint.y <= m.dataSeries.axisY.viewportMaximum + b && g.push(m)) : \"waterfall\" === e.type ? (b = 0, m.cumulativeSumYStartValue < m.dataSeries.axisY.viewportMinimum ? b-- : m.cumulativeSumYStartValue > m.dataSeries.axisY.viewportMaximum && b++, m.cumulativeSum < m.dataSeries.axisY.viewportMinimum ? b-- : m.cumulativeSum > m.dataSeries.axisY.viewportMaximum && b++, 2 > b && -2 < b && g.push(m)) : (0 <= m.dataSeries.type.indexOf(\"100\") || \"stackedColumn\" === e.type || \"stackedBar\" === e.type || m.dataPoint.y >= m.dataSeries.axisY.viewportMinimum &&\n                                        m.dataPoint.y <= m.dataSeries.axisY.viewportMaximum) && g.push(m);\n                            else\n                                g.push(m);\n                    }\n                }\n                if (0 < g.length) {\n                    if (this.highlightObjects(g), this.enabled)\n                        if (b = \"\", b = this.getToolTipInnerHTML({ entries: g }), null !== b) {\n                            this.contentDiv.innerHTML = b;\n                            b = !1;\n                            \"none\" === this.container.style.display && (b = !0, this.container.style.display = \"block\");\n                            try {\n                                this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : r ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\", this.borderColor = \"waterfall\" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor =\n                                    this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : 0 < g[0].dataPoint.y ? g[0].dataSeries.risingColor : g[0].dataSeries.fallingColor : \"error\" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[e.index %\n                                    g[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[g[0].index % g[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + \"px\" : \"2px\", this.contentDiv.style.borderRadius = this.cornerRadius ||\n                                    0 === this.cornerRadius ? this.cornerRadius + \"px\" : \"5px\", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + \"px\" : \"14px\", this.contentDiv.style.color = this.fontColor ? this.fontColor : \"#000000\", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : \"Calibri, Arial, Georgia, serif;\", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : \"normal\", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle :\n                                    r ? \"italic\" : \"normal\";\n                            }\n                            catch (p) { }\n                            \"pie\" === g[0].dataSeries.type || \"doughnut\" === g[0].dataSeries.type || \"funnel\" === g[0].dataSeries.type || \"pyramid\" === g[0].dataSeries.type || \"bar\" === g[0].dataSeries.type || \"rangeBar\" === g[0].dataSeries.type || \"stackedBar\" === g[0].dataSeries.type || \"stackedBar100\" === g[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10);\n                            0 > a && (a += this.container.clientWidth + 20);\n                            a + this.container.clientWidth >\n                                Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));\n                            d = 1 !== g.length || this.shared || \"line\" !== g[0].dataSeries.type && \"stepLine\" !== g[0].dataSeries.type && \"spline\" !== g[0].dataSeries.type && \"area\" !== g[0].dataSeries.type && \"stepArea\" !== g[0].dataSeries.type && \"splineArea\" !== g[0].dataSeries.type ? \"bar\" === g[0].dataSeries.type || \"rangeBar\" === g[0].dataSeries.type || \"stackedBar\" === g[0].dataSeries.type || \"stackedBar100\" ===\n                                g[0].dataSeries.type ? g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) : d : g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y);\n                            d = -d + 10;\n                            0 < d + this.container.clientHeight + 5 && (d -= d + this.container.clientHeight + 5 - 0);\n                            this.fixMozTransitionDelay(a, d);\n                            !this.animationEnabled || b ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);\n                            this.container.style.left = a + \"px\";\n                            this.container.style.bottom = d + \"px\";\n                        }\n                        else\n                            this.hide(!1);\n                }\n                else\n                    this.hide();\n            }\n        };\n        $.prototype.highlightObjects = function (a) {\n            var d = this.chart.overlaidCanvasCtx;\n            this.chart.resetOverlayedCanvas();\n            d.clearRect(0, 0, this.chart.width, this.chart.height);\n            d.save();\n            var b = this.chart.plotArea, c = 0;\n            d.beginPath();\n            d.rect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);\n            d.clip();\n            for (b = 0; b < a.length; b++) {\n                var e = a[b];\n                if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && \"dataPoint\" === e.objectType) {\n                    var c = this.chart.data[e.dataSeriesIndex], g = c.dataPoints[e.dataPointIndex], k = e.dataPointIndex;\n                    !1 === g.highlightEnabled || !0 !== c.highlightEnabled && !0 !== g.highlightEnabled || (\"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"scatter\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"stackedArea\" === c.type || \"stackedArea100\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type ? (g = c.getMarkerProperties(k, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || \"#FFFFFF\", g.borderThickness = g.borderThickness || Math.ceil(0.1 *\n                        g.size), ia.drawMarkers([g]), \"undefined\" !== typeof e.y2 && (g = c.getMarkerProperties(k, e.x1, e.y2, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || \"#FFFFFF\", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), ia.drawMarkers([g]))) : \"bubble\" === c.type ? (g = c.getMarkerProperties(k, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = e.size, g.color = \"white\", g.borderColor = \"white\", d.globalAlpha = 0.3, ia.drawMarkers([g]), d.globalAlpha = 1) : \"column\" === c.type || \"stackedColumn\" ===\n                        c.type || \"stackedColumn100\" === c.type || \"bar\" === c.type || \"rangeBar\" === c.type || \"stackedBar\" === c.type || \"stackedBar100\" === c.type || \"rangeColumn\" === c.type || \"waterfall\" === c.type ? ea(d, e.x1, e.y1, e.x2, e.y2, \"white\", 0, null, !1, !1, !1, !1, 0.3) : \"pie\" === c.type || \"doughnut\" === c.type ? ja(d, e.center, e.radius, \"white\", c.type, e.startAngle, e.endAngle, 0.3, e.percentInnerRadius) : \"funnel\" === c.type || \"pyramid\" === c.type ? ra(d, e.funnelSection, 0.3, \"white\") : \"candlestick\" === c.type ? (d.globalAlpha = 1, d.strokeStyle = e.color, d.lineWidth = 2 * e.borderThickness,\n                        c = 0 === d.lineWidth % 2 ? 0 : 0.5, d.beginPath(), d.moveTo(e.x3 - c, Math.min(e.y2, e.y3)), d.lineTo(e.x3 - c, Math.min(e.y1, e.y4)), d.stroke(), d.beginPath(), d.moveTo(e.x3 - c, Math.max(e.y1, e.y4)), d.lineTo(e.x3 - c, Math.max(e.y2, e.y3)), d.stroke(), ea(d, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), \"transparent\", 2 * e.borderThickness, e.color, !1, !1, !1, !1), d.globalAlpha = 1) : \"ohlc\" === c.type ? (d.globalAlpha = 1, d.strokeStyle = e.color, d.lineWidth = 2 * e.borderThickness, c = 0 === d.lineWidth % 2 ? 0 : 0.5, d.beginPath(), d.moveTo(e.x3 - c, e.y2), d.lineTo(e.x3 -\n                        c, e.y3), d.stroke(), d.beginPath(), d.moveTo(e.x3, e.y1), d.lineTo(e.x1, e.y1), d.stroke(), d.beginPath(), d.moveTo(e.x3, e.y4), d.lineTo(e.x2, e.y4), d.stroke(), d.globalAlpha = 1) : \"boxAndWhisker\" === c.type ? (d.save(), d.globalAlpha = 1, d.strokeStyle = e.stemColor, d.lineWidth = 2 * e.stemThickness, 0 < e.stemThickness && (d.beginPath(), d.moveTo(e.x3, e.y2 + e.borderThickness / 2), d.lineTo(e.x3, e.y1 + e.whiskerThickness / 2), d.stroke(), d.beginPath(), d.moveTo(e.x3, e.y4 - e.whiskerThickness / 2), d.lineTo(e.x3, e.y3 - e.borderThickness / 2), d.stroke()),\n                        d.beginPath(), ea(d, e.x1 - e.borderThickness / 2, Math.max(e.y2 + e.borderThickness / 2, e.y3 + e.borderThickness / 2), e.x2 + e.borderThickness / 2, Math.min(e.y2 - e.borderThickness / 2, e.y3 - e.borderThickness / 2), \"transparent\", e.borderThickness, e.color, !1, !1, !1, !1), d.globalAlpha = 1, d.strokeStyle = e.whiskerColor, d.lineWidth = 2 * e.whiskerThickness, 0 < e.whiskerThickness && (d.beginPath(), d.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y4), d.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y4), d.stroke(), d.beginPath(), d.moveTo(Math.floor(e.x3 -\n                        e.whiskerLength / 2), e.y1), d.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y1), d.stroke()), d.globalAlpha = 1, d.strokeStyle = e.lineColor, d.lineWidth = 2 * e.lineThickness, 0 < e.lineThickness && (d.beginPath(), d.moveTo(e.x1, e.y5), d.lineTo(e.x2, e.y5), d.stroke()), d.restore(), d.globalAlpha = 1) : \"error\" === c.type && E(d, e.x1, e.y1, e.x2, e.y2, \"white\", e.whiskerProperties, e.stemProperties, e.isXYSwapped, 0.3));\n                }\n            }\n            d.restore();\n            d.globalAlpha = 1;\n            d.beginPath();\n        };\n        $.prototype.getToolTipInnerHTML = function (a) {\n            a = a.entries;\n            for (var d = null, b = null, c = null, e = 0, g = \"\", k = !0, h = 0; h < a.length; h++)\n                if (a[h].dataSeries.toolTipContent || a[h].dataPoint.toolTipContent) {\n                    k = !1;\n                    break;\n                }\n            if (k && (this.content && \"function\" === typeof this.content || this.contentFormatter))\n                a = { chart: this.chart, toolTip: this.options, entries: a }, d = this.contentFormatter ? this.contentFormatter(a) : this.content(a);\n            else if (this.shared && \"none\" !== this.chart.plotInfo.axisPlacement) {\n                for (var p = null, m = \"\", h = 0; h < a.length; h++)\n                    b = a[h].dataSeries, c = a[h].dataPoint, e = a[h].index, g = \"\", 0 === h && (k && !this.content) && (this.chart.axisX &&\n                        0 < this.chart.axisX.length ? m += \"undefined\" !== typeof this.chart.axisX[0].labels[c.x] ? this.chart.axisX[0].labels[c.x] : \"{x}\" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (m += \"undefined\" !== typeof this.chart.axisX2[0].labels[c.x] ? this.chart.axisX2[0].labels[c.x] : \"{x}\"), m += \"</br>\", m = this.chart.replaceKeywordsWithValue(m, c, b, e)), null === c.toolTipContent || \"undefined\" === typeof c.toolTipContent && null === b.options.toolTipContent || (\"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"area\" === b.type || \"stepArea\" ===\n                        b.type || \"splineArea\" === b.type || \"column\" === b.type || \"bar\" === b.type || \"scatter\" === b.type || \"stackedColumn\" === b.type || \"stackedColumn100\" === b.type || \"stackedBar\" === b.type || \"stackedBar100\" === b.type || \"stackedArea\" === b.type || \"stackedArea100\" === b.type || \"waterfall\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += p != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ?\n                        this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y}\", p = b.axisXIndex) : \"bubble\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += p != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}\") :\n                        \"rangeColumn\" === b.type || \"rangeBar\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"error\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += p != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}\") : \"candlestick\" ===\n                            b.type || \"ohlc\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += p != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}\") : \"boxAndWhisker\" ===\n                            b.type && (this.chart.axisX && 1 < this.chart.axisX.length && (g += p != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}\"),\n                        null === d && (d = \"\"), !0 === this.reversed ? (d = this.chart.replaceKeywordsWithValue(g, c, b, e) + d, h < a.length - 1 && (d = \"</br>\" + d)) : (d += this.chart.replaceKeywordsWithValue(g, c, b, e), h < a.length - 1 && (d += \"</br>\")));\n                null !== d && (d = m + d);\n            }\n            else {\n                b = a[0].dataSeries;\n                c = a[0].dataPoint;\n                e = a[0].index;\n                if (null === c.toolTipContent || \"undefined\" === typeof c.toolTipContent && null === b.options.toolTipContent)\n                    return null;\n                \"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"area\" === b.type || \"stepArea\" === b.type || \"splineArea\" === b.type || \"column\" ===\n                    b.type || \"bar\" === b.type || \"scatter\" === b.type || \"stackedColumn\" === b.type || \"stackedColumn100\" === b.type || \"stackedBar\" === b.type || \"stackedBar100\" === b.type || \"stackedArea\" === b.type || \"stackedArea100\" === b.type || \"waterfall\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \":</span>&nbsp;&nbsp;{y}\" : \"bubble\" === b.type ? g = c.toolTipContent ?\n                    c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}\" : \"pie\" === b.type || \"doughnut\" === b.type || \"funnel\" === b.type || \"pyramid\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" :\n                    \"'color:{color};'\") + \"\\\"'>\" + (c.name ? \"{name}:</span>&nbsp;&nbsp;\" : c.label ? \"{label}:</span>&nbsp;&nbsp;\" : \"</span>\") + \"{y}\" : \"rangeColumn\" === b.type || \"rangeBar\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"error\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \" :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}\" :\n                    \"candlestick\" === b.type || \"ohlc\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \"</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}\" : \"boxAndWhisker\" === b.type && (g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent :\n                        this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \"</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}\");\n                null === d && (d = \"\");\n                d += this.chart.replaceKeywordsWithValue(g, c, b, e);\n            }\n            return d;\n        };\n        $.prototype.enableAnimation = function () { if (!this.container.style.WebkitTransition) {\n            var a = this.getContainerTransition(this.containerTransitionDuration);\n            this.container.style.WebkitTransition = a;\n            this.container.style.MsTransition = a;\n            this.container.style.transition = a;\n            this.container.style.MozTransition = this.mozContainerTransition;\n        } };\n        $.prototype.disableAnimation = function () {\n            this.container.style.WebkitTransition && (this.container.style.WebkitTransition =\n                \"\", this.container.style.MozTransition = \"\", this.container.style.MsTransition = \"\", this.container.style.transition = \"\");\n        };\n        $.prototype.hide = function (a) { this.container && (this.container.style.display = \"none\", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, (\"undefined\" === typeof a || a) && this.chart.resetOverlayedCanvas()); };\n        $.prototype.show = function (a, d, b) { this._updateToolTip(a, d, \"undefined\" === typeof b ? !1 : b); };\n        $.prototype.fixMozTransitionDelay = function (a, d) {\n            if (20 < this.chart._eventManager.lastObjectId)\n                this.mozContainerTransition =\n                    this.getContainerTransition(0);\n            else {\n                var b = parseFloat(this.container.style.left), b = isNaN(b) ? 0 : b, c = parseFloat(this.container.style.bottom), c = isNaN(c) ? 0 : c;\n                10 < Math.sqrt(Math.pow(b - a, 2) + Math.pow(c - d, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0);\n            }\n        };\n        $.prototype.getContainerTransition = function (a) { return \"left \" + a + \"s ease-out 0s, bottom \" + a + \"s ease-out 0s\"; };\n        ha.prototype.reset = function () {\n            this.lastObjectId = 0;\n            this.objectMap = [];\n            this.rectangularRegionEventSubscriptions =\n                [];\n            this.previousDataPointEventObject = null;\n            this.eventObjects = [];\n            r && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());\n        };\n        ha.prototype.getNewObjectTrackingId = function () { return ++this.lastObjectId; };\n        ha.prototype.mouseEventHandler = function (a) {\n            if (\"mousemove\" === a.type || \"click\" === a.type) {\n                var d = [], b = Ra(a), c = null;\n                if ((c = this.chart.getObjectAtXY(b.x, b.y, !1)) && \"undefined\" !== typeof this.objectMap[c])\n                    if (c = this.objectMap[c], \"dataPoint\" === c.objectType) {\n                        var e = this.chart.data[c.dataSeriesIndex], g = e.dataPoints[c.dataPointIndex], h = c.dataPointIndex;\n                        c.eventParameter = { x: b.x, y: b.y, dataPoint: g, dataSeries: e.options, dataPointIndex: h, dataSeriesIndex: e.index, chart: this.chart };\n                        c.eventContext = { context: g, userContext: g, mouseover: \"mouseover\", mousemove: \"mousemove\", mouseout: \"mouseout\", click: \"click\" };\n                        d.push(c);\n                        c = this.objectMap[e.id];\n                        c.eventParameter = { x: b.x, y: b.y, dataPoint: g, dataSeries: e.options, dataPointIndex: h, dataSeriesIndex: e.index, chart: this.chart };\n                        c.eventContext = { context: e, userContext: e.options, mouseover: \"mouseover\",\n                            mousemove: \"mousemove\", mouseout: \"mouseout\", click: \"click\" };\n                        d.push(this.objectMap[e.id]);\n                    }\n                    else\n                        \"legendItem\" === c.objectType && (e = this.chart.data[c.dataSeriesIndex], g = null !== c.dataPointIndex ? e.dataPoints[c.dataPointIndex] : null, c.eventParameter = { x: b.x, y: b.y, dataSeries: e.options, dataPoint: g, dataPointIndex: c.dataPointIndex, dataSeriesIndex: c.dataSeriesIndex, chart: this.chart }, c.eventContext = { context: this.chart.legend, userContext: this.chart.legend.options, mouseover: \"itemmouseover\", mousemove: \"itemmousemove\", mouseout: \"itemmouseout\",\n                            click: \"itemclick\" }, d.push(c));\n                e = [];\n                for (b = 0; b < this.mouseoveredObjectMaps.length; b++) {\n                    g = !0;\n                    for (c = 0; c < d.length; c++)\n                        if (d[c].id === this.mouseoveredObjectMaps[b].id) {\n                            g = !1;\n                            break;\n                        }\n                    g ? this.fireEvent(this.mouseoveredObjectMaps[b], \"mouseout\", a) : e.push(this.mouseoveredObjectMaps[b]);\n                }\n                this.mouseoveredObjectMaps = e;\n                for (b = 0; b < d.length; b++) {\n                    e = !1;\n                    for (c = 0; c < this.mouseoveredObjectMaps.length; c++)\n                        if (d[b].id === this.mouseoveredObjectMaps[c].id) {\n                            e = !0;\n                            break;\n                        }\n                    e || (this.fireEvent(d[b], \"mouseover\", a), this.mouseoveredObjectMaps.push(d[b]));\n                    \"click\" === a.type ? this.fireEvent(d[b], \"click\", a) : \"mousemove\" === a.type && this.fireEvent(d[b], \"mousemove\", a);\n                }\n            }\n        };\n        ha.prototype.fireEvent = function (a, d, b) {\n            if (a && d) {\n                var c = a.eventParameter, e = a.eventContext, g = a.eventContext.userContext;\n                g && (e && g[e[d]]) && g[e[d]].call(g, c);\n                \"mouseout\" !== d ? g.cursor && g.cursor !== b.target.style.cursor && (b.target.style.cursor = g.cursor) : (b.target.style.cursor = this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext);\n                \"click\" === d && (\"dataPoint\" === a.objectType && this.chart.pieDoughnutClickHandler) &&\n                    this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], c);\n                \"click\" === d && (\"dataPoint\" === a.objectType && this.chart.funnelPyramidClickHandler) && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], c);\n            }\n        };\n        ga.prototype.animate = function (a, d, b, c, e) {\n            var g = this;\n            this.chart.isAnimating = !0;\n            e = e || M.easing.linear;\n            b && this.animations.push({ startTime: (new Date).getTime() + (a ? a : 0), duration: d, animationCallback: b, onComplete: c });\n            for (a = []; 0 < this.animations.length;)\n                if (d = this.animations.shift(),\n                    b = (new Date).getTime(), c = 0, d.startTime <= b && (c = e(Math.min(b - d.startTime, d.duration), 0, 1, d.duration), c = Math.min(c, 1), isNaN(c) || !isFinite(c)) && (c = 1), 1 > c && a.push(d), d.animationCallback(c), 1 <= c && d.onComplete)\n                    d.onComplete();\n            this.animations = a;\n            0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function () { g.animate.call(g); }) : this.chart.isAnimating = !1;\n        };\n        ga.prototype.cancelAllAnimations = function () {\n            this.animations = [];\n            this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);\n            this.animationRequestId = null;\n            this.chart.isAnimating = !1;\n        };\n        var M = { yScaleAnimation: function (a, d) { if (0 !== a) {\n                var b = d.dest, c = d.source.canvas, e = d.animationBase;\n                b.drawImage(c, 0, 0, c.width, c.height, 0, e - e * a, b.canvas.width / W, a * b.canvas.height / W);\n            } }, xScaleAnimation: function (a, d) { if (0 !== a) {\n                var b = d.dest, c = d.source.canvas, e = d.animationBase;\n                b.drawImage(c, 0, 0, c.width, c.height, e - e * a, 0, a * b.canvas.width / W, b.canvas.height / W);\n            } }, xClipAnimation: function (a, d) {\n                if (0 !== a) {\n                    var b = d.dest, c = d.source.canvas;\n                    b.save();\n                    0 < a && b.drawImage(c, 0, 0, c.width * a, c.height, 0, 0, c.width * a / W, c.height / W);\n                    b.restore();\n                }\n            }, fadeInAnimation: function (a, d) { if (0 !== a) {\n                var b = d.dest, c = d.source.canvas;\n                b.save();\n                b.globalAlpha = a;\n                b.drawImage(c, 0, 0, c.width, c.height, 0, 0, b.canvas.width / W, b.canvas.height / W);\n                b.restore();\n            } }, easing: { linear: function (a, d, b, c) { return b * a / c + d; }, easeOutQuad: function (a, d, b, c) { return -b * (a /= c) * (a - 2) + d; }, easeOutQuart: function (a, d, b, c) { return -b * ((a = a / c - 1) * a * a * a - 1) + d; }, easeInQuad: function (a, d, b, c) { return b * (a /= c) * a + d; }, easeInQuart: function (a, d, b, c) { return b * (a /= c) * a * a * a + d; } } }, ia = { drawMarker: function (a, d, b, c, e, g, h, l) {\n                if (b) {\n                    var p = 1;\n                    b.fillStyle = g ? g : \"#000000\";\n                    b.strokeStyle = h ? h : \"#000000\";\n                    b.lineWidth = l ? l : 0;\n                    b.setLineDash && b.setLineDash(R(\"solid\", l));\n                    \"circle\" === c ? (b.moveTo(a, d), b.beginPath(), b.arc(a, d, e / 2, 0, 2 * Math.PI, !1), g && b.fill(), l && (h ? b.stroke() : (p = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = p))) : \"square\" === c ? (b.beginPath(), b.rect(a - e / 2, d - e / 2, e, e), g && b.fill(), l && (h ? b.stroke() : (p = b.globalAlpha, b.globalAlpha =\n                        0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = p))) : \"triangle\" === c ? (b.beginPath(), b.moveTo(a - e / 2, d + e / 2), b.lineTo(a + e / 2, d + e / 2), b.lineTo(a, d - e / 2), b.closePath(), g && b.fill(), l && (h ? b.stroke() : (p = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = p)), b.beginPath()) : \"cross\" === c && (b.strokeStyle = g, b.lineWidth = e / 4, b.beginPath(), b.moveTo(a - e / 2, d - e / 2), b.lineTo(a + e / 2, d + e / 2), b.stroke(), b.moveTo(a + e / 2, d - e / 2), b.lineTo(a - e / 2, d + e / 2), b.stroke());\n                }\n            }, drawMarkers: function (a) {\n                for (var d = 0; d < a.length; d++) {\n                    var b = a[d];\n                    ia.drawMarker(b.x, b.y, b.ctx, b.type, b.size, b.color, b.borderColor, b.borderThickness);\n                }\n            } };\n        return p;\n    }();\n    Na.Chart.version = \"v2.3.2 GA\";\n})();\n/*\n  excanvas is used to support IE678 which do not implement HTML5 Canvas Element. You can safely remove the following excanvas code if you don't need to support older browsers.\n\n  Copyright 2006 Google Inc. https://code.google.com/p/explorercanvas/\n  Licensed under the Apache License, Version 2.0\n*/\ndocument.createElement(\"canvas\").getContext || function () {\n    function V() { return this.context_ || (this.context_ = new C(this)); }\n    function W(a, b, c) { var g = M.call(arguments, 2); return function () { return a.apply(b, g.concat(M.call(arguments))); }; }\n    function N(a) { return String(a).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\"); }\n    function O(a) {\n        a.namespaces.g_vml_ || a.namespaces.add(\"g_vml_\", \"urn:schemas-microsoft-com:vml\", \"#default#VML\");\n        a.namespaces.g_o_ || a.namespaces.add(\"g_o_\", \"urn:schemas-microsoft-com:office:office\", \"#default#VML\");\n        a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = \"ex_canvas_\", a.cssText = \"canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}\");\n    }\n    function X(a) {\n        var b = a.srcElement;\n        switch (a.propertyName) {\n            case \"width\":\n                b.getContext().clearRect();\n                b.style.width = b.attributes.width.nodeValue + \"px\";\n                b.firstChild.style.width = b.clientWidth + \"px\";\n                break;\n            case \"height\": b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + \"px\", b.firstChild.style.height = b.clientHeight +\n                \"px\";\n        }\n    }\n    function Y(a) { a = a.srcElement; a.firstChild && (a.firstChild.style.width = a.clientWidth + \"px\", a.firstChild.style.height = a.clientHeight + \"px\"); }\n    function D() { return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; }\n    function t(a, b) { for (var c = D(), g = 0; 3 > g; g++)\n        for (var e = 0; 3 > e; e++) {\n            for (var f = 0, d = 0; 3 > d; d++)\n                f += a[g][d] * b[d][e];\n            c[g][e] = f;\n        } return c; }\n    function P(a, b) {\n        b.fillStyle = a.fillStyle;\n        b.lineCap = a.lineCap;\n        b.lineJoin = a.lineJoin;\n        b.lineWidth = a.lineWidth;\n        b.miterLimit = a.miterLimit;\n        b.shadowBlur = a.shadowBlur;\n        b.shadowColor = a.shadowColor;\n        b.shadowOffsetX =\n            a.shadowOffsetX;\n        b.shadowOffsetY = a.shadowOffsetY;\n        b.strokeStyle = a.strokeStyle;\n        b.globalAlpha = a.globalAlpha;\n        b.font = a.font;\n        b.textAlign = a.textAlign;\n        b.textBaseline = a.textBaseline;\n        b.arcScaleX_ = a.arcScaleX_;\n        b.arcScaleY_ = a.arcScaleY_;\n        b.lineScale_ = a.lineScale_;\n    }\n    function Q(a) { var b = a.indexOf(\"(\", 3), c = a.indexOf(\")\", b + 1), b = a.substring(b + 1, c).split(\",\"); if (4 != b.length || \"a\" != a.charAt(3))\n        b[3] = 1; return b; }\n    function E(a, b, c) { return Math.min(c, Math.max(b, a)); }\n    function F(a, b, c) {\n        0 > c && c++;\n        1 < c && c--;\n        return 1 > 6 * c ? a + 6 * (b - a) * c :\n            1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a;\n    }\n    function G(a) {\n        if (a in H)\n            return H[a];\n        var b, c = 1;\n        a = String(a);\n        if (\"#\" == a.charAt(0))\n            b = a;\n        else if (/^rgb/.test(a)) {\n            c = Q(a);\n            b = \"#\";\n            for (var g, e = 0; 3 > e; e++)\n                g = -1 != c[e].indexOf(\"%\") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += v[E(g, 0, 255)];\n            c = +c[3];\n        }\n        else if (/^hsl/.test(a)) {\n            e = c = Q(a);\n            b = parseFloat(e[0]) / 360 % 360;\n            0 > b && b++;\n            g = E(parseFloat(e[1]) / 100, 0, 1);\n            e = E(parseFloat(e[2]) / 100, 0, 1);\n            if (0 == g)\n                g = e = b = e;\n            else {\n                var f = 0.5 > e ? e * (1 + g) : e + g - e * g, d = 2 * e - f;\n                g = F(d, f, b + 1 / 3);\n                e = F(d, f, b);\n                b = F(d, f, b - 1 / 3);\n            }\n            b = \"#\" +\n                v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];\n            c = c[3];\n        }\n        else\n            b = Z[a] || a;\n        return H[a] = { color: b, alpha: c };\n    }\n    function C(a) {\n        this.m_ = D();\n        this.mStack_ = [];\n        this.aStack_ = [];\n        this.currentPath_ = [];\n        this.fillStyle = this.strokeStyle = \"#000\";\n        this.lineWidth = 1;\n        this.lineJoin = \"miter\";\n        this.lineCap = \"butt\";\n        this.miterLimit = 1 * q;\n        this.globalAlpha = 1;\n        this.font = \"10px sans-serif\";\n        this.textAlign = \"left\";\n        this.textBaseline = \"alphabetic\";\n        this.canvas = a;\n        var b = \"width:\" + a.clientWidth + \"px;height:\" + a.clientHeight + \"px;overflow:hidden;position:absolute\", c = a.ownerDocument.createElement(\"div\");\n        c.style.cssText = b;\n        a.appendChild(c);\n        b = c.cloneNode(!1);\n        b.style.backgroundColor = \"red\";\n        b.style.filter = \"alpha(opacity=0)\";\n        a.appendChild(b);\n        this.element_ = c;\n        this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;\n    }\n    function R(a, b, c, g) { a.currentPath_.push({ type: \"bezierCurveTo\", cp1x: b.x, cp1y: b.y, cp2x: c.x, cp2y: c.y, x: g.x, y: g.y }); a.currentX_ = g.x; a.currentY_ = g.y; }\n    function S(a, b) {\n        var c = G(a.strokeStyle), g = c.color, c = c.alpha * a.globalAlpha, e = a.lineScale_ * a.lineWidth;\n        1 > e && (c *= e);\n        b.push(\"<g_vml_:stroke\", ' opacity=\"', c, '\"', ' joinstyle=\"', a.lineJoin, '\"', ' miterlimit=\"', a.miterLimit, '\"', ' endcap=\"', $[a.lineCap] || \"square\", '\"', ' weight=\"', e, 'px\"', ' color=\"', g, '\" />');\n    }\n    function T(a, b, c, g) {\n        var e = a.fillStyle, f = a.arcScaleX_, d = a.arcScaleY_, k = g.x - c.x, n = g.y - c.y;\n        if (e instanceof w) {\n            var h = 0, l = g = 0, u = 0, m = 1;\n            if (\"gradient\" == e.type_) {\n                h = e.x1_ / f;\n                c = e.y1_ / d;\n                var p = s(a, e.x0_ / f, e.y0_ / d), h = s(a, h, c), h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI;\n                0 > h && (h += 360);\n                1E-6 > h && (h = 0);\n            }\n            else\n                p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k, l = (p.y - c.y) / n, k /= f * q,\n                    n /= d * q, m = x.max(k, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u;\n            f = e.colors_;\n            f.sort(function (a, b) { return a.offset - b.offset; });\n            d = f.length;\n            p = f[0].color;\n            c = f[d - 1].color;\n            k = f[0].alpha * a.globalAlpha;\n            a = f[d - 1].alpha * a.globalAlpha;\n            for (var n = [], r = 0; r < d; r++) {\n                var t = f[r];\n                n.push(t.offset * m + u + \" \" + t.color);\n            }\n            b.push('<g_vml_:fill type=\"', e.type_, '\"', ' method=\"none\" focus=\"100%\"', ' color=\"', p, '\"', ' color2=\"', c, '\"', ' colors=\"', n.join(\",\"), '\"', ' opacity=\"', a, '\"', ' g_o_:opacity2=\"', k, '\"', ' angle=\"', h, '\"', ' focusposition=\"', g, \",\", l, '\" />');\n        }\n        else\n            e instanceof\n                I ? k && n && b.push(\"<g_vml_:fill\", ' position=\"', -c.x / k * f * f, \",\", -c.y / n * d * d, '\"', ' type=\"tile\"', ' src=\"', e.src_, '\" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color=\"', e.color, '\" opacity=\"', e.alpha * a.globalAlpha, '\" />'));\n    }\n    function s(a, b, c) { a = a.m_; return { x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r, y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r }; }\n    function z(a, b, c) {\n        isFinite(b[0][0]) && (isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1])) && (a.m_ = b, c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] *\n            b[1][0]))));\n    }\n    function w(a) { this.type_ = a; this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0; this.colors_ = []; }\n    function I(a, b) { if (!a || 1 != a.nodeType || \"IMG\" != a.tagName)\n        throw new A(\"TYPE_MISMATCH_ERR\"); if (\"complete\" != a.readyState)\n        throw new A(\"INVALID_STATE_ERR\"); switch (b) {\n        case \"repeat\":\n        case null:\n        case \"\":\n            this.repetition_ = \"repeat\";\n            break;\n        case \"repeat-x\":\n        case \"repeat-y\":\n        case \"no-repeat\":\n            this.repetition_ = b;\n            break;\n        default: throw new A(\"SYNTAX_ERR\");\n    } this.src_ = a.src; this.width_ = a.width; this.height_ = a.height; }\n    function A(a) { this.code = this[a]; this.message = a + \": DOM Exception \" + this.code; }\n    var x = Math, k = x.round, J = x.sin, K = x.cos, ba = x.abs, aa = x.sqrt, q = 10, r = q / 2;\n    navigator.userAgent.match(/MSIE ([\\d.]+)?/);\n    var M = Array.prototype.slice;\n    O(document);\n    var U = { init: function (a) { a = a || document; a.createElement(\"canvas\"); a.attachEvent(\"onreadystatechange\", W(this.init_, this, a)); }, init_: function (a) { a = a.getElementsByTagName(\"canvas\"); for (var b = 0; b < a.length; b++)\n            this.initElement(a[b]); }, initElement: function (a) {\n            if (!a.getContext) {\n                a.getContext =\n                    V;\n                O(a.ownerDocument);\n                a.innerHTML = \"\";\n                a.attachEvent(\"onpropertychange\", X);\n                a.attachEvent(\"onresize\", Y);\n                var b = a.attributes;\n                b.width && b.width.specified ? a.style.width = b.width.nodeValue + \"px\" : a.width = a.clientWidth;\n                b.height && b.height.specified ? a.style.height = b.height.nodeValue + \"px\" : a.height = a.clientHeight;\n            }\n            return a;\n        } };\n    U.init();\n    for (var v = [], d = 0; 16 > d; d++)\n        for (var B = 0; 16 > B; B++)\n            v[16 * d + B] = d.toString(16) + B.toString(16);\n    var Z = { aliceblue: \"#F0F8FF\", antiquewhite: \"#FAEBD7\", aquamarine: \"#7FFFD4\", azure: \"#F0FFFF\", beige: \"#F5F5DC\",\n        bisque: \"#FFE4C4\", black: \"#000000\", blanchedalmond: \"#FFEBCD\", blueviolet: \"#8A2BE2\", brown: \"#A52A2A\", burlywood: \"#DEB887\", cadetblue: \"#5F9EA0\", chartreuse: \"#7FFF00\", chocolate: \"#D2691E\", coral: \"#FF7F50\", cornflowerblue: \"#6495ED\", cornsilk: \"#FFF8DC\", crimson: \"#DC143C\", cyan: \"#00FFFF\", darkblue: \"#00008B\", darkcyan: \"#008B8B\", darkgoldenrod: \"#B8860B\", darkgray: \"#A9A9A9\", darkgreen: \"#006400\", darkgrey: \"#A9A9A9\", darkkhaki: \"#BDB76B\", darkmagenta: \"#8B008B\", darkolivegreen: \"#556B2F\", darkorange: \"#FF8C00\", darkorchid: \"#9932CC\", darkred: \"#8B0000\",\n        darksalmon: \"#E9967A\", darkseagreen: \"#8FBC8F\", darkslateblue: \"#483D8B\", darkslategray: \"#2F4F4F\", darkslategrey: \"#2F4F4F\", darkturquoise: \"#00CED1\", darkviolet: \"#9400D3\", deeppink: \"#FF1493\", deepskyblue: \"#00BFFF\", dimgray: \"#696969\", dimgrey: \"#696969\", dodgerblue: \"#1E90FF\", firebrick: \"#B22222\", floralwhite: \"#FFFAF0\", forestgreen: \"#228B22\", gainsboro: \"#DCDCDC\", ghostwhite: \"#F8F8FF\", gold: \"#FFD700\", goldenrod: \"#DAA520\", grey: \"#808080\", greenyellow: \"#ADFF2F\", honeydew: \"#F0FFF0\", hotpink: \"#FF69B4\", indianred: \"#CD5C5C\", indigo: \"#4B0082\",\n        ivory: \"#FFFFF0\", khaki: \"#F0E68C\", lavender: \"#E6E6FA\", lavenderblush: \"#FFF0F5\", lawngreen: \"#7CFC00\", lemonchiffon: \"#FFFACD\", lightblue: \"#ADD8E6\", lightcoral: \"#F08080\", lightcyan: \"#E0FFFF\", lightgoldenrodyellow: \"#FAFAD2\", lightgreen: \"#90EE90\", lightgrey: \"#D3D3D3\", lightpink: \"#FFB6C1\", lightsalmon: \"#FFA07A\", lightseagreen: \"#20B2AA\", lightskyblue: \"#87CEFA\", lightslategray: \"#778899\", lightslategrey: \"#778899\", lightsteelblue: \"#B0C4DE\", lightyellow: \"#FFFFE0\", limegreen: \"#32CD32\", linen: \"#FAF0E6\", magenta: \"#FF00FF\", mediumaquamarine: \"#66CDAA\",\n        mediumblue: \"#0000CD\", mediumorchid: \"#BA55D3\", mediumpurple: \"#9370DB\", mediumseagreen: \"#3CB371\", mediumslateblue: \"#7B68EE\", mediumspringgreen: \"#00FA9A\", mediumturquoise: \"#48D1CC\", mediumvioletred: \"#C71585\", midnightblue: \"#191970\", mintcream: \"#F5FFFA\", mistyrose: \"#FFE4E1\", moccasin: \"#FFE4B5\", navajowhite: \"#FFDEAD\", oldlace: \"#FDF5E6\", olivedrab: \"#6B8E23\", orange: \"#FFA500\", orangered: \"#FF4500\", orchid: \"#DA70D6\", palegoldenrod: \"#EEE8AA\", palegreen: \"#98FB98\", paleturquoise: \"#AFEEEE\", palevioletred: \"#DB7093\", papayawhip: \"#FFEFD5\",\n        peachpuff: \"#FFDAB9\", peru: \"#CD853F\", pink: \"#FFC0CB\", plum: \"#DDA0DD\", powderblue: \"#B0E0E6\", rosybrown: \"#BC8F8F\", royalblue: \"#4169E1\", saddlebrown: \"#8B4513\", salmon: \"#FA8072\", sandybrown: \"#F4A460\", seagreen: \"#2E8B57\", seashell: \"#FFF5EE\", sienna: \"#A0522D\", skyblue: \"#87CEEB\", slateblue: \"#6A5ACD\", slategray: \"#708090\", slategrey: \"#708090\", snow: \"#FFFAFA\", springgreen: \"#00FF7F\", steelblue: \"#4682B4\", tan: \"#D2B48C\", thistle: \"#D8BFD8\", tomato: \"#FF6347\", turquoise: \"#40E0D0\", violet: \"#EE82EE\", wheat: \"#F5DEB3\", whitesmoke: \"#F5F5F5\", yellowgreen: \"#9ACD32\" }, H = {}, L = {}, $ = { butt: \"flat\", round: \"round\" }, d = C.prototype;\n    d.clearRect = function () { this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null); this.element_.innerHTML = \"\"; };\n    d.beginPath = function () { this.currentPath_ = []; };\n    d.moveTo = function (a, b) { var c = s(this, a, b); this.currentPath_.push({ type: \"moveTo\", x: c.x, y: c.y }); this.currentX_ = c.x; this.currentY_ = c.y; };\n    d.lineTo = function (a, b) { var c = s(this, a, b); this.currentPath_.push({ type: \"lineTo\", x: c.x, y: c.y }); this.currentX_ = c.x; this.currentY_ = c.y; };\n    d.bezierCurveTo =\n        function (a, b, c, g, e, f) { e = s(this, e, f); a = s(this, a, b); c = s(this, c, g); R(this, a, c, e); };\n    d.quadraticCurveTo = function (a, b, c, g) { a = s(this, a, b); c = s(this, c, g); g = { x: this.currentX_ + 2 / 3 * (a.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a.y - this.currentY_) }; R(this, g, { x: g.x + (c.x - this.currentX_) / 3, y: g.y + (c.y - this.currentY_) / 3 }, c); };\n    d.arc = function (a, b, c, g, e, f) {\n        c *= q;\n        var d = f ? \"at\" : \"wa\", k = a + K(g) * c - r, n = b + J(g) * c - r;\n        g = a + K(e) * c - r;\n        e = b + J(e) * c - r;\n        k != g || f || (k += 0.125);\n        a = s(this, a, b);\n        k = s(this, k, n);\n        g = s(this, g, e);\n        this.currentPath_.push({ type: d,\n            x: a.x, y: a.y, radius: c, xStart: k.x, yStart: k.y, xEnd: g.x, yEnd: g.y });\n    };\n    d.rect = function (a, b, c, g) { this.moveTo(a, b); this.lineTo(a + c, b); this.lineTo(a + c, b + g); this.lineTo(a, b + g); this.closePath(); };\n    d.strokeRect = function (a, b, c, g) { var e = this.currentPath_; this.beginPath(); this.moveTo(a, b); this.lineTo(a + c, b); this.lineTo(a + c, b + g); this.lineTo(a, b + g); this.closePath(); this.stroke(); this.currentPath_ = e; };\n    d.fillRect = function (a, b, c, g) {\n        var e = this.currentPath_;\n        this.beginPath();\n        this.moveTo(a, b);\n        this.lineTo(a + c, b);\n        this.lineTo(a +\n            c, b + g);\n        this.lineTo(a, b + g);\n        this.closePath();\n        this.fill();\n        this.currentPath_ = e;\n    };\n    d.createLinearGradient = function (a, b, c, g) { var e = new w(\"gradient\"); e.x0_ = a; e.y0_ = b; e.x1_ = c; e.y1_ = g; return e; };\n    d.createRadialGradient = function (a, b, c, g, e, f) { var d = new w(\"gradientradial\"); d.x0_ = a; d.y0_ = b; d.r0_ = c; d.x1_ = g; d.y1_ = e; d.r1_ = f; return d; };\n    d.drawImage = function (a, b) {\n        var c, g, e, d, r, y, n, h;\n        e = a.runtimeStyle.width;\n        d = a.runtimeStyle.height;\n        a.runtimeStyle.width = \"auto\";\n        a.runtimeStyle.height = \"auto\";\n        var l = a.width, u = a.height;\n        a.runtimeStyle.width =\n            e;\n        a.runtimeStyle.height = d;\n        if (3 == arguments.length)\n            c = arguments[1], g = arguments[2], r = y = 0, n = e = l, h = d = u;\n        else if (5 == arguments.length)\n            c = arguments[1], g = arguments[2], e = arguments[3], d = arguments[4], r = y = 0, n = l, h = u;\n        else if (9 == arguments.length)\n            r = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], e = arguments[7], d = arguments[8];\n        else\n            throw Error(\"Invalid number of arguments\");\n        var m = s(this, c, g), p = [];\n        p.push(\" <g_vml_:group\", ' coordsize=\"', 10 * q, \",\", 10 * q, '\"', ' coordorigin=\"0,0\"', ' style=\"width:', 10, \"px;height:\", 10, \"px;position:absolute;\");\n        if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {\n            var t = [];\n            t.push(\"M11=\", this.m_[0][0], \",\", \"M12=\", this.m_[1][0], \",\", \"M21=\", this.m_[0][1], \",\", \"M22=\", this.m_[1][1], \",\", \"Dx=\", k(m.x / q), \",\", \"Dy=\", k(m.y / q), \"\");\n            var v = s(this, c + e, g), w = s(this, c, g + d);\n            c = s(this, c + e, g + d);\n            m.x = x.max(m.x, v.x, w.x, c.x);\n            m.y = x.max(m.y, v.y, w.y, c.y);\n            p.push(\"padding:0 \", k(m.x / q), \"px \", k(m.y / q), \"px 0;filter:progid:DXImageTransform.Microsoft.Matrix(\", t.join(\"\"), \", sizingmethod='clip');\");\n        }\n        else\n            p.push(\"top:\", k(m.y / q), \"px;left:\", k(m.x / q), \"px;\");\n        p.push(' \">', '<g_vml_:image src=\"', a.src, '\"', ' style=\"width:', q * e, \"px;\", \" height:\", q * d, 'px\"', ' cropleft=\"', r / l, '\"', ' croptop=\"', y / u, '\"', ' cropright=\"', (l - r - n) / l, '\"', ' cropbottom=\"', (u - y - h) / u, '\"', \" />\", \"</g_vml_:group>\");\n        this.element_.insertAdjacentHTML(\"BeforeEnd\", p.join(\"\"));\n    };\n    d.stroke = function (a) {\n        var b = [];\n        b.push(\"<g_vml_:shape\", ' filled=\"', !!a, '\"', ' style=\"position:absolute;width:', 10, \"px;height:\", 10, 'px;\"', ' coordorigin=\"0,0\"', ' coordsize=\"', 10 * q, \",\", 10 * q, '\"', ' stroked=\"', !a, '\"', ' path=\"');\n        for (var c = { x: null, y: null }, d = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) {\n            var f = this.currentPath_[e];\n            switch (f.type) {\n                case \"moveTo\":\n                    b.push(\" m \", k(f.x), \",\", k(f.y));\n                    break;\n                case \"lineTo\":\n                    b.push(\" l \", k(f.x), \",\", k(f.y));\n                    break;\n                case \"close\":\n                    b.push(\" x \");\n                    f = null;\n                    break;\n                case \"bezierCurveTo\":\n                    b.push(\" c \", k(f.cp1x), \",\", k(f.cp1y), \",\", k(f.cp2x), \",\", k(f.cp2y), \",\", k(f.x), \",\", k(f.y));\n                    break;\n                case \"at\":\n                case \"wa\": b.push(\" \", f.type, \" \", k(f.x - this.arcScaleX_ * f.radius), \",\", k(f.y - this.arcScaleY_ *\n                    f.radius), \" \", k(f.x + this.arcScaleX_ * f.radius), \",\", k(f.y + this.arcScaleY_ * f.radius), \" \", k(f.xStart), \",\", k(f.yStart), \" \", k(f.xEnd), \",\", k(f.yEnd));\n            }\n            if (f) {\n                if (null == c.x || f.x < c.x)\n                    c.x = f.x;\n                if (null == d.x || f.x > d.x)\n                    d.x = f.x;\n                if (null == c.y || f.y < c.y)\n                    c.y = f.y;\n                if (null == d.y || f.y > d.y)\n                    d.y = f.y;\n            }\n        }\n        b.push(' \">');\n        a ? T(this, b, c, d) : S(this, b);\n        b.push(\"</g_vml_:shape>\");\n        this.element_.insertAdjacentHTML(\"beforeEnd\", b.join(\"\"));\n    };\n    d.fill = function () { this.stroke(!0); };\n    d.closePath = function () { this.currentPath_.push({ type: \"close\" }); };\n    d.save = function () {\n        var a = {};\n        P(this, a);\n        this.aStack_.push(a);\n        this.mStack_.push(this.m_);\n        this.m_ = t(D(), this.m_);\n    };\n    d.restore = function () { this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop()); };\n    d.translate = function (a, b) { z(this, t([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), !1); };\n    d.rotate = function (a) { var b = K(a); a = J(a); z(this, t([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), !1); };\n    d.scale = function (a, b) { this.arcScaleX_ *= a; this.arcScaleY_ *= b; z(this, t([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), !0); };\n    d.transform = function (a, b, c, d, e, f) {\n        z(this, t([[a,\n                b, 0], [c, d, 0], [e, f, 1]], this.m_), !0);\n    };\n    d.setTransform = function (a, b, c, d, e, f) { z(this, [[a, b, 0], [c, d, 0], [e, f, 1]], !0); };\n    d.drawText_ = function (a, b, c, d, e) {\n        var f = this.m_;\n        d = 0;\n        var r = 1E3, t = 0, n = [], h;\n        h = this.font;\n        if (L[h])\n            h = L[h];\n        else {\n            var l = document.createElement(\"div\").style;\n            try {\n                l.font = h;\n            }\n            catch (u) { }\n            h = L[h] = { style: l.fontStyle || \"normal\", variant: l.fontVariant || \"normal\", weight: l.fontWeight || \"normal\", size: l.fontSize || 10, family: l.fontFamily || \"sans-serif\" };\n        }\n        var l = h, m = this.element_;\n        h = {};\n        for (var p in l)\n            h[p] = l[p];\n        p = parseFloat(m.currentStyle.fontSize);\n        m = parseFloat(l.size);\n        \"number\" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf(\"px\") ? h.size = m : -1 != l.size.indexOf(\"em\") ? h.size = p * m : -1 != l.size.indexOf(\"%\") ? h.size = p / 100 * m : -1 != l.size.indexOf(\"pt\") ? h.size = m / 0.75 : h.size = p;\n        h.size *= 0.981;\n        p = h.style + \" \" + h.variant + \" \" + h.weight + \" \" + h.size + \"px \" + h.family;\n        m = this.element_.currentStyle;\n        l = this.textAlign.toLowerCase();\n        switch (l) {\n            case \"left\":\n            case \"center\":\n            case \"right\": break;\n            case \"end\":\n                l = \"ltr\" == m.direction ? \"right\" : \"left\";\n                break;\n            case \"start\":\n                l = \"rtl\" == m.direction ? \"right\" :\n                    \"left\";\n                break;\n            default: l = \"left\";\n        }\n        switch (this.textBaseline) {\n            case \"hanging\":\n            case \"top\":\n                t = h.size / 1.75;\n                break;\n            case \"middle\": break;\n            default:\n            case null:\n            case \"alphabetic\":\n            case \"ideographic\":\n            case \"bottom\": t = -h.size / 2.25;\n        }\n        switch (l) {\n            case \"right\":\n                d = 1E3;\n                r = 0.05;\n                break;\n            case \"center\": d = r = 500;\n        }\n        b = s(this, b + 0, c + t);\n        n.push('<g_vml_:line from=\"', -d, ' 0\" to=\"', r, ' 0.05\" ', ' coordsize=\"100 100\" coordorigin=\"0 0\"', ' filled=\"', !e, '\" stroked=\"', !!e, '\" style=\"position:absolute;width:1px;height:1px;\">');\n        e ? S(this, n) : T(this, n, { x: -d, y: 0 }, { x: r, y: h.size });\n        e = f[0][0].toFixed(3) + \",\" + f[1][0].toFixed(3) + \",\" + f[0][1].toFixed(3) + \",\" + f[1][1].toFixed(3) + \",0,0\";\n        b = k(b.x / q) + \",\" + k(b.y / q);\n        n.push('<g_vml_:skew on=\"t\" matrix=\"', e, '\" ', ' offset=\"', b, '\" origin=\"', d, ' 0\" />', '<g_vml_:path textpathok=\"true\" />', '<g_vml_:textpath on=\"true\" string=\"', N(a), '\" style=\"v-text-align:', l, \";font:\", N(p), '\" /></g_vml_:line>');\n        this.element_.insertAdjacentHTML(\"beforeEnd\", n.join(\"\"));\n    };\n    d.fillText = function (a, b, c, d) { this.drawText_(a, b, c, d, !1); };\n    d.strokeText = function (a, b, c, d) { this.drawText_(a, b, c, d, !0); };\n    d.measureText = function (a) { this.textMeasureEl_ || (this.element_.insertAdjacentHTML(\"beforeEnd\", '<span style=\"position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;\"></span>'), this.textMeasureEl_ = this.element_.lastChild); var b = this.element_.ownerDocument; this.textMeasureEl_.innerHTML = \"\"; this.textMeasureEl_.style.font = this.font; this.textMeasureEl_.appendChild(b.createTextNode(a)); return { width: this.textMeasureEl_.offsetWidth }; };\n    d.clip = function () { };\n    d.arcTo = function () { };\n    d.createPattern = function (a, b) { return new I(a, b); };\n    w.prototype.addColorStop = function (a, b) { b = G(b); this.colors_.push({ offset: a, color: b.color, alpha: b.alpha }); };\n    d = A.prototype = Error();\n    d.INDEX_SIZE_ERR = 1;\n    d.DOMSTRING_SIZE_ERR = 2;\n    d.HIERARCHY_REQUEST_ERR = 3;\n    d.WRONG_DOCUMENT_ERR = 4;\n    d.INVALID_CHARACTER_ERR = 5;\n    d.NO_DATA_ALLOWED_ERR = 6;\n    d.NO_MODIFICATION_ALLOWED_ERR = 7;\n    d.NOT_FOUND_ERR = 8;\n    d.NOT_SUPPORTED_ERR = 9;\n    d.INUSE_ATTRIBUTE_ERR = 10;\n    d.INVALID_STATE_ERR = 11;\n    d.SYNTAX_ERR = 12;\n    d.INVALID_MODIFICATION_ERR =\n        13;\n    d.NAMESPACE_ERR = 14;\n    d.INVALID_ACCESS_ERR = 15;\n    d.VALIDATION_ERR = 16;\n    d.TYPE_MISMATCH_ERR = 17;\n    G_vmlCanvasManager = U;\n    CanvasRenderingContext2D = C;\n    CanvasGradient = w;\n    CanvasPattern = I;\n    DOMException = A;\n}();\n/*eslint-enable*/\n/*jshint ignore:end*/ \n//# sourceMappingURL=canvasjs.min.js.map","import { WorkArea } from './work-area.model';\n\nexport class Agv {\n    private progress = 0\n    private error = false\n\n    public get id(): number {\n        return this._id;\n    }\n    public set id(value: number) {\n        this._id = value;\n    }\n\n    public getProgress(): number {\n        return this.progress;\n    }\n    public setProgress(value: number) {\n        this.progress = value;\n    }\n    public getError(): boolean {\n        return this.error;\n    }\n    public setError(value: boolean) {\n        this.error = value;\n    }\n\n    constructor(private _id: number) {\n    }\n}\n","import { Agv } from './agv.model';\n\nexport class WorkArea {\n    public get name(): string {\n        return this._name;\n    }\n    public set name(value: string) {\n        this._name = value;\n    }\n    public get agvList(): Agv[] {\n        return this._agvList;\n    }\n    public set agvList(value) {\n        this._agvList = value;\n    }\n    public get id(): number {\n        return this._id;\n    }\n    public set id(value) {\n        this._id = value;\n    }\n\n\n\n    constructor(private _id: number,private _name: string,private _agvList: Agv[]) {\n    }\n\n\n}\n","import { Injectable, NgZone } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SseService {\n\n\n  //NgZone to alert Angular when an event occurs because it happens outside of the framework.\n  \n  constructor(private ngZone: NgZone) { }\n\n  /**\n   * Creates event source\n   * @param url\n   */\n  getEventSource(url: string): EventSource {\n    return new EventSource(url);\n  }\n\n  getServerSentEvent(url: string) {\n  //  console.log(\"before\")\n    return Observable.create(observer => {\n    //  console.log(\"middle\")\n      const eventSource = this.getEventSource(url);\n      //console.log(\"after\")\n\n      eventSource.onmessage = event => {\n        //success\n        console.log(\"SseService on success\");\n        this.ngZone.run(() => {\n          observer.next(event);\n        })\n\n      }\n      eventSource.onerror = error => {\n        console.log(\"SseService on Error\");\n        this.ngZone.run(() => {\n          observer.next(error);\n        })\n      }\n    })\n\n  }\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UCAService {\n\n  constructor() { }\n}\n","import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { retry } from 'rxjs/operators';\nimport { Order } from 'src/app/model/order.model';\nimport { Task } from 'src/app/model/task.model';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UCCService {\n\n\n  private _subjectSelectedWorkAreaAndAgv: Subject<number[]>;\n  public get subjectSelectedWorkAreaAndAgv(): Subject<number[]> {\n    return this._subjectSelectedWorkAreaAndAgv;\n  }\n  public set subjectSelectedWorkAreaAndAgv(value: Subject<number[]>) {\n    this._subjectSelectedWorkAreaAndAgv = value;\n  }\n \n  public getSubjectSelectedWorkAreaAndAgv(): Observable<number[]> {\n    return this._subjectSelectedWorkAreaAndAgv.asObservable();\n  }\n\n  private _currentOrder: Order;\n\n  public get currentOrder(): Order {\n\n    if (this._currentOrder)\n      return this._currentOrder;\n    else {\n      let currentOrder = JSON.parse(localStorage.getItem('currentOrder'))\n      if (currentOrder)\n        return currentOrder as Order\n      else return null\n    }\n  }\n  public set currentOrder(value: Order) {\n    this._currentOrder = value;\n  }\n\n  constructor(private http: HttpClient) {\n    this.subjectSelectedWorkAreaAndAgv = new Subject();\n  }\n\n\n  getTaskListAgv<Task>(order_id: Number, agv_id: Number): Observable<Task[]> {\n    let url = `http://icowms.cloud.reply.eu/Details/getTaskListAgv?order_id=${order_id}&agv_id=${agv_id}`\n    return this.http.get<Task[]>(url).pipe(retry(3))\n  }\n\n  getTaskListOrder<Task>(order_id: Number): Observable<Task[]> {\n    let url = `http://icowms.cloud.reply.eu/Details/getTaskListOrder?order_id=${order_id}`\n    return this.http.get<Task[]>(url).pipe(retry(3))\n\n  }\n  getOrdListByDateAndUC<Order>(uc: string, timestamp: string): Observable<Order[]> {\n    let url = `http://icowms.cloud.reply.eu/Details/getOrdListbyDate?ts=${timestamp}&uc=${uc}`\n    return this.http.get<Order[]>(url).pipe(retry(3))\n\n  }\n  setTaskStatusOk(task_id: number) {\n    let url = `http://icowms.cloud.reply.eu/Details/updateStatusOK?task_id=${task_id}`\n    return this.http.get<any>(url).pipe(retry(3))\n  }\n\n  setSolveAction(solve_action_text: string, operator_ass_id: number, cobot_id: number, solve_act_mast_id: number, error_id: number): Observable<any> {\n    let url = `http://icowms.cloud.reply.eu/Details/insertSolveAction?solve_action=${solve_action_text}&operator_ass_id=${operator_ass_id}&cobot_id=${cobot_id}&solve_act_mast_id=${solve_act_mast_id}&error_id=${error_id}`\n    return this.http.get<any>(url).pipe(retry(3))\n  }\n\n\n  getLastActionError(task_id: number) {\n    let url = `http://icowms.cloud.reply.eu/Details/getLastActError?task_id=${task_id}`\n    return this.http.get<any>(url).pipe(retry(3))\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport * as CryptoJS from 'crypto-js';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n\n  constructor(private http: HttpClient) {\n\n  }\n\n\n\n  login(username: string, password: string): Observable<any> {\n    \n\n    var encrypted = CryptoJS.AES.encrypt(password, \"my-secret\");\n\n    console.log(encrypted.toString());\n\n    const URL: string = \"http://localhost:4200/pwd/Details/verifyPwd\";\n\n    return this.http.post<any>(URL, { login: username, pwd: encrypted.toString() });\n  }\n\n\n  isLogged() {\n    if (localStorage.getItem(\"session\"))\n      return true\n    else\n      return false\n  }\n\n}\n","// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\n","import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n","/* (ignored) */"],"sourceRoot":"webpack:///"}